{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/Nlvi/source/script/bootstarp.js","path":"script/bootstarp.js","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/style/style.styl","path":"style/style.styl","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/syuanpi/syuanpi.min.css","path":"syuanpi/syuanpi.min.css","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/script/src/plugins.js","path":"script/src/plugins.js","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/script/scheme/balance.js","path":"script/scheme/balance.js","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/script/scheme/banderole.js","path":"script/scheme/banderole.js","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/font/iconfont/iconfont.eot","path":"font/iconfont/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/script/src/nlvi.js","path":"script/src/nlvi.js","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/font/iconfont/iconfont.svg","path":"font/iconfont/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/font/iconfont/iconfont.ttf","path":"font/iconfont/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/font/iconfont/iconfont.woff","path":"font/iconfont/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/font/allura/allura.ttf","path":"font/allura/allura.ttf","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/script/lib/lazyload/lazyload.min.js","path":"script/lib/lazyload/lazyload.min.js","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/script/lib/jquery/jquery-3.2.1.min.js","path":"script/lib/jquery/jquery-3.2.1.min.js","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/script/lib/lightbox/css/lightbox.min.css","path":"script/lib/lightbox/css/lightbox.min.css","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/script/lib/lightbox/images/close.png","path":"script/lib/lightbox/images/close.png","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/script/lib/lightbox/images/loading.gif","path":"script/lib/lightbox/images/loading.gif","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/script/lib/lightbox/images/next.png","path":"script/lib/lightbox/images/next.png","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/script/lib/lightbox/images/prev.png","path":"script/lib/lightbox/images/prev.png","modified":1,"renderable":1},{"_id":"themes/Nlvi/source/script/lib/lightbox/js/lightbox.min.js","path":"script/lib/lightbox/js/lightbox.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/Nlvi/_config.yml","hash":"e5c7bfcfcdc719629bc296cbbc1a2440d360db72","modified":1559559832039},{"_id":"source/.DS_Store","hash":"283f8362195946f6fad7e1a75f425e32f9407509","modified":1543561873917},{"_id":"themes/Nlvi/README.md","hash":"b6215d0139806755603ae33a758f4ac6bbe5e5d8","modified":1553223804222},{"_id":"themes/Nlvi/LICENSE","hash":"6982c21214397aa93d5dd277a878b54499b32d26","modified":1553223804222},{"_id":"themes/Nlvi/package.json","hash":"f33b61768fb453e59a4f77d9b67a4663929972ea","modified":1553223804239},{"_id":"source/_posts/nginx.md","hash":"6ae56b56802f46af948cbcc1c23830c1cc37a795","modified":1559559801190},{"_id":"source/_posts/docker-react-app.md","hash":"5e55845554fd367ef24c52dca511add798e0cef3","modified":1557828675000},{"_id":"source/_posts/js-extends.md","hash":"7e03e370496b545bf26c1acf25368d3dadd128d0","modified":1596089592943},{"_id":"source/_posts/publish-subscribe.md","hash":"8b1fa23bc96f14e2cadbe0505dc32500d95acbf6","modified":1552891984000},{"_id":"source/_posts/simpe-webpack-project.md","hash":"a5f7cbddc342a0f7c0b2ca9075ecdad763641178","modified":1543220964000},{"_id":"source/_posts/simple-compiler.md","hash":"14b4ec768400a307a6b23571a60301d951b1f369","modified":1559559685459},{"_id":"source/_posts/software-entropy.md","hash":"5d19b3f21fff28835a96afe59e8122295d81b942","modified":1587525250860},{"_id":"source/_posts/object-oriented-for-miniapp.md","hash":"860e51609b5ae6dec757c43ac3d68eb2ab28185a","modified":1587521784270},{"_id":"source/_posts/browser-process.md","hash":"e73e1d9095736ac56987fa377f2137f6dfa02716","modified":1594949641883},{"_id":"source/_posts/socket.md","hash":"b551ab0bda9bb9fd380c8ab63da578c9f55d5f9a","modified":1597296782919},{"_id":"source/about/index.md","hash":"760186d55a53a04c323e6fd0184fdcefec464a94","modified":1553222396451},{"_id":"themes/Nlvi/languages/en.yml","hash":"0723d6f5c7e0aaed37826cebf56715489e2e803f","modified":1553223804224},{"_id":"themes/Nlvi/languages/ja.yml","hash":"4a0560f79c686f37191810a3667eedb90463c1f1","modified":1553223804224},{"_id":"themes/Nlvi/languages/zh-TW.yml","hash":"5d01de648d0e620006062da5fd3a7d23725d3c4e","modified":1553223804224},{"_id":"themes/Nlvi/languages/zh-CN.yml","hash":"3b3b71c3e3b48748ec09153340a019d373e6e78f","modified":1553223804224},{"_id":"themes/Nlvi/layout/_layout.swig","hash":"1949bdb7d67524ad92d0e062502c6932a0909fcf","modified":1553223804225},{"_id":"themes/Nlvi/layout/index.swig","hash":"d5f3471d053c3ed27b5bb95e83ebae50f7f407da","modified":1553224533657},{"_id":"themes/Nlvi/layout/page.swig","hash":"fc14f7b87184ee571f7fa0140c2d58ccddec8aa9","modified":1553223804238},{"_id":"themes/Nlvi/layout/archive.swig","hash":"a01a091054af5ee0e10e3a2bb8669593abfb8e08","modified":1553223804237},{"_id":"themes/Nlvi/languages/default.yml","hash":"0723d6f5c7e0aaed37826cebf56715489e2e803f","modified":1553223804223},{"_id":"themes/Nlvi/layout/post.swig","hash":"4649a9a0c2ec2241bc5a6ce37ab7799624a8d577","modified":1553223804238},{"_id":"themes/Nlvi/_source/about/index.md","hash":"760186d55a53a04c323e6fd0184fdcefec464a94","modified":1553223804223},{"_id":"themes/Nlvi/layout/_script/backtop.swig","hash":"ec2cb40299704e0b265b352db5c7545fc5ad9aac","modified":1553223804236},{"_id":"themes/Nlvi/layout/_script/config.swig","hash":"c38af2d9e8a9ab75812447369560eae8beae6540","modified":1559560207406},{"_id":"themes/Nlvi/layout/_script/script.swig","hash":"dcccc58a5ba6e083c8e358f470d585e5ab360e70","modified":1553223804237},{"_id":"themes/Nlvi/layout/_partial/archive.swig","hash":"0f5dee29901b71a17a2c52d01fd101cef57ace4a","modified":1559560069273},{"_id":"themes/Nlvi/layout/_partial/footer.swig","hash":"59ede514b2f629916830665d34c8aa21898f521d","modified":1553223804230},{"_id":"themes/Nlvi/layout/_partial/friendlink.swig","hash":"a33dbcca300217329eb0699385f769998cf2568f","modified":1553223804231},{"_id":"themes/Nlvi/layout/_partial/head.swig","hash":"46aaa8cff0c9ecd5f4502565e8437d3c60eb8821","modified":1553223804231},{"_id":"themes/Nlvi/layout/_partial/main.swig","hash":"76478b162c47c32fdb2ce98200e46241fb1623a6","modified":1553223804231},{"_id":"themes/Nlvi/layout/_partial/post.swig","hash":"72133de399c146459b32151ff87cc142e040363a","modified":1553223804232},{"_id":"themes/Nlvi/layout/_partial/header.swig","hash":"2e09870b6ae5ce49b8e5a85d052fbd4a3bd820d2","modified":1553223804231},{"_id":"themes/Nlvi/layout/_partial/pagenum.swig","hash":"1f3b9ea5f315c5dee1f554b5b6d363c13214fd60","modified":1553223804232},{"_id":"themes/Nlvi/layout/_partial/progress.swig","hash":"631faa669004de37b0a8812d709c95eb8948143e","modified":1553223804232},{"_id":"themes/Nlvi/layout/_partial/tagcloud.swig","hash":"96fe84d20323183a6337786aa0a1b7edbb309ad9","modified":1553223804233},{"_id":"themes/Nlvi/source/script/bootstarp.js","hash":"b467456b1b4491209197d9d7dd20e4cad0354b92","modified":1559558683359},{"_id":"themes/Nlvi/source/style/style.styl","hash":"824d69730060608a83be54b1784daf30d116695b","modified":1553223804262},{"_id":"themes/Nlvi/source/syuanpi/syuanpi.min.css","hash":"90f4530e067c1207c446f76865261f63550f29b7","modified":1553223804262},{"_id":"themes/Nlvi/source/script/src/plugins.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553223804250},{"_id":"themes/Nlvi/layout/_script/_plugin/search.swig","hash":"508fc7597aa9deee6e48c7697397b9cd8fb96524","modified":1553223804236},{"_id":"themes/Nlvi/layout/_script/_analytics/busuanzi.swig","hash":"f0c9bebbd1456fbac320fab6687a71fa12bcd69e","modified":1553223804233},{"_id":"themes/Nlvi/layout/_script/_analytics/google.swig","hash":"7531ea299737a6746051ed2e2964d3f72a178177","modified":1553223804234},{"_id":"themes/Nlvi/layout/_script/_analytics/baidu.swig","hash":"479c1e4486ea9832d4a0037da781ee991d7a6d50","modified":1553223804233},{"_id":"themes/Nlvi/layout/_script/_comment/gitment.swig","hash":"bf753589f9d10377ccec310f4510df4a840d2542","modified":1553223804235},{"_id":"themes/Nlvi/layout/_script/_comment/changyan.swig","hash":"d3304f4e58478c162cd5822815f4c06aacb18e0d","modified":1553223804235},{"_id":"themes/Nlvi/layout/_script/_comment/livere.swig","hash":"2c5636640d6cdbe16a2400c23410432804c5ddc5","modified":1553223804236},{"_id":"themes/Nlvi/layout/_script/_comment/disqus.swig","hash":"2e2e0e064f86936702ee5f1c880786581b7a5799","modified":1553223804235},{"_id":"themes/Nlvi/layout/_partial/_footer/contact.swig","hash":"355ebd0cf1a423abb0578c6ac044186a78a7041e","modified":1553234921028},{"_id":"themes/Nlvi/layout/_partial/_feature/balance.swig","hash":"0011ecc2e26e04d3fc17d05dc58d0fbf9d3e9043","modified":1553223804225},{"_id":"themes/Nlvi/layout/_partial/_feature/banderole.swig","hash":"9cfb539a98cae7e4ff3a09da9d5bd359d6744a58","modified":1553223804225},{"_id":"themes/Nlvi/layout/_partial/_feature/common.swig","hash":"257b9de47dfbd0e9caba7716212879b3fbd7d2ec","modified":1553223804226},{"_id":"themes/Nlvi/layout/_partial/_head/link.swig","hash":"8b8818d7b9919df1843d72fc7906646aecec7fb6","modified":1553223804227},{"_id":"themes/Nlvi/layout/_partial/_head/meta.swig","hash":"7fe1dc067679ce204f8e47d9c269cc651911c7ae","modified":1553223804228},{"_id":"themes/Nlvi/layout/_partial/_footer/copyright.swig","hash":"cbf06dbbd995407c64e65e7c57b3854b2be75893","modified":1553223804226},{"_id":"themes/Nlvi/layout/_partial/_header/logo.swig","hash":"e20cee30dd7acd408573af5cc6aeb653caf5cd07","modified":1553223804228},{"_id":"themes/Nlvi/layout/_partial/_header/mobile.swig","hash":"2cc8806a15e323fffffddee1bc249d31a8c59a21","modified":1553223804228},{"_id":"themes/Nlvi/layout/_partial/_header/nav.swig","hash":"cd721810933af3084cef0bfca1db35ffe5001b86","modified":1553223804229},{"_id":"themes/Nlvi/layout/_partial/_post/comments.swig","hash":"27603ed685bff4c59e304aae5a70b269c3983748","modified":1553223804229},{"_id":"themes/Nlvi/layout/_partial/_post/copyright.swig","hash":"c9626d9abdb342a11ab73d58b3f2e6dd625e8a80","modified":1553223804230},{"_id":"themes/Nlvi/layout/_partial/_post/reward.swig","hash":"9650d0611f27c10b00af35f865891126bda3a536","modified":1553223804230},{"_id":"themes/Nlvi/layout/_partial/_post/toc.swig","hash":"f7ff02d5971cdc24f2d96b8758992c57135b42f2","modified":1559558356866},{"_id":"themes/Nlvi/source/script/scheme/balance.js","hash":"a5ddcd25f9290f82cd5fb17affc23c5f6a12e100","modified":1559560280251},{"_id":"themes/Nlvi/source/script/scheme/banderole.js","hash":"8cc5c1278c38c73e02c8f15dfa3d5bcdc2cc7db9","modified":1559560393306},{"_id":"themes/Nlvi/source/font/iconfont/iconfont.eot","hash":"50dfc343891178ff2967be924a1d41caf6bbfc99","modified":1553223804241},{"_id":"themes/Nlvi/source/script/src/nlvi.js","hash":"8d23ed879e28094b2cbd673b5d6e191e519ac940","modified":1553223804249},{"_id":"themes/Nlvi/source/font/iconfont/iconfont.svg","hash":"21347d575656d3b337136a03336a8c724b34b623","modified":1553223804241},{"_id":"themes/Nlvi/source/font/iconfont/iconfont.ttf","hash":"6f2b83d658e10c74dd334f9cec0d41aeba4c4461","modified":1553223804242},{"_id":"themes/Nlvi/source/style/_common/animation.styl","hash":"c75c7ce292f2c494361e4e034faf31e25b8f606e","modified":1553223804251},{"_id":"themes/Nlvi/source/font/iconfont/iconfont.woff","hash":"ae747a96899ce947549df7d7f05c50db5466d18d","modified":1553223804242},{"_id":"themes/Nlvi/source/style/_common/func.styl","hash":"6990c98d28fa46109cca26f8f02fccead8ca8e41","modified":1553223804251},{"_id":"themes/Nlvi/source/style/_common/global.styl","hash":"5046017c56d5590036e93237b9f0371c4f4db9c6","modified":1553223804252},{"_id":"themes/Nlvi/source/style/_common/normalize.styl","hash":"0204871038355f90cb648f495ba26c9b29e69a5a","modified":1553223804253},{"_id":"themes/Nlvi/source/style/_common/variable.styl","hash":"7f30f76118108b6e008e29212758029af6573974","modified":1553223804253},{"_id":"themes/Nlvi/source/style/_custom/custom.styl","hash":"954a167563239ce54dc3907227fe192c65450b1d","modified":1553223804254},{"_id":"themes/Nlvi/source/style/_partial/footer.styl","hash":"0be237c30e723182e1ac9c16a4e56f8f6ba72d0d","modified":1553223804261},{"_id":"themes/Nlvi/source/font/allura/allura.ttf","hash":"9f36627fa1afab68887d63cf002ab6646e62a798","modified":1553223804240},{"_id":"themes/Nlvi/source/script/lib/lazyload/lazyload.min.js","hash":"65468ac83c83d506cf6ca4af8acf62e9d8461aed","modified":1553223804245},{"_id":"themes/Nlvi/source/style/_common/_utils/device.styl","hash":"8a6e225ef5018f601a1fb485d694d007eaff024f","modified":1553223804251},{"_id":"themes/Nlvi/source/style/_common/_utils/fonts.styl","hash":"97ebeef98cb46d5fd3c281a0ff2a49ba96d49013","modified":1553223804251},{"_id":"themes/Nlvi/source/style/_common/_utils/iconfont.styl","hash":"d104d1086beb7558701222aeeb608c938e26517e","modified":1553223804251},{"_id":"themes/Nlvi/source/style/_partial/_code/frame.styl","hash":"5cace14f2159175277636fdefacdfba93ba9f2dc","modified":1553223804255},{"_id":"themes/Nlvi/source/style/_partial/_code/index.styl","hash":"69cde3a96a19ac485cbc52832d5379faa57ab9f9","modified":1553223804255},{"_id":"themes/Nlvi/source/style/_partial/_page/paginator.styl","hash":"5c6e8c384c711fd5e51a4e88d58a975189a1aa05","modified":1553223804256},{"_id":"themes/Nlvi/source/style/_partial/_code/highlight.styl","hash":"79113830d23948e0df2f0ef6cf6231b7199c46dd","modified":1553223804255},{"_id":"themes/Nlvi/source/style/_partial/_common/archive.styl","hash":"e7aeb2412a73fe615d8ada99a702b9a2de8fd963","modified":1553223804255},{"_id":"themes/Nlvi/source/style/_partial/_common/about.styl","hash":"e850d7a6604353307081ecbe9774452a15188db0","modified":1553223804255},{"_id":"themes/Nlvi/source/style/_partial/_common/header.styl","hash":"3a535db5d4d7da892a4e966fe61e2d110d972736","modified":1553223804256},{"_id":"themes/Nlvi/source/style/_partial/_common/friendlink.styl","hash":"fb395c060ba99e45cf67e4f9b883ec4a2bde6cfd","modified":1553223804256},{"_id":"themes/Nlvi/source/style/_partial/_common/post.styl","hash":"99b57cd07df8542ff6c7480bf37b56a658c2b2c9","modified":1553223804256},{"_id":"themes/Nlvi/source/style/_partial/_post/copyright.styl","hash":"a79e4cc509eea2a95fb16d1b01f79c60f727f47b","modified":1553223804257},{"_id":"themes/Nlvi/source/style/_partial/_post/reward.styl","hash":"9cd00e07f14f164a46670deef23649a07c6466d4","modified":1553223804258},{"_id":"themes/Nlvi/source/style/_partial/_schemes/common.styl","hash":"ebcdd8c6cd492aa2ba97bcc7f50f5195fd747615","modified":1553223804261},{"_id":"themes/Nlvi/source/style/_partial/_utils/progress.styl","hash":"1f00cc3500b95e6e6d44032b9366ea43beb533f7","modified":1553223804261},{"_id":"themes/Nlvi/source/script/lib/jquery/jquery-3.2.1.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1553223804244},{"_id":"themes/Nlvi/source/script/lib/lightbox/css/lightbox.min.css","hash":"1eacd12cdeb43eb7f06360949e129e83e66dfec4","modified":1553223804246},{"_id":"themes/Nlvi/source/script/lib/lightbox/images/close.png","hash":"3ca48361cfe0e41163023d03c26296f375bb3eac","modified":1553223804247},{"_id":"themes/Nlvi/source/script/lib/lightbox/images/loading.gif","hash":"cf720b50cf8dde0e1a84ce1c6a77788bfc5882d5","modified":1553223804247},{"_id":"themes/Nlvi/source/script/lib/lightbox/images/next.png","hash":"777e92c050f600b4519299c3d786b8f2f459fea4","modified":1553223804247},{"_id":"themes/Nlvi/source/script/lib/lightbox/images/prev.png","hash":"6640a3432f7ba7aea6129cdf7a5d3eabd47c295c","modified":1553223804248},{"_id":"themes/Nlvi/source/script/lib/lightbox/js/lightbox.min.js","hash":"2cc5973fd9ee6fbbd5b9facb9862bc3318153f53","modified":1553223804248},{"_id":"themes/Nlvi/source/style/_partial/_schemes/_balance/index.styl","hash":"b98475026c556dbb2588349228382efd2a3bb23e","modified":1553223804259},{"_id":"themes/Nlvi/source/style/_partial/_schemes/_balance/container.styl","hash":"3947718d13ff4843ed78ee650eb5d55cdfd7ab64","modified":1553223804259},{"_id":"themes/Nlvi/source/style/_partial/_schemes/_balance/header.styl","hash":"4bae68e02ee7e6f2209d95a254b22fe92ebdea80","modified":1553223804259},{"_id":"themes/Nlvi/source/style/_partial/_schemes/_banderole/container.styl","hash":"398fe712e1aed9535c68604ab1aba17059a1369d","modified":1553223804261},{"_id":"themes/Nlvi/source/style/_partial/_schemes/_banderole/header.styl","hash":"2ce04a35c85ec64019dc6812307c63b3488e215d","modified":1553223804261},{"_id":"themes/Nlvi/source/style/_partial/_schemes/_banderole/index.styl","hash":"cc41a84a02847d093a07ccefdfa57cc0fe688c08","modified":1553223804261},{"_id":"themes/Nlvi/source/style/_partial/_schemes/_balance/_utils/tagcloud.styl","hash":"19880aa3b2e246610b4eb012950c6d52ad4e1fd9","modified":1553223804259},{"_id":"themes/Nlvi/source/style/_partial/_schemes/_balance/_post/toc.styl","hash":"5d66be15bb7041818e1589e5f9c39dd6d7f58c06","modified":1553223804258},{"_id":"themes/Nlvi/source/style/_partial/_schemes/_balance/_utils/backtop.styl","hash":"2a26dc6566ab79f21724bc8b6106ccf5c5952f42","modified":1553223804259},{"_id":"themes/Nlvi/source/style/_partial/_schemes/_banderole/_post/toc.styl","hash":"998f1346fe63e8653964eebf7abee8d0dc1a4bd7","modified":1553223804260},{"_id":"themes/Nlvi/source/style/_partial/_schemes/_banderole/_utils/backtop.styl","hash":"4bbf20c4006a745870c58bd6966613c019d5e76d","modified":1553223804260},{"_id":"themes/Nlvi/source/style/_partial/_schemes/_banderole/_utils/search.styl","hash":"2669b8d329900cad20f767af5e736a272e732978","modified":1553223804260},{"_id":"themes/Nlvi/source/style/_partial/_schemes/_banderole/_utils/tagcloud.styl","hash":"42d7d4793209098d319fda519a6831ee7b393dfe","modified":1553223804260}],"Category":[],"Data":[],"Page":[{"title":"About","type":"about","comments":0,"_content":"","source":"about/index.md","raw":"title: About\ntype: \"about\"\ncomments: false\n---","date":"2019-03-22T02:39:56.451Z","updated":"2019-03-22T02:39:56.451Z","path":"about/index.html","layout":"page","_id":"ckdsjt88e0005falv9quz61la","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"使用nginx做反代理以及添加SSL。","date":"2019-06-03T11:03:21.190Z","_content":"<br/>\n\n# 前言\n\n本篇适合入门nginx或需要对自己的网站做ssl的情况。\n自己为了要做小程序需要ssl，就整理了一些流程，自己之后也可以回顾。\n\n<!--more-->\n\n<!-- toc -->\n\n## 安装nginx\n\n```bash\nsudo yum install -y nginx\n```\n\n# 使用nginx\n\n```bash\n/usr/local/nginx/sbin/nginx // 启动\n/usr/local/nginx/sbin/nginx -s stop // 停止\n/usr/local/nginx/sbin/nginx -s restart // 重启\n```\n\n## 添加环境变量\n\n打开bash_profile文件\n\n```bash\nvim ~/.bash_profile\n```\n在PATH那一行添加nginx的指令路径，我这边是/usr/local/nginx/sbin，注意用 : 来分割\n\n```bash\nPATH=$PATH:$HOME/bin:/usr/local/nginx/sbin\n```\n\n## 配置nginx\n\n假设测试域名 www.*****.cn\n\n```conf\nserver\n    {\n        #监听端口\n        listen 80;\n\n        #域名可以有多个，用空格隔开\n        server_name www.*****.cn;\n        index index.html index.htm index.php;\n        root /data/www/myproject; #你的项目目录\n\n        #对******进行负载均衡\n        location ~ .*.(php|php5)?$\n        {\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            include fastcgi.conf;\n        }\n         \n        #图片缓存时间设置\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n            expires 10d;\n        }\n         \n        #JS和CSS缓存时间设置\n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n         \n        #日志格式设定\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\n        #$remote_user：用来记录客户端用户名称；\n        #$time_local： 用来记录访问时间与时区；\n        #$request： 用来记录请求的url与http协议；\n        #$status： 用来记录请求状态；成功是200，\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\n        #$http_referer：用来记录从那个页面链接访问过来的；\n        #$http_user_agent：记录客户浏览器的相关信息；\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\n        log_format access '$remote_addr - $remote_user [$time_local] \"$request\" '\n        '$status $body_bytes_sent \"$http_referer\" '\n        '\"$http_user_agent\" $http_x_forwarded_for';\n         \n        #定义本虚拟主机的访问日志\n        access_log  /usr/local/nginx/logs/host.access.log  main;\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\n         \n        #对 \"/\" 启用反向代理\n        location / {\n            proxy_pass http://127.0.0.1:88;\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n             \n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n             \n            #以下是一些反向代理的配置，可选。\n            proxy_set_header Host $host;\n\n            #允许客户端请求的最大单文件字节数\n            client_max_body_size 10m;\n\n            #缓冲区代理缓冲用户端请求的最大字节数，\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\n            client_body_buffer_size 128k;\n\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\n            proxy_intercept_errors on;\n\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\n            #nginx跟后端服务器连接超时时间(代理连接超时)\n            proxy_connect_timeout 90;\n\n            #后端服务器数据回传时间(代理发送超时)\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\n            proxy_send_timeout 90;\n\n            #连接成功后，后端服务器响应时间(代理接收超时)\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\n            proxy_read_timeout 90;\n\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\n            proxy_buffer_size 4k;\n\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\n            proxy_buffers 4 32k;\n\n            #高负荷下缓冲大小（proxy_buffers*2）\n            proxy_busy_buffers_size 64k;\n\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n            proxy_temp_file_write_size 64k;\n        }\n         \n         \n        #设定查看Nginx状态的地址\n        location /NginxStatus {\n            stub_status on;\n            access_log on;\n            auth_basic \"NginxStatus\";\n            auth_basic_user_file confpasswd;\n            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。\n        }\n         \n        #本地动静分离反向代理配置\n        #所有jsp的页面均交由tomcat或resin处理\n        location ~ .(jsp|jspx|do)?$ {\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://127.0.0.1:8080;\n        }\n         \n        #所有静态文件由nginx直接读取不经过tomcat或resin\n        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|\n        pdf|xls|mp3|wma)$\n        {\n            expires 15d; \n        }\n         \n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n    }\n```\n\n## 启动nginx\n\n```BASH\nnginx\n```\n或者\n```bash\nnginx -c /usr/local/nginx/conf/nginx.conf\n```\n\n# 添加ssl\n\n这里选择用centosrhel7-nginx来实现ssl，以下有教程也可以选择看官网\n<a href=\"https://certbot.eff.org/lets-encrypt/centosrhel7-nginx\">centosrhel7-nginx</a>\n\n## 安装\n\n```bash\nyum install certbot python2-certbot-nginx\n```\n\n## 重新编译生成nginx并覆盖旧的\n\n### nginx开启ssl模块\n\n切换到源码包，这边是用的是nginx-1.6.2\n```bash\ncd /usr/local/nginx/nginx-1.6.2 \n./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module // 重新配置参数\n```\n等配置完成后运行命令\n\n```bash\nmake\n```\n\n编译完成后会在objs目录下生成一个新的nginx执行模块，将这个模块复制到/usr/local/nginx/sbin/ 目录下， 记得先备份\n输入 nginx -V 看是否有新增的参数\n\n```bash\ncp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak // 备份\ncp ./objs/nginx /usr/local/nginx/sbin // 更新\nnginx -V \n// 输出 configure arguments: --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module\n```\n\n## 启动certbot\n\n```bash\ncertbot --nginx\n```\n\n## 设置定时脚本\n\n由于certbot的证书是90天就过期，因此建议做个定时脚本定时renew\n```bash\ncrontab -e\n```\n在vim编辑器中输入\n```bash\n0 0,12 * * * python -c 'import random; import time; time.sleep(random.random() * 3600)' && certbot renew\n// 这段指令表示 12点0分0秒 执行 python 脚本，延迟结束后执行certbot renew，重新续订证书\n```\n\n完","source":"_posts/nginx.md","raw":"---\ntitle: 使用nginx做反代理以及添加SSL。\ndate: 2019年06月3日\n---\n<br/>\n\n# 前言\n\n本篇适合入门nginx或需要对自己的网站做ssl的情况。\n自己为了要做小程序需要ssl，就整理了一些流程，自己之后也可以回顾。\n\n<!--more-->\n\n<!-- toc -->\n\n## 安装nginx\n\n```bash\nsudo yum install -y nginx\n```\n\n# 使用nginx\n\n```bash\n/usr/local/nginx/sbin/nginx // 启动\n/usr/local/nginx/sbin/nginx -s stop // 停止\n/usr/local/nginx/sbin/nginx -s restart // 重启\n```\n\n## 添加环境变量\n\n打开bash_profile文件\n\n```bash\nvim ~/.bash_profile\n```\n在PATH那一行添加nginx的指令路径，我这边是/usr/local/nginx/sbin，注意用 : 来分割\n\n```bash\nPATH=$PATH:$HOME/bin:/usr/local/nginx/sbin\n```\n\n## 配置nginx\n\n假设测试域名 www.*****.cn\n\n```conf\nserver\n    {\n        #监听端口\n        listen 80;\n\n        #域名可以有多个，用空格隔开\n        server_name www.*****.cn;\n        index index.html index.htm index.php;\n        root /data/www/myproject; #你的项目目录\n\n        #对******进行负载均衡\n        location ~ .*.(php|php5)?$\n        {\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            include fastcgi.conf;\n        }\n         \n        #图片缓存时间设置\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n            expires 10d;\n        }\n         \n        #JS和CSS缓存时间设置\n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n         \n        #日志格式设定\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\n        #$remote_user：用来记录客户端用户名称；\n        #$time_local： 用来记录访问时间与时区；\n        #$request： 用来记录请求的url与http协议；\n        #$status： 用来记录请求状态；成功是200，\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\n        #$http_referer：用来记录从那个页面链接访问过来的；\n        #$http_user_agent：记录客户浏览器的相关信息；\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\n        log_format access '$remote_addr - $remote_user [$time_local] \"$request\" '\n        '$status $body_bytes_sent \"$http_referer\" '\n        '\"$http_user_agent\" $http_x_forwarded_for';\n         \n        #定义本虚拟主机的访问日志\n        access_log  /usr/local/nginx/logs/host.access.log  main;\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\n         \n        #对 \"/\" 启用反向代理\n        location / {\n            proxy_pass http://127.0.0.1:88;\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n             \n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n             \n            #以下是一些反向代理的配置，可选。\n            proxy_set_header Host $host;\n\n            #允许客户端请求的最大单文件字节数\n            client_max_body_size 10m;\n\n            #缓冲区代理缓冲用户端请求的最大字节数，\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\n            client_body_buffer_size 128k;\n\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\n            proxy_intercept_errors on;\n\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\n            #nginx跟后端服务器连接超时时间(代理连接超时)\n            proxy_connect_timeout 90;\n\n            #后端服务器数据回传时间(代理发送超时)\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\n            proxy_send_timeout 90;\n\n            #连接成功后，后端服务器响应时间(代理接收超时)\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\n            proxy_read_timeout 90;\n\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\n            proxy_buffer_size 4k;\n\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\n            proxy_buffers 4 32k;\n\n            #高负荷下缓冲大小（proxy_buffers*2）\n            proxy_busy_buffers_size 64k;\n\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n            proxy_temp_file_write_size 64k;\n        }\n         \n         \n        #设定查看Nginx状态的地址\n        location /NginxStatus {\n            stub_status on;\n            access_log on;\n            auth_basic \"NginxStatus\";\n            auth_basic_user_file confpasswd;\n            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。\n        }\n         \n        #本地动静分离反向代理配置\n        #所有jsp的页面均交由tomcat或resin处理\n        location ~ .(jsp|jspx|do)?$ {\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://127.0.0.1:8080;\n        }\n         \n        #所有静态文件由nginx直接读取不经过tomcat或resin\n        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|\n        pdf|xls|mp3|wma)$\n        {\n            expires 15d; \n        }\n         \n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n    }\n```\n\n## 启动nginx\n\n```BASH\nnginx\n```\n或者\n```bash\nnginx -c /usr/local/nginx/conf/nginx.conf\n```\n\n# 添加ssl\n\n这里选择用centosrhel7-nginx来实现ssl，以下有教程也可以选择看官网\n<a href=\"https://certbot.eff.org/lets-encrypt/centosrhel7-nginx\">centosrhel7-nginx</a>\n\n## 安装\n\n```bash\nyum install certbot python2-certbot-nginx\n```\n\n## 重新编译生成nginx并覆盖旧的\n\n### nginx开启ssl模块\n\n切换到源码包，这边是用的是nginx-1.6.2\n```bash\ncd /usr/local/nginx/nginx-1.6.2 \n./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module // 重新配置参数\n```\n等配置完成后运行命令\n\n```bash\nmake\n```\n\n编译完成后会在objs目录下生成一个新的nginx执行模块，将这个模块复制到/usr/local/nginx/sbin/ 目录下， 记得先备份\n输入 nginx -V 看是否有新增的参数\n\n```bash\ncp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak // 备份\ncp ./objs/nginx /usr/local/nginx/sbin // 更新\nnginx -V \n// 输出 configure arguments: --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module\n```\n\n## 启动certbot\n\n```bash\ncertbot --nginx\n```\n\n## 设置定时脚本\n\n由于certbot的证书是90天就过期，因此建议做个定时脚本定时renew\n```bash\ncrontab -e\n```\n在vim编辑器中输入\n```bash\n0 0,12 * * * python -c 'import random; import time; time.sleep(random.random() * 3600)' && certbot renew\n// 这段指令表示 12点0分0秒 执行 python 脚本，延迟结束后执行certbot renew，重新续订证书\n```\n\n完","slug":"nginx","published":1,"updated":"2019-06-03T11:03:21.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdsjt87h0000falvdfzx5vht","content":"<p><br></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本篇适合入门nginx或需要对自己的网站做ssl的情况。<br>自己为了要做小程序需要ssl，就整理了一些流程，自己之后也可以回顾。</p>\n<a id=\"more\"></a>\n<!-- toc -->\n<h2 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装nginx</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y nginx</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用nginx\"><a href=\"#使用nginx\" class=\"headerlink\" title=\"使用nginx\"></a>使用nginx</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx // 启动</span><br><span class=\"line\">/usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx -s stop // 停止</span><br><span class=\"line\">/usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx -s restart // 重启</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加环境变量\"><a href=\"#添加环境变量\" class=\"headerlink\" title=\"添加环境变量\"></a>添加环境变量</h2><p>打开bash_profile文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>在PATH那一行添加nginx的指令路径，我这边是/usr/local/nginx/sbin，注意用 : 来分割</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$HOME</span>/bin:/usr/<span class=\"built_in\">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置nginx\"><a href=\"#配置nginx\" class=\"headerlink\" title=\"配置nginx\"></a>配置nginx</h2><p>假设测试域名 www.<strong>*</strong>.cn</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        #监听端口</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\"></span><br><span class=\"line\">        #域名可以有多个，用空格隔开</span><br><span class=\"line\">        server_name www.*****.cn;</span><br><span class=\"line\">        index index.html index.htm index.php;</span><br><span class=\"line\">        root /data/www/myproject; #你的项目目录</span><br><span class=\"line\"></span><br><span class=\"line\">        #对******进行负载均衡</span><br><span class=\"line\">        location ~ .*.(php|php5)?$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fastcgi_pass 127.0.0.1:9000;</span><br><span class=\"line\">            fastcgi_index index.php;</span><br><span class=\"line\">            include fastcgi.conf;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #图片缓存时间设置</span><br><span class=\"line\">        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            expires 10d;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #JS和CSS缓存时间设置</span><br><span class=\"line\">        location ~ .*.(js|css)?$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            expires 1h;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #日志格式设定</span><br><span class=\"line\">        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span><br><span class=\"line\">        #$remote_user：用来记录客户端用户名称；</span><br><span class=\"line\">        #$time_local： 用来记录访问时间与时区；</span><br><span class=\"line\">        #$request： 用来记录请求的url与http协议；</span><br><span class=\"line\">        #$status： 用来记录请求状态；成功是200，</span><br><span class=\"line\">        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span><br><span class=\"line\">        #$http_referer：用来记录从那个页面链接访问过来的；</span><br><span class=\"line\">        #$http_user_agent：记录客户浏览器的相关信息；</span><br><span class=\"line\">        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span><br><span class=\"line\">        log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class=\"line\">        &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class=\"line\">        &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #定义本虚拟主机的访问日志</span><br><span class=\"line\">        access_log  /usr/local/nginx/logs/host.access.log  main;</span><br><span class=\"line\">        access_log  /usr/local/nginx/logs/host.access.404.log  log404;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #对 &quot;/&quot; 启用反向代理</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            proxy_pass http://127.0.0.1:88;</span><br><span class=\"line\">            proxy_redirect off;</span><br><span class=\"line\">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">             </span><br><span class=\"line\">            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class=\"line\">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">             </span><br><span class=\"line\">            #以下是一些反向代理的配置，可选。</span><br><span class=\"line\">            proxy_set_header Host $host;</span><br><span class=\"line\"></span><br><span class=\"line\">            #允许客户端请求的最大单文件字节数</span><br><span class=\"line\">            client_max_body_size 10m;</span><br><span class=\"line\"></span><br><span class=\"line\">            #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class=\"line\">            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span><br><span class=\"line\">            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span><br><span class=\"line\">            client_body_buffer_size 128k;</span><br><span class=\"line\"></span><br><span class=\"line\">            #表示使nginx阻止HTTP应答代码为400或者更高的应答。</span><br><span class=\"line\">            proxy_intercept_errors on;</span><br><span class=\"line\"></span><br><span class=\"line\">            #后端服务器连接的超时时间_发起握手等候响应超时时间</span><br><span class=\"line\">            #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class=\"line\">            proxy_connect_timeout 90;</span><br><span class=\"line\"></span><br><span class=\"line\">            #后端服务器数据回传时间(代理发送超时)</span><br><span class=\"line\">            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span><br><span class=\"line\">            proxy_send_timeout 90;</span><br><span class=\"line\"></span><br><span class=\"line\">            #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class=\"line\">            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span><br><span class=\"line\">            proxy_read_timeout 90;</span><br><span class=\"line\"></span><br><span class=\"line\">            #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class=\"line\">            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span><br><span class=\"line\">            proxy_buffer_size 4k;</span><br><span class=\"line\"></span><br><span class=\"line\">            #proxy_buffers缓冲区，网页平均在32k以下的设置</span><br><span class=\"line\">            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span><br><span class=\"line\">            proxy_buffers 4 32k;</span><br><span class=\"line\"></span><br><span class=\"line\">            #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class=\"line\">            proxy_busy_buffers_size 64k;</span><br><span class=\"line\"></span><br><span class=\"line\">            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span><br><span class=\"line\">            #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class=\"line\">            proxy_temp_file_write_size 64k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">         </span><br><span class=\"line\">        #设定查看Nginx状态的地址</span><br><span class=\"line\">        location /NginxStatus &#123;</span><br><span class=\"line\">            stub_status on;</span><br><span class=\"line\">            access_log on;</span><br><span class=\"line\">            auth_basic &quot;NginxStatus&quot;;</span><br><span class=\"line\">            auth_basic_user_file confpasswd;</span><br><span class=\"line\">            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #本地动静分离反向代理配置</span><br><span class=\"line\">        #所有jsp的页面均交由tomcat或resin处理</span><br><span class=\"line\">        location ~ .(jsp|jspx|do)?$ &#123;</span><br><span class=\"line\">            proxy_set_header Host $host;</span><br><span class=\"line\">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">            proxy_pass http://127.0.0.1:8080;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #所有静态文件由nginx直接读取不经过tomcat或resin</span><br><span class=\"line\">        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|</span><br><span class=\"line\">        pdf|xls|mp3|wma)$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            expires 15d; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        location ~ .*.(js|css)?$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            expires 1h;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动nginx\"><a href=\"#启动nginx\" class=\"headerlink\" title=\"启动nginx\"></a>启动nginx</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx</span><br></pre></td></tr></table></figure>\n<p>或者<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c /usr/<span class=\"built_in\">local</span>/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"添加ssl\"><a href=\"#添加ssl\" class=\"headerlink\" title=\"添加ssl\"></a>添加ssl</h1><p>这里选择用centosrhel7-nginx来实现ssl，以下有教程也可以选择看官网<br><a href=\"https://certbot.eff.org/lets-encrypt/centosrhel7-nginx\" target=\"_blank\" rel=\"noopener\">centosrhel7-nginx</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install certbot python2-certbot-nginx</span><br></pre></td></tr></table></figure>\n<h2 id=\"重新编译生成nginx并覆盖旧的\"><a href=\"#重新编译生成nginx并覆盖旧的\" class=\"headerlink\" title=\"重新编译生成nginx并覆盖旧的\"></a>重新编译生成nginx并覆盖旧的</h2><h3 id=\"nginx开启ssl模块\"><a href=\"#nginx开启ssl模块\" class=\"headerlink\" title=\"nginx开启ssl模块\"></a>nginx开启ssl模块</h3><p>切换到源码包，这边是用的是nginx-1.6.2<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/nginx/nginx-1.6.2 </span><br><span class=\"line\">./configure --prefix=/usr/<span class=\"built_in\">local</span>/nginx --with-http_stub_status_module --with-http_ssl_module // 重新配置参数</span><br></pre></td></tr></table></figure></p>\n<p>等配置完成后运行命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<p>编译完成后会在objs目录下生成一个新的nginx执行模块，将这个模块复制到/usr/local/nginx/sbin/ 目录下， 记得先备份<br>输入 nginx -V 看是否有新增的参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx /usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx.bak // 备份</span><br><span class=\"line\">cp ./objs/nginx /usr/<span class=\"built_in\">local</span>/nginx/sbin // 更新</span><br><span class=\"line\">nginx -V </span><br><span class=\"line\">// 输出 configure arguments: --prefix=/usr/<span class=\"built_in\">local</span>/nginx --with-http_stub_status_module --with-http_ssl_module</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动certbot\"><a href=\"#启动certbot\" class=\"headerlink\" title=\"启动certbot\"></a>启动certbot</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">certbot --nginx</span><br></pre></td></tr></table></figure>\n<h2 id=\"设置定时脚本\"><a href=\"#设置定时脚本\" class=\"headerlink\" title=\"设置定时脚本\"></a>设置定时脚本</h2><p>由于certbot的证书是90天就过期，因此建议做个定时脚本定时renew<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -e</span><br></pre></td></tr></table></figure></p>\n<p>在vim编辑器中输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 0,12 * * * python -c <span class=\"string\">'import random; import time; time.sleep(random.random() * 3600)'</span> &amp;&amp; certbot renew</span><br><span class=\"line\">// 这段指令表示 12点0分0秒 执行 python 脚本，延迟结束后执行certbot renew，重新续订证书</span><br></pre></td></tr></table></figure></p>\n<p>完</p>\n","site":{"data":{}},"excerpt":"<p><br></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本篇适合入门nginx或需要对自己的网站做ssl的情况。<br>自己为了要做小程序需要ssl，就整理了一些流程，自己之后也可以回顾。</p>","more":"<!-- toc -->\n<h2 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装nginx</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y nginx</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用nginx\"><a href=\"#使用nginx\" class=\"headerlink\" title=\"使用nginx\"></a>使用nginx</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx // 启动</span><br><span class=\"line\">/usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx -s stop // 停止</span><br><span class=\"line\">/usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx -s restart // 重启</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加环境变量\"><a href=\"#添加环境变量\" class=\"headerlink\" title=\"添加环境变量\"></a>添加环境变量</h2><p>打开bash_profile文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>在PATH那一行添加nginx的指令路径，我这边是/usr/local/nginx/sbin，注意用 : 来分割</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$HOME</span>/bin:/usr/<span class=\"built_in\">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置nginx\"><a href=\"#配置nginx\" class=\"headerlink\" title=\"配置nginx\"></a>配置nginx</h2><p>假设测试域名 www.<strong>*</strong>.cn</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        #监听端口</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\"></span><br><span class=\"line\">        #域名可以有多个，用空格隔开</span><br><span class=\"line\">        server_name www.*****.cn;</span><br><span class=\"line\">        index index.html index.htm index.php;</span><br><span class=\"line\">        root /data/www/myproject; #你的项目目录</span><br><span class=\"line\"></span><br><span class=\"line\">        #对******进行负载均衡</span><br><span class=\"line\">        location ~ .*.(php|php5)?$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fastcgi_pass 127.0.0.1:9000;</span><br><span class=\"line\">            fastcgi_index index.php;</span><br><span class=\"line\">            include fastcgi.conf;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #图片缓存时间设置</span><br><span class=\"line\">        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            expires 10d;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #JS和CSS缓存时间设置</span><br><span class=\"line\">        location ~ .*.(js|css)?$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            expires 1h;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #日志格式设定</span><br><span class=\"line\">        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span><br><span class=\"line\">        #$remote_user：用来记录客户端用户名称；</span><br><span class=\"line\">        #$time_local： 用来记录访问时间与时区；</span><br><span class=\"line\">        #$request： 用来记录请求的url与http协议；</span><br><span class=\"line\">        #$status： 用来记录请求状态；成功是200，</span><br><span class=\"line\">        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span><br><span class=\"line\">        #$http_referer：用来记录从那个页面链接访问过来的；</span><br><span class=\"line\">        #$http_user_agent：记录客户浏览器的相关信息；</span><br><span class=\"line\">        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span><br><span class=\"line\">        log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class=\"line\">        &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class=\"line\">        &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #定义本虚拟主机的访问日志</span><br><span class=\"line\">        access_log  /usr/local/nginx/logs/host.access.log  main;</span><br><span class=\"line\">        access_log  /usr/local/nginx/logs/host.access.404.log  log404;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #对 &quot;/&quot; 启用反向代理</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            proxy_pass http://127.0.0.1:88;</span><br><span class=\"line\">            proxy_redirect off;</span><br><span class=\"line\">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">             </span><br><span class=\"line\">            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class=\"line\">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">             </span><br><span class=\"line\">            #以下是一些反向代理的配置，可选。</span><br><span class=\"line\">            proxy_set_header Host $host;</span><br><span class=\"line\"></span><br><span class=\"line\">            #允许客户端请求的最大单文件字节数</span><br><span class=\"line\">            client_max_body_size 10m;</span><br><span class=\"line\"></span><br><span class=\"line\">            #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class=\"line\">            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span><br><span class=\"line\">            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span><br><span class=\"line\">            client_body_buffer_size 128k;</span><br><span class=\"line\"></span><br><span class=\"line\">            #表示使nginx阻止HTTP应答代码为400或者更高的应答。</span><br><span class=\"line\">            proxy_intercept_errors on;</span><br><span class=\"line\"></span><br><span class=\"line\">            #后端服务器连接的超时时间_发起握手等候响应超时时间</span><br><span class=\"line\">            #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class=\"line\">            proxy_connect_timeout 90;</span><br><span class=\"line\"></span><br><span class=\"line\">            #后端服务器数据回传时间(代理发送超时)</span><br><span class=\"line\">            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span><br><span class=\"line\">            proxy_send_timeout 90;</span><br><span class=\"line\"></span><br><span class=\"line\">            #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class=\"line\">            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span><br><span class=\"line\">            proxy_read_timeout 90;</span><br><span class=\"line\"></span><br><span class=\"line\">            #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class=\"line\">            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span><br><span class=\"line\">            proxy_buffer_size 4k;</span><br><span class=\"line\"></span><br><span class=\"line\">            #proxy_buffers缓冲区，网页平均在32k以下的设置</span><br><span class=\"line\">            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span><br><span class=\"line\">            proxy_buffers 4 32k;</span><br><span class=\"line\"></span><br><span class=\"line\">            #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class=\"line\">            proxy_busy_buffers_size 64k;</span><br><span class=\"line\"></span><br><span class=\"line\">            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span><br><span class=\"line\">            #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class=\"line\">            proxy_temp_file_write_size 64k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">         </span><br><span class=\"line\">        #设定查看Nginx状态的地址</span><br><span class=\"line\">        location /NginxStatus &#123;</span><br><span class=\"line\">            stub_status on;</span><br><span class=\"line\">            access_log on;</span><br><span class=\"line\">            auth_basic &quot;NginxStatus&quot;;</span><br><span class=\"line\">            auth_basic_user_file confpasswd;</span><br><span class=\"line\">            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #本地动静分离反向代理配置</span><br><span class=\"line\">        #所有jsp的页面均交由tomcat或resin处理</span><br><span class=\"line\">        location ~ .(jsp|jspx|do)?$ &#123;</span><br><span class=\"line\">            proxy_set_header Host $host;</span><br><span class=\"line\">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">            proxy_pass http://127.0.0.1:8080;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        #所有静态文件由nginx直接读取不经过tomcat或resin</span><br><span class=\"line\">        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|</span><br><span class=\"line\">        pdf|xls|mp3|wma)$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            expires 15d; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        location ~ .*.(js|css)?$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            expires 1h;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动nginx\"><a href=\"#启动nginx\" class=\"headerlink\" title=\"启动nginx\"></a>启动nginx</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx</span><br></pre></td></tr></table></figure>\n<p>或者<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c /usr/<span class=\"built_in\">local</span>/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"添加ssl\"><a href=\"#添加ssl\" class=\"headerlink\" title=\"添加ssl\"></a>添加ssl</h1><p>这里选择用centosrhel7-nginx来实现ssl，以下有教程也可以选择看官网<br><a href=\"https://certbot.eff.org/lets-encrypt/centosrhel7-nginx\" target=\"_blank\" rel=\"noopener\">centosrhel7-nginx</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install certbot python2-certbot-nginx</span><br></pre></td></tr></table></figure>\n<h2 id=\"重新编译生成nginx并覆盖旧的\"><a href=\"#重新编译生成nginx并覆盖旧的\" class=\"headerlink\" title=\"重新编译生成nginx并覆盖旧的\"></a>重新编译生成nginx并覆盖旧的</h2><h3 id=\"nginx开启ssl模块\"><a href=\"#nginx开启ssl模块\" class=\"headerlink\" title=\"nginx开启ssl模块\"></a>nginx开启ssl模块</h3><p>切换到源码包，这边是用的是nginx-1.6.2<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/nginx/nginx-1.6.2 </span><br><span class=\"line\">./configure --prefix=/usr/<span class=\"built_in\">local</span>/nginx --with-http_stub_status_module --with-http_ssl_module // 重新配置参数</span><br></pre></td></tr></table></figure></p>\n<p>等配置完成后运行命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<p>编译完成后会在objs目录下生成一个新的nginx执行模块，将这个模块复制到/usr/local/nginx/sbin/ 目录下， 记得先备份<br>输入 nginx -V 看是否有新增的参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx /usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx.bak // 备份</span><br><span class=\"line\">cp ./objs/nginx /usr/<span class=\"built_in\">local</span>/nginx/sbin // 更新</span><br><span class=\"line\">nginx -V </span><br><span class=\"line\">// 输出 configure arguments: --prefix=/usr/<span class=\"built_in\">local</span>/nginx --with-http_stub_status_module --with-http_ssl_module</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动certbot\"><a href=\"#启动certbot\" class=\"headerlink\" title=\"启动certbot\"></a>启动certbot</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">certbot --nginx</span><br></pre></td></tr></table></figure>\n<h2 id=\"设置定时脚本\"><a href=\"#设置定时脚本\" class=\"headerlink\" title=\"设置定时脚本\"></a>设置定时脚本</h2><p>由于certbot的证书是90天就过期，因此建议做个定时脚本定时renew<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -e</span><br></pre></td></tr></table></figure></p>\n<p>在vim编辑器中输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 0,12 * * * python -c <span class=\"string\">'import random; import time; time.sleep(random.random() * 3600)'</span> &amp;&amp; certbot renew</span><br><span class=\"line\">// 这段指令表示 12点0分0秒 执行 python 脚本，延迟结束后执行certbot renew，重新续订证书</span><br></pre></td></tr></table></figure></p>\n<p>完</p>"},{"title":"用docker来构建一个react项目镜像（一）","date":"2019-05-14T10:11:15.000Z","_content":"\n<br/>\n\n前言\n====\n最近在捣鼓自己的一个小站点，但是每次更新项目都要发布后总是ssh，然后重启nginx，属实麻烦，就尝试使用Jenkins来部署自动化，但在这之前要了解一下docker。\n就尝试用docker来构建一个react项目。\n\n<!--more-->\n\n####创建一个react-app项目\n\n这里就直接使用create-react-app 脚手架了。\n\n安装脚手架\n```npm\n   npm install -g create-react-app\n```\n\n完事后执行以下指令，创建一个目录\n```vue\n   create-react-app docker-demo\n```\n\n在创建后的根目录下面新建一个Dockerfile文件\n并键入以下代码：\n```vue\n# 使用node版本11.12.0\nFROM node:11.12.0\n\n# 代表生产环境\nENV PROJECT_ENV production\n# 许多 package 会根据此环境变量，做出不同的行为\n# 另外，在 webpack 中打包也会根据此环境变量做出优化，但是 create-react-app 在打包时会写死该环境变量\nENV NODE_ENV production\n# 进入code文件夹，如果没有则会生成，并进入文件夹\nWORKDIR /code\n# 将当前内容 放入code文件夹\nADD . /code\n\n# 执行指令\nRUN yarn install && yarn build && npm install -g http-server\n\n# 暴露容器端口 8080\nEXPOSE 8080\n\n# 当执行docker run的时候会执行以下shell 脚本。\nCMD http-server ./build -p 8080\n```\n\n一切准备就绪后，开始创建镜像。\n假设已经安装了docker环境。\n\n在当前项目目录下执行build指令\n```vue\n    // -t 给这个镜像打tag\n    docker build -t=reactapp . \n```\n\nbuild完成后可以查看镜像列表\n```vue\n    docker image list\n```\n\n然后启动镜像变为容器\n```vue\n   // 表示将本地4040端口代理映射容器暴露的8080端口\n    docker run -p 4040:8080 reactapp\n```\n\n之后会出现\n```vue\nStarting up http-server, serving ./build\nAvailable on:\n  http://127.0.0.1:8080\n  http://172.17.0.2:8080\nHit CTRL-C to stop the server\n```\n\n然后输入链接可以访问，如果以上操作是服务器端的话，可以用外网进行打开，但是端口要变成4040，因为8080是容器内部服务的端口。","source":"_posts/docker-react-app.md","raw":"---\ntitle: 用docker来构建一个react项目镜像（一）\ndate: 2019年05月14日\n---\n\n<br/>\n\n前言\n====\n最近在捣鼓自己的一个小站点，但是每次更新项目都要发布后总是ssh，然后重启nginx，属实麻烦，就尝试使用Jenkins来部署自动化，但在这之前要了解一下docker。\n就尝试用docker来构建一个react项目。\n\n<!--more-->\n\n####创建一个react-app项目\n\n这里就直接使用create-react-app 脚手架了。\n\n安装脚手架\n```npm\n   npm install -g create-react-app\n```\n\n完事后执行以下指令，创建一个目录\n```vue\n   create-react-app docker-demo\n```\n\n在创建后的根目录下面新建一个Dockerfile文件\n并键入以下代码：\n```vue\n# 使用node版本11.12.0\nFROM node:11.12.0\n\n# 代表生产环境\nENV PROJECT_ENV production\n# 许多 package 会根据此环境变量，做出不同的行为\n# 另外，在 webpack 中打包也会根据此环境变量做出优化，但是 create-react-app 在打包时会写死该环境变量\nENV NODE_ENV production\n# 进入code文件夹，如果没有则会生成，并进入文件夹\nWORKDIR /code\n# 将当前内容 放入code文件夹\nADD . /code\n\n# 执行指令\nRUN yarn install && yarn build && npm install -g http-server\n\n# 暴露容器端口 8080\nEXPOSE 8080\n\n# 当执行docker run的时候会执行以下shell 脚本。\nCMD http-server ./build -p 8080\n```\n\n一切准备就绪后，开始创建镜像。\n假设已经安装了docker环境。\n\n在当前项目目录下执行build指令\n```vue\n    // -t 给这个镜像打tag\n    docker build -t=reactapp . \n```\n\nbuild完成后可以查看镜像列表\n```vue\n    docker image list\n```\n\n然后启动镜像变为容器\n```vue\n   // 表示将本地4040端口代理映射容器暴露的8080端口\n    docker run -p 4040:8080 reactapp\n```\n\n之后会出现\n```vue\nStarting up http-server, serving ./build\nAvailable on:\n  http://127.0.0.1:8080\n  http://172.17.0.2:8080\nHit CTRL-C to stop the server\n```\n\n然后输入链接可以访问，如果以上操作是服务器端的话，可以用外网进行打开，但是端口要变成4040，因为8080是容器内部服务的端口。","slug":"docker-react-app","published":1,"updated":"2019-05-14T10:11:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdsjt87k0001falvjypqvq15","content":"<p><br></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近在捣鼓自己的一个小站点，但是每次更新项目都要发布后总是ssh，然后重启nginx，属实麻烦，就尝试使用Jenkins来部署自动化，但在这之前要了解一下docker。<br>就尝试用docker来构建一个react项目。</p>\n<a id=\"more\"></a>\n<p>####创建一个react-app项目</p>\n<p>这里就直接使用create-react-app 脚手架了。</p>\n<p>安装脚手架<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g create-react-app</span><br></pre></td></tr></table></figure></p>\n<p>完事后执行以下指令，创建一个目录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create-react-app docker-demo</span><br></pre></td></tr></table></figure></p>\n<p>在创建后的根目录下面新建一个Dockerfile文件<br>并键入以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用node版本11.12.0</span><br><span class=\"line\">FROM node:11.12.0</span><br><span class=\"line\"></span><br><span class=\"line\"># 代表生产环境</span><br><span class=\"line\">ENV PROJECT_ENV production</span><br><span class=\"line\"># 许多 package 会根据此环境变量，做出不同的行为</span><br><span class=\"line\"># 另外，在 webpack 中打包也会根据此环境变量做出优化，但是 create-react-app 在打包时会写死该环境变量</span><br><span class=\"line\">ENV NODE_ENV production</span><br><span class=\"line\"># 进入code文件夹，如果没有则会生成，并进入文件夹</span><br><span class=\"line\">WORKDIR /code</span><br><span class=\"line\"># 将当前内容 放入code文件夹</span><br><span class=\"line\">ADD . /code</span><br><span class=\"line\"></span><br><span class=\"line\"># 执行指令</span><br><span class=\"line\">RUN yarn install &amp;&amp; yarn build &amp;&amp; npm install -g http-server</span><br><span class=\"line\"></span><br><span class=\"line\"># 暴露容器端口 8080</span><br><span class=\"line\">EXPOSE 8080</span><br><span class=\"line\"></span><br><span class=\"line\"># 当执行docker run的时候会执行以下shell 脚本。</span><br><span class=\"line\">CMD http-server ./build -p 8080</span><br></pre></td></tr></table></figure></p>\n<p>一切准备就绪后，开始创建镜像。<br>假设已经安装了docker环境。</p>\n<p>在当前项目目录下执行build指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// -t 给这个镜像打tag</span><br><span class=\"line\">docker build -t=reactapp .</span><br></pre></td></tr></table></figure></p>\n<p>build完成后可以查看镜像列表<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker image list</span><br></pre></td></tr></table></figure></p>\n<p>然后启动镜像变为容器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 表示将本地4040端口代理映射容器暴露的8080端口</span><br><span class=\"line\"> docker run -p 4040:8080 reactapp</span><br></pre></td></tr></table></figure></p>\n<p>之后会出现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Starting up http-server, serving ./build</span><br><span class=\"line\">Available on:</span><br><span class=\"line\">  http://127.0.0.1:8080</span><br><span class=\"line\">  http://172.17.0.2:8080</span><br><span class=\"line\">Hit CTRL-C to stop the server</span><br></pre></td></tr></table></figure></p>\n<p>然后输入链接可以访问，如果以上操作是服务器端的话，可以用外网进行打开，但是端口要变成4040，因为8080是容器内部服务的端口。</p>\n","site":{"data":{}},"excerpt":"<p><br></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近在捣鼓自己的一个小站点，但是每次更新项目都要发布后总是ssh，然后重启nginx，属实麻烦，就尝试使用Jenkins来部署自动化，但在这之前要了解一下docker。<br>就尝试用docker来构建一个react项目。</p>","more":"<p>####创建一个react-app项目</p>\n<p>这里就直接使用create-react-app 脚手架了。</p>\n<p>安装脚手架<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g create-react-app</span><br></pre></td></tr></table></figure></p>\n<p>完事后执行以下指令，创建一个目录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create-react-app docker-demo</span><br></pre></td></tr></table></figure></p>\n<p>在创建后的根目录下面新建一个Dockerfile文件<br>并键入以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用node版本11.12.0</span><br><span class=\"line\">FROM node:11.12.0</span><br><span class=\"line\"></span><br><span class=\"line\"># 代表生产环境</span><br><span class=\"line\">ENV PROJECT_ENV production</span><br><span class=\"line\"># 许多 package 会根据此环境变量，做出不同的行为</span><br><span class=\"line\"># 另外，在 webpack 中打包也会根据此环境变量做出优化，但是 create-react-app 在打包时会写死该环境变量</span><br><span class=\"line\">ENV NODE_ENV production</span><br><span class=\"line\"># 进入code文件夹，如果没有则会生成，并进入文件夹</span><br><span class=\"line\">WORKDIR /code</span><br><span class=\"line\"># 将当前内容 放入code文件夹</span><br><span class=\"line\">ADD . /code</span><br><span class=\"line\"></span><br><span class=\"line\"># 执行指令</span><br><span class=\"line\">RUN yarn install &amp;&amp; yarn build &amp;&amp; npm install -g http-server</span><br><span class=\"line\"></span><br><span class=\"line\"># 暴露容器端口 8080</span><br><span class=\"line\">EXPOSE 8080</span><br><span class=\"line\"></span><br><span class=\"line\"># 当执行docker run的时候会执行以下shell 脚本。</span><br><span class=\"line\">CMD http-server ./build -p 8080</span><br></pre></td></tr></table></figure></p>\n<p>一切准备就绪后，开始创建镜像。<br>假设已经安装了docker环境。</p>\n<p>在当前项目目录下执行build指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// -t 给这个镜像打tag</span><br><span class=\"line\">docker build -t=reactapp .</span><br></pre></td></tr></table></figure></p>\n<p>build完成后可以查看镜像列表<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker image list</span><br></pre></td></tr></table></figure></p>\n<p>然后启动镜像变为容器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 表示将本地4040端口代理映射容器暴露的8080端口</span><br><span class=\"line\"> docker run -p 4040:8080 reactapp</span><br></pre></td></tr></table></figure></p>\n<p>之后会出现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Starting up http-server, serving ./build</span><br><span class=\"line\">Available on:</span><br><span class=\"line\">  http://127.0.0.1:8080</span><br><span class=\"line\">  http://172.17.0.2:8080</span><br><span class=\"line\">Hit CTRL-C to stop the server</span><br></pre></td></tr></table></figure></p>\n<p>然后输入链接可以访问，如果以上操作是服务器端的话，可以用外网进行打开，但是端口要变成4040，因为8080是容器内部服务的端口。</p>"},{"_content":"### js继承\n","source":"_posts/js-extends.md","raw":"### js继承\n","slug":"js-extends","published":1,"date":"2020-07-30T06:13:03.866Z","updated":"2020-07-30T06:13:12.943Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdsjt87m0002falvax7zb5ey","content":"<h3 id=\"js继承\"><a href=\"#js继承\" class=\"headerlink\" title=\"js继承\"></a>js继承</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js继承\"><a href=\"#js继承\" class=\"headerlink\" title=\"js继承\"></a>js继承</h3>"},{"title":"Vue原理(一)","date":"2019-03-18T06:53:04.000Z","_content":"<br/>\n\n观察者模式设计\n====\n在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。(来自wiki百科)\n\n例：小明去买房（观察者Observer），去找房产中心（目标主体Subject），发布者说等有合适的就通知小明。这样就形成了一个环\n\n发布订阅模式设计\n====\n\n在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。(来自wiki百科)\n\n例：小明去买房（订阅者Subscriber），委托第三方中介去买房（调度中心Event Channel），等待第三方中介回馈消息，过了一会房产中心（发布者Publisher）发布消息给第三方中介，第三方中介发现正好符合小明的要求（key）就去通知小明。\n\n两者区别\n====\n\n<img src=\"https://user-gold-cdn.xitu.io/2017/11/22/15fe1b1f174cd376?imageslim\" />\n\n图片来源: <a href=\"http://developers-club.com/posts/270339/\" >developers-club</a>\n\n>1. 在观察者模式中，观察者是知道主体Subject的，而Subject一直保持对观察者的记录。相反在发布订阅中，两者并不互相了解，只能通过代理进行沟通。\n>2. 观察者模式大多数是同步，如：事件触发，而发布订阅模式大多数是异步，如：消息队列。\n>3. 观察者模式是一种紧耦合状态，而发布订阅模式是一种松耦合的状态。\n>4. 观察者模式是通过主体本身去遍历观察者（维护的是观察者），然后调用订阅者的通知方法去实现。而发布订阅则是通过事件管道去通知（维护的是事件）。\n\nMVVM和MVC的区别\n====\nMVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。\n\n在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。\n\nViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\n\nVue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 \n\n<!--more-->\n\n回到Vue\n==== \n\nVue的双向绑定则是利用了观察者模式实现的。\n参考链接：https://segmentfault.com/a/1190000013338801\n\n<pre>\n<code>\nclass Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 为了标明该对象已经被observer过\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n</code>\n</pre>\n\n <pre><code>\n // 拦截数据\n export function defineReactive (\n   obj: Object,\n   key: string,\n   val: any,\n   customSetter?: ?Function,\n   shallow?: boolean\n ) {\n   const dep = new Dep()\n \n   const property = Object.getOwnPropertyDescriptor(obj, key)\n   if (property && property.configurable === false) {\n     return\n   }\n \n   // cater for pre-defined getter/setters\n   const getter = property && property.get\n   const setter = property && property.set\n   if ((!getter || setter) && arguments.length === 2) {\n     val = obj[key]\n   }\n \n   let childOb = !shallow && observe(val)\n   Object.defineProperty(obj, key, {\n     enumerable: true,\n     configurable: true,\n     get: function reactiveGetter () {\n       const value = getter ? getter.call(obj) : val\n       if (Dep.target) {\n         dep.depend()\n         if (childOb) {\n           childOb.dep.depend()\n           if (Array.isArray(value)) {\n             dependArray(value)\n           }\n         }\n       }\n       return value\n     },\n     set: function reactiveSetter (newVal) {\n       const value = getter ? getter.call(obj) : val\n       /* eslint-disable no-self-compare */\n       if (newVal === value || (newVal !== newVal && value !== value)) {\n         return\n       }\n       /* eslint-enable no-self-compare */\n       if (process.env.NODE_ENV !== 'production' && customSetter) {\n         customSetter()\n       }\n       // #7981: for accessor properties without setter\n       if (getter && !setter) return\n       if (setter) {\n         setter.call(obj, newVal)\n       } else {\n         val = newVal\n       }\n       childOb = !shallow && observe(newVal)\n       // 使当前的调度中心通知所有Watcher\n       dep.notify()\n     }\n   })\n }\n </code></pre>\n \n Vue模版渲染\n \n 在执行npm run dev或者npm run build的时候，Vue使用rollup进行编译，入口文件为entry-runtime-with-compiler.js，\n 该文件有以下代码，在runtime的时候执行\n ```vue\n // entry-runtime-with-compiler.js，\n import Vue from './runtime/index'\n ```\n ```vue\n // runtime/index.js\n import Vue from 'core/index'\n ```\n ```vue\n // core/index.js\n // 导入Vue的实例，初始化全局Api\nimport Vue from './instance/index'\nimport { initGlobalAPI } from './global-api/index'\nimport { isServerRendering } from 'core/util/env'\nimport { FunctionalRenderContext } from 'core/vdom/create-functional-component'\ninitGlobalAPI(Vue)\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n})\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n})\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n})\n\nVue.version = '__VERSION__'\n\nexport default Vue\n```\n```vue\n// instance/index.js\n// 做Vue的各种模块混\n// 每当new Vue的时候执行初始化\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n// 初始化混入 *\ninitMixin(Vue)\n\nstateMixin(Vue)\n// 事件混入\neventsMixin(Vue)\n// 生命周期的混入 *\nlifecycleMixin(Vue)\n// render函数混入 *\nrenderMixin(Vue)\n```\n```vue\n// 走进this._init(options)方法\n// 最主要的是\n// 触发Vue原型上的$mount方法，进行compile。compiler/index.js会返回render函数和sataicRenderFns函数。等待renderMixin函数的使用。\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n\n```\n在render.js的renderMixi方法中使用了以下方法\n```vue\n// core/instance/render.js文件中 line:83\n// 这里就是将template进行转换\ntry {\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n  }\n\n// render方法 ，由compiler方法返回，功能是使用with语句的作用是将代码的作用域设置到一个特定的作用域中。之后的msg的都是访问的this中的属性，而this就是\n// vm._renderProxy（vm的一个代理实例），由于Vue自己的proxy方法会将this.data.msg的值的获取改为this.msg，因此msg就变成了\n// options中的data的一个值传入。经过_c (createElement)方法完成template模版的替换。\n(function anonymous(\n) {\nwith(this){return _c('div',{attrs:{\"id\":\"el\"}},[_v(\"\\n  \"+_s(msg)+_s(msg)+\"\\n\")])}\n})\n```\n###梳理下Vue初始化流程：\n>1. 在<font color=pink size=4>new</font>实例Vue的时候，调用<font color=\"pink\" size=\"4\">this._init(options)</font>方法将传入的对象作为$options属性存在Vue实例中。并将各种组件的props，父子组件的inject属性和指令进行合并，开始走created流程。\n>2. 执行了<font color=\"pink\" size=\"4\">initState()</font>方法，对所有数据包括(props和methods)进行拦截，给数据进行observer，并且给被observer过的属性增加ob属性标识，来表示已经被observer。【数据拦截原理见上方观察者模式】\n>> <font color=\"grey\" size=2>补充:由于遍历对象的属性，则每个对象都会有一个Dep，且一个Dep可能会有许多Watcher，因为可能这个属性的值被多处使用，所以当数据改变，则遍历触发自身的所有的Watcher。即dep.notify() => Array.forEach.update</font>\n>3. 之后调用<font color=pink size=4>vm.$mount(el)</font>方法, 进行Vue的mounted。\n>4. 在这之前用一个字段mount存储目标的自定义mounted方法后调用公用的mounted方法，在mounted过程中调用<font color=pink size=4>compilerToFunctions()</font>方法返回一个render函数(一个with关键字函数，切设计虚拟DOM树)，并设置<font color=pink size=4>options.render = render</font>。\n>5. 在公用的mounted方法后有一个<font color=\"pink\" size=\"4\">return mount.call(this, el, hydrating)</font>方法，开始调用自定义的mounted方法。\n>6. 在自定义mounted方法中，调用<font color=\"pink\" size=\"4\">mountComponent()</font>完成观察者模式：实例Watcher类。\n>7. 每个Watcher类在constructor中会调用<font color=\"pink\" size=\"4\">this.value = this.lazy ? undefined : this.get()</font>, 而this.get()方法将自身依赖push给全局的targetStack数组中，并把Dep.target的指向指为当前Watcher。 当要获取属性的值的时候，相应属性自身的get方法之前，将会被之前observer数据拦截，此时Dep.target就存在值，就调用了内部的<font color=\"pink\" size=\"4\">dep.depend()</font>方法实现依赖关系，将当前Watcher放入当前Dep中，等待后期的数据更新。这样就行成了一个依赖环。\n\n最后贴一下官网的生命周期图<a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\">Vue生命周期</a>\n\nVue的详细模板编译原理<a href=\"https://github.com/berwin/Blog/issues/18\">传送门</a>\n\n\n","source":"_posts/publish-subscribe.md","raw":"---\ntitle: Vue原理(一)\ndate: 2018年11月24日\n---\n<br/>\n\n观察者模式设计\n====\n在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。(来自wiki百科)\n\n例：小明去买房（观察者Observer），去找房产中心（目标主体Subject），发布者说等有合适的就通知小明。这样就形成了一个环\n\n发布订阅模式设计\n====\n\n在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。(来自wiki百科)\n\n例：小明去买房（订阅者Subscriber），委托第三方中介去买房（调度中心Event Channel），等待第三方中介回馈消息，过了一会房产中心（发布者Publisher）发布消息给第三方中介，第三方中介发现正好符合小明的要求（key）就去通知小明。\n\n两者区别\n====\n\n<img src=\"https://user-gold-cdn.xitu.io/2017/11/22/15fe1b1f174cd376?imageslim\" />\n\n图片来源: <a href=\"http://developers-club.com/posts/270339/\" >developers-club</a>\n\n>1. 在观察者模式中，观察者是知道主体Subject的，而Subject一直保持对观察者的记录。相反在发布订阅中，两者并不互相了解，只能通过代理进行沟通。\n>2. 观察者模式大多数是同步，如：事件触发，而发布订阅模式大多数是异步，如：消息队列。\n>3. 观察者模式是一种紧耦合状态，而发布订阅模式是一种松耦合的状态。\n>4. 观察者模式是通过主体本身去遍历观察者（维护的是观察者），然后调用订阅者的通知方法去实现。而发布订阅则是通过事件管道去通知（维护的是事件）。\n\nMVVM和MVC的区别\n====\nMVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。\n\n在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。\n\nViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\n\nVue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 \n\n<!--more-->\n\n回到Vue\n==== \n\nVue的双向绑定则是利用了观察者模式实现的。\n参考链接：https://segmentfault.com/a/1190000013338801\n\n<pre>\n<code>\nclass Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 为了标明该对象已经被observer过\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n</code>\n</pre>\n\n <pre><code>\n // 拦截数据\n export function defineReactive (\n   obj: Object,\n   key: string,\n   val: any,\n   customSetter?: ?Function,\n   shallow?: boolean\n ) {\n   const dep = new Dep()\n \n   const property = Object.getOwnPropertyDescriptor(obj, key)\n   if (property && property.configurable === false) {\n     return\n   }\n \n   // cater for pre-defined getter/setters\n   const getter = property && property.get\n   const setter = property && property.set\n   if ((!getter || setter) && arguments.length === 2) {\n     val = obj[key]\n   }\n \n   let childOb = !shallow && observe(val)\n   Object.defineProperty(obj, key, {\n     enumerable: true,\n     configurable: true,\n     get: function reactiveGetter () {\n       const value = getter ? getter.call(obj) : val\n       if (Dep.target) {\n         dep.depend()\n         if (childOb) {\n           childOb.dep.depend()\n           if (Array.isArray(value)) {\n             dependArray(value)\n           }\n         }\n       }\n       return value\n     },\n     set: function reactiveSetter (newVal) {\n       const value = getter ? getter.call(obj) : val\n       /* eslint-disable no-self-compare */\n       if (newVal === value || (newVal !== newVal && value !== value)) {\n         return\n       }\n       /* eslint-enable no-self-compare */\n       if (process.env.NODE_ENV !== 'production' && customSetter) {\n         customSetter()\n       }\n       // #7981: for accessor properties without setter\n       if (getter && !setter) return\n       if (setter) {\n         setter.call(obj, newVal)\n       } else {\n         val = newVal\n       }\n       childOb = !shallow && observe(newVal)\n       // 使当前的调度中心通知所有Watcher\n       dep.notify()\n     }\n   })\n }\n </code></pre>\n \n Vue模版渲染\n \n 在执行npm run dev或者npm run build的时候，Vue使用rollup进行编译，入口文件为entry-runtime-with-compiler.js，\n 该文件有以下代码，在runtime的时候执行\n ```vue\n // entry-runtime-with-compiler.js，\n import Vue from './runtime/index'\n ```\n ```vue\n // runtime/index.js\n import Vue from 'core/index'\n ```\n ```vue\n // core/index.js\n // 导入Vue的实例，初始化全局Api\nimport Vue from './instance/index'\nimport { initGlobalAPI } from './global-api/index'\nimport { isServerRendering } from 'core/util/env'\nimport { FunctionalRenderContext } from 'core/vdom/create-functional-component'\ninitGlobalAPI(Vue)\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n})\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n})\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n})\n\nVue.version = '__VERSION__'\n\nexport default Vue\n```\n```vue\n// instance/index.js\n// 做Vue的各种模块混\n// 每当new Vue的时候执行初始化\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n// 初始化混入 *\ninitMixin(Vue)\n\nstateMixin(Vue)\n// 事件混入\neventsMixin(Vue)\n// 生命周期的混入 *\nlifecycleMixin(Vue)\n// render函数混入 *\nrenderMixin(Vue)\n```\n```vue\n// 走进this._init(options)方法\n// 最主要的是\n// 触发Vue原型上的$mount方法，进行compile。compiler/index.js会返回render函数和sataicRenderFns函数。等待renderMixin函数的使用。\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n\n```\n在render.js的renderMixi方法中使用了以下方法\n```vue\n// core/instance/render.js文件中 line:83\n// 这里就是将template进行转换\ntry {\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n  }\n\n// render方法 ，由compiler方法返回，功能是使用with语句的作用是将代码的作用域设置到一个特定的作用域中。之后的msg的都是访问的this中的属性，而this就是\n// vm._renderProxy（vm的一个代理实例），由于Vue自己的proxy方法会将this.data.msg的值的获取改为this.msg，因此msg就变成了\n// options中的data的一个值传入。经过_c (createElement)方法完成template模版的替换。\n(function anonymous(\n) {\nwith(this){return _c('div',{attrs:{\"id\":\"el\"}},[_v(\"\\n  \"+_s(msg)+_s(msg)+\"\\n\")])}\n})\n```\n###梳理下Vue初始化流程：\n>1. 在<font color=pink size=4>new</font>实例Vue的时候，调用<font color=\"pink\" size=\"4\">this._init(options)</font>方法将传入的对象作为$options属性存在Vue实例中。并将各种组件的props，父子组件的inject属性和指令进行合并，开始走created流程。\n>2. 执行了<font color=\"pink\" size=\"4\">initState()</font>方法，对所有数据包括(props和methods)进行拦截，给数据进行observer，并且给被observer过的属性增加ob属性标识，来表示已经被observer。【数据拦截原理见上方观察者模式】\n>> <font color=\"grey\" size=2>补充:由于遍历对象的属性，则每个对象都会有一个Dep，且一个Dep可能会有许多Watcher，因为可能这个属性的值被多处使用，所以当数据改变，则遍历触发自身的所有的Watcher。即dep.notify() => Array.forEach.update</font>\n>3. 之后调用<font color=pink size=4>vm.$mount(el)</font>方法, 进行Vue的mounted。\n>4. 在这之前用一个字段mount存储目标的自定义mounted方法后调用公用的mounted方法，在mounted过程中调用<font color=pink size=4>compilerToFunctions()</font>方法返回一个render函数(一个with关键字函数，切设计虚拟DOM树)，并设置<font color=pink size=4>options.render = render</font>。\n>5. 在公用的mounted方法后有一个<font color=\"pink\" size=\"4\">return mount.call(this, el, hydrating)</font>方法，开始调用自定义的mounted方法。\n>6. 在自定义mounted方法中，调用<font color=\"pink\" size=\"4\">mountComponent()</font>完成观察者模式：实例Watcher类。\n>7. 每个Watcher类在constructor中会调用<font color=\"pink\" size=\"4\">this.value = this.lazy ? undefined : this.get()</font>, 而this.get()方法将自身依赖push给全局的targetStack数组中，并把Dep.target的指向指为当前Watcher。 当要获取属性的值的时候，相应属性自身的get方法之前，将会被之前observer数据拦截，此时Dep.target就存在值，就调用了内部的<font color=\"pink\" size=\"4\">dep.depend()</font>方法实现依赖关系，将当前Watcher放入当前Dep中，等待后期的数据更新。这样就行成了一个依赖环。\n\n最后贴一下官网的生命周期图<a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\">Vue生命周期</a>\n\nVue的详细模板编译原理<a href=\"https://github.com/berwin/Blog/issues/18\">传送门</a>\n\n\n","slug":"publish-subscribe","published":1,"updated":"2019-03-18T06:53:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdsjt87n0003falvfn3ydok4","content":"<p><br></p>\n<h1 id=\"观察者模式设计\"><a href=\"#观察者模式设计\" class=\"headerlink\" title=\"观察者模式设计\"></a>观察者模式设计</h1><p>在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。(来自wiki百科)</p>\n<p>例：小明去买房（观察者Observer），去找房产中心（目标主体Subject），发布者说等有合适的就通知小明。这样就形成了一个环</p>\n<h1 id=\"发布订阅模式设计\"><a href=\"#发布订阅模式设计\" class=\"headerlink\" title=\"发布订阅模式设计\"></a>发布订阅模式设计</h1><p>在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。(来自wiki百科)</p>\n<p>例：小明去买房（订阅者Subscriber），委托第三方中介去买房（调度中心Event Channel），等待第三方中介回馈消息，过了一会房产中心（发布者Publisher）发布消息给第三方中介，第三方中介发现正好符合小明的要求（key）就去通知小明。</p>\n<h1 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h1><p><img src=\"https://user-gold-cdn.xitu.io/2017/11/22/15fe1b1f174cd376?imageslim\"></p>\n<p>图片来源: <a href=\"http://developers-club.com/posts/270339/\" target=\"_blank\" rel=\"noopener\">developers-club</a></p>\n<blockquote>\n<ol>\n<li>在观察者模式中，观察者是知道主体Subject的，而Subject一直保持对观察者的记录。相反在发布订阅中，两者并不互相了解，只能通过代理进行沟通。</li>\n<li>观察者模式大多数是同步，如：事件触发，而发布订阅模式大多数是异步，如：消息队列。</li>\n<li>观察者模式是一种紧耦合状态，而发布订阅模式是一种松耦合的状态。</li>\n<li>观察者模式是通过主体本身去遍历观察者（维护的是观察者），然后调用订阅者的通知方法去实现。而发布订阅则是通过事件管道去通知（维护的是事件）。</li>\n</ol>\n</blockquote>\n<h1 id=\"MVVM和MVC的区别\"><a href=\"#MVVM和MVC的区别\" class=\"headerlink\" title=\"MVVM和MVC的区别\"></a>MVVM和MVC的区别</h1><p>MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>\n<p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>\n<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>\n<p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 </p>\n<a id=\"more\"></a>\n<h1 id=\"回到Vue\"><a href=\"#回到Vue\" class=\"headerlink\" title=\"回到Vue\"></a>回到Vue</h1><p>Vue的双向绑定则是利用了观察者模式实现的。<br>参考链接：<a href=\"https://segmentfault.com/a/1190000013338801\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000013338801</a></p>\n<pre>\n<code>\nclass Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 为了标明该对象已经被observer过\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n</any></code>\n</pre>\n\n <pre><code>\n // 拦截数据\n export function defineReactive (\n   obj: Object,\n   key: string,\n   val: any,\n   customSetter?: ?Function,\n   shallow?: boolean\n ) {\n   const dep = new Dep()\n\n   const property = Object.getOwnPropertyDescriptor(obj, key)\n   if (property && property.configurable === false) {\n     return\n   }\n\n   // cater for pre-defined getter/setters\n   const getter = property && property.get\n   const setter = property && property.set\n   if ((!getter || setter) && arguments.length === 2) {\n     val = obj[key]\n   }\n\n   let childOb = !shallow && observe(val)\n   Object.defineProperty(obj, key, {\n     enumerable: true,\n     configurable: true,\n     get: function reactiveGetter () {\n       const value = getter ? getter.call(obj) : val\n       if (Dep.target) {\n         dep.depend()\n         if (childOb) {\n           childOb.dep.depend()\n           if (Array.isArray(value)) {\n             dependArray(value)\n           }\n         }\n       }\n       return value\n     },\n     set: function reactiveSetter (newVal) {\n       const value = getter ? getter.call(obj) : val\n       /* eslint-disable no-self-compare */\n       if (newVal === value || (newVal !== newVal && value !== value)) {\n         return\n       }\n       /* eslint-enable no-self-compare */\n       if (process.env.NODE_ENV !== 'production' && customSetter) {\n         customSetter()\n       }\n       // #7981: for accessor properties without setter\n       if (getter && !setter) return\n       if (setter) {\n         setter.call(obj, newVal)\n       } else {\n         val = newVal\n       }\n       childOb = !shallow && observe(newVal)\n       // 使当前的调度中心通知所有Watcher\n       dep.notify()\n     }\n   })\n }\n </code></pre>\n\n<p> Vue模版渲染</p>\n<p> 在执行npm run dev或者npm run build的时候，Vue使用rollup进行编译，入口文件为entry-runtime-with-compiler.js，<br> 该文件有以下代码，在runtime的时候执行<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry-runtime-with-compiler.js，</span><br><span class=\"line\">import Vue from &apos;./runtime/index&apos;</span><br></pre></td></tr></table></figure></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// runtime/index.js</span><br><span class=\"line\">import Vue from &apos;core/index&apos;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // core/index.js</span><br><span class=\"line\"> // 导入Vue的实例，初始化全局Api</span><br><span class=\"line\">import Vue from &apos;./instance/index&apos;</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;</span><br><span class=\"line\">import &#123; isServerRendering &#125; from &apos;core/util/env&apos;</span><br><span class=\"line\">import &#123; FunctionalRenderContext &#125; from &apos;core/vdom/create-functional-component&apos;</span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123;</span><br><span class=\"line\">  get: isServerRendering</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$ssrContext&apos;, &#123;</span><br><span class=\"line\">  get () &#123;</span><br><span class=\"line\">    /* istanbul ignore next */</span><br><span class=\"line\">    return this.$vnode &amp;&amp; this.$vnode.ssrContext</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// expose FunctionalRenderContext for ssr runtime helper installation</span><br><span class=\"line\">Object.defineProperty(Vue, &apos;FunctionalRenderContext&apos;, &#123;</span><br><span class=\"line\">  value: FunctionalRenderContext</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.version = &apos;__VERSION__&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// instance/index.js</span><br><span class=\"line\">// 做Vue的各种模块混</span><br><span class=\"line\">// 每当new Vue的时候执行初始化</span><br><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 初始化混入 *</span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\">// 事件混入</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\">// 生命周期的混入 *</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\">// render函数混入 *</span><br><span class=\"line\">renderMixin(Vue)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 走进this._init(options)方法</span><br><span class=\"line\">// 最主要的是</span><br><span class=\"line\">// 触发Vue原型上的$mount方法，进行compile。compiler/index.js会返回render函数和sataicRenderFns函数。等待renderMixin函数的使用。</span><br><span class=\"line\">    if (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在render.js的renderMixi方法中使用了以下方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// core/instance/render.js文件中 line:83</span><br><span class=\"line\">// 这里就是将template进行转换</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// render方法 ，由compiler方法返回，功能是使用with语句的作用是将代码的作用域设置到一个特定的作用域中。之后的msg的都是访问的this中的属性，而this就是</span><br><span class=\"line\">// vm._renderProxy（vm的一个代理实例），由于Vue自己的proxy方法会将this.data.msg的值的获取改为this.msg，因此msg就变成了</span><br><span class=\"line\">// options中的data的一个值传入。经过_c (createElement)方法完成template模版的替换。</span><br><span class=\"line\">(function anonymous(</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">with(this)&#123;return _c(&apos;div&apos;,&#123;attrs:&#123;&quot;id&quot;:&quot;el&quot;&#125;&#125;,[_v(&quot;\\n  &quot;+_s(msg)+_s(msg)+&quot;\\n&quot;)])&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>###梳理下Vue初始化流程：</p>\n<blockquote>\n<ol>\n<li>在<font color=\"pink\" size=\"4\">new</font>实例Vue的时候，调用<font color=\"pink\" size=\"4\">this._init(options)</font>方法将传入的对象作为$options属性存在Vue实例中。并将各种组件的props，父子组件的inject属性和指令进行合并，开始走created流程。</li>\n<li>执行了<font color=\"pink\" size=\"4\">initState()</font>方法，对所有数据包括(props和methods)进行拦截，给数据进行observer，并且给被observer过的属性增加ob属性标识，来表示已经被observer。【数据拦截原理见上方观察者模式】<blockquote>\n<font color=\"grey\" size=\"2\">补充:由于遍历对象的属性，则每个对象都会有一个Dep，且一个Dep可能会有许多Watcher，因为可能这个属性的值被多处使用，所以当数据改变，则遍历触发自身的所有的Watcher。即dep.notify() =&gt; Array.forEach.update</font></blockquote>\n</li>\n<li>之后调用<font color=\"pink\" size=\"4\">vm.$mount(el)</font>方法, 进行Vue的mounted。</li>\n<li>在这之前用一个字段mount存储目标的自定义mounted方法后调用公用的mounted方法，在mounted过程中调用<font color=\"pink\" size=\"4\">compilerToFunctions()</font>方法返回一个render函数(一个with关键字函数，切设计虚拟DOM树)，并设置<font color=\"pink\" size=\"4\">options.render = render</font>。</li>\n<li>在公用的mounted方法后有一个<font color=\"pink\" size=\"4\">return mount.call(this, el, hydrating)</font>方法，开始调用自定义的mounted方法。</li>\n<li>在自定义mounted方法中，调用<font color=\"pink\" size=\"4\">mountComponent()</font>完成观察者模式：实例Watcher类。</li>\n<li>每个Watcher类在constructor中会调用<font color=\"pink\" size=\"4\">this.value = this.lazy ? undefined : this.get()</font>, 而this.get()方法将自身依赖push给全局的targetStack数组中，并把Dep.target的指向指为当前Watcher。 当要获取属性的值的时候，相应属性自身的get方法之前，将会被之前observer数据拦截，此时Dep.target就存在值，就调用了内部的<font color=\"pink\" size=\"4\">dep.depend()</font>方法实现依赖关系，将当前Watcher放入当前Dep中，等待后期的数据更新。这样就行成了一个依赖环。</li>\n</ol>\n</blockquote>\n<p>最后贴一下官网的生命周期图<a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\" target=\"_blank\" rel=\"noopener\">Vue生命周期</a></p>\n<p>Vue的详细模板编译原理<a href=\"https://github.com/berwin/Blog/issues/18\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n","site":{"data":{}},"excerpt":"<p><br></p>\n<h1 id=\"观察者模式设计\"><a href=\"#观察者模式设计\" class=\"headerlink\" title=\"观察者模式设计\"></a>观察者模式设计</h1><p>在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。(来自wiki百科)</p>\n<p>例：小明去买房（观察者Observer），去找房产中心（目标主体Subject），发布者说等有合适的就通知小明。这样就形成了一个环</p>\n<h1 id=\"发布订阅模式设计\"><a href=\"#发布订阅模式设计\" class=\"headerlink\" title=\"发布订阅模式设计\"></a>发布订阅模式设计</h1><p>在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。(来自wiki百科)</p>\n<p>例：小明去买房（订阅者Subscriber），委托第三方中介去买房（调度中心Event Channel），等待第三方中介回馈消息，过了一会房产中心（发布者Publisher）发布消息给第三方中介，第三方中介发现正好符合小明的要求（key）就去通知小明。</p>\n<h1 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h1><p><img src=\"https://user-gold-cdn.xitu.io/2017/11/22/15fe1b1f174cd376?imageslim\"></p>\n<p>图片来源: <a href=\"http://developers-club.com/posts/270339/\" target=\"_blank\" rel=\"noopener\">developers-club</a></p>\n<blockquote>\n<ol>\n<li>在观察者模式中，观察者是知道主体Subject的，而Subject一直保持对观察者的记录。相反在发布订阅中，两者并不互相了解，只能通过代理进行沟通。</li>\n<li>观察者模式大多数是同步，如：事件触发，而发布订阅模式大多数是异步，如：消息队列。</li>\n<li>观察者模式是一种紧耦合状态，而发布订阅模式是一种松耦合的状态。</li>\n<li>观察者模式是通过主体本身去遍历观察者（维护的是观察者），然后调用订阅者的通知方法去实现。而发布订阅则是通过事件管道去通知（维护的是事件）。</li>\n</ol>\n</blockquote>\n<h1 id=\"MVVM和MVC的区别\"><a href=\"#MVVM和MVC的区别\" class=\"headerlink\" title=\"MVVM和MVC的区别\"></a>MVVM和MVC的区别</h1><p>MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>\n<p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>\n<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>\n<p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 </p>","more":"<h1 id=\"回到Vue\"><a href=\"#回到Vue\" class=\"headerlink\" title=\"回到Vue\"></a>回到Vue</h1><p>Vue的双向绑定则是利用了观察者模式实现的。<br>参考链接：<a href=\"https://segmentfault.com/a/1190000013338801\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000013338801</a></p>\n<pre>\n<code>\nclass Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 为了标明该对象已经被observer过\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n</any></code>\n</pre>\n\n <pre><code>\n // 拦截数据\n export function defineReactive (\n   obj: Object,\n   key: string,\n   val: any,\n   customSetter?: ?Function,\n   shallow?: boolean\n ) {\n   const dep = new Dep()\n\n   const property = Object.getOwnPropertyDescriptor(obj, key)\n   if (property && property.configurable === false) {\n     return\n   }\n\n   // cater for pre-defined getter/setters\n   const getter = property && property.get\n   const setter = property && property.set\n   if ((!getter || setter) && arguments.length === 2) {\n     val = obj[key]\n   }\n\n   let childOb = !shallow && observe(val)\n   Object.defineProperty(obj, key, {\n     enumerable: true,\n     configurable: true,\n     get: function reactiveGetter () {\n       const value = getter ? getter.call(obj) : val\n       if (Dep.target) {\n         dep.depend()\n         if (childOb) {\n           childOb.dep.depend()\n           if (Array.isArray(value)) {\n             dependArray(value)\n           }\n         }\n       }\n       return value\n     },\n     set: function reactiveSetter (newVal) {\n       const value = getter ? getter.call(obj) : val\n       /* eslint-disable no-self-compare */\n       if (newVal === value || (newVal !== newVal && value !== value)) {\n         return\n       }\n       /* eslint-enable no-self-compare */\n       if (process.env.NODE_ENV !== 'production' && customSetter) {\n         customSetter()\n       }\n       // #7981: for accessor properties without setter\n       if (getter && !setter) return\n       if (setter) {\n         setter.call(obj, newVal)\n       } else {\n         val = newVal\n       }\n       childOb = !shallow && observe(newVal)\n       // 使当前的调度中心通知所有Watcher\n       dep.notify()\n     }\n   })\n }\n </code></pre>\n\n<p> Vue模版渲染</p>\n<p> 在执行npm run dev或者npm run build的时候，Vue使用rollup进行编译，入口文件为entry-runtime-with-compiler.js，<br> 该文件有以下代码，在runtime的时候执行<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry-runtime-with-compiler.js，</span><br><span class=\"line\">import Vue from &apos;./runtime/index&apos;</span><br></pre></td></tr></table></figure></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// runtime/index.js</span><br><span class=\"line\">import Vue from &apos;core/index&apos;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // core/index.js</span><br><span class=\"line\"> // 导入Vue的实例，初始化全局Api</span><br><span class=\"line\">import Vue from &apos;./instance/index&apos;</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;</span><br><span class=\"line\">import &#123; isServerRendering &#125; from &apos;core/util/env&apos;</span><br><span class=\"line\">import &#123; FunctionalRenderContext &#125; from &apos;core/vdom/create-functional-component&apos;</span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123;</span><br><span class=\"line\">  get: isServerRendering</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$ssrContext&apos;, &#123;</span><br><span class=\"line\">  get () &#123;</span><br><span class=\"line\">    /* istanbul ignore next */</span><br><span class=\"line\">    return this.$vnode &amp;&amp; this.$vnode.ssrContext</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// expose FunctionalRenderContext for ssr runtime helper installation</span><br><span class=\"line\">Object.defineProperty(Vue, &apos;FunctionalRenderContext&apos;, &#123;</span><br><span class=\"line\">  value: FunctionalRenderContext</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.version = &apos;__VERSION__&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// instance/index.js</span><br><span class=\"line\">// 做Vue的各种模块混</span><br><span class=\"line\">// 每当new Vue的时候执行初始化</span><br><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 初始化混入 *</span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\">// 事件混入</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\">// 生命周期的混入 *</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\">// render函数混入 *</span><br><span class=\"line\">renderMixin(Vue)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 走进this._init(options)方法</span><br><span class=\"line\">// 最主要的是</span><br><span class=\"line\">// 触发Vue原型上的$mount方法，进行compile。compiler/index.js会返回render函数和sataicRenderFns函数。等待renderMixin函数的使用。</span><br><span class=\"line\">    if (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在render.js的renderMixi方法中使用了以下方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// core/instance/render.js文件中 line:83</span><br><span class=\"line\">// 这里就是将template进行转换</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// render方法 ，由compiler方法返回，功能是使用with语句的作用是将代码的作用域设置到一个特定的作用域中。之后的msg的都是访问的this中的属性，而this就是</span><br><span class=\"line\">// vm._renderProxy（vm的一个代理实例），由于Vue自己的proxy方法会将this.data.msg的值的获取改为this.msg，因此msg就变成了</span><br><span class=\"line\">// options中的data的一个值传入。经过_c (createElement)方法完成template模版的替换。</span><br><span class=\"line\">(function anonymous(</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">with(this)&#123;return _c(&apos;div&apos;,&#123;attrs:&#123;&quot;id&quot;:&quot;el&quot;&#125;&#125;,[_v(&quot;\\n  &quot;+_s(msg)+_s(msg)+&quot;\\n&quot;)])&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>###梳理下Vue初始化流程：</p>\n<blockquote>\n<ol>\n<li>在<font color=\"pink\" size=\"4\">new</font>实例Vue的时候，调用<font color=\"pink\" size=\"4\">this._init(options)</font>方法将传入的对象作为$options属性存在Vue实例中。并将各种组件的props，父子组件的inject属性和指令进行合并，开始走created流程。</li>\n<li>执行了<font color=\"pink\" size=\"4\">initState()</font>方法，对所有数据包括(props和methods)进行拦截，给数据进行observer，并且给被observer过的属性增加ob属性标识，来表示已经被observer。【数据拦截原理见上方观察者模式】<blockquote>\n<font color=\"grey\" size=\"2\">补充:由于遍历对象的属性，则每个对象都会有一个Dep，且一个Dep可能会有许多Watcher，因为可能这个属性的值被多处使用，所以当数据改变，则遍历触发自身的所有的Watcher。即dep.notify() =&gt; Array.forEach.update</font></blockquote>\n</li>\n<li>之后调用<font color=\"pink\" size=\"4\">vm.$mount(el)</font>方法, 进行Vue的mounted。</li>\n<li>在这之前用一个字段mount存储目标的自定义mounted方法后调用公用的mounted方法，在mounted过程中调用<font color=\"pink\" size=\"4\">compilerToFunctions()</font>方法返回一个render函数(一个with关键字函数，切设计虚拟DOM树)，并设置<font color=\"pink\" size=\"4\">options.render = render</font>。</li>\n<li>在公用的mounted方法后有一个<font color=\"pink\" size=\"4\">return mount.call(this, el, hydrating)</font>方法，开始调用自定义的mounted方法。</li>\n<li>在自定义mounted方法中，调用<font color=\"pink\" size=\"4\">mountComponent()</font>完成观察者模式：实例Watcher类。</li>\n<li>每个Watcher类在constructor中会调用<font color=\"pink\" size=\"4\">this.value = this.lazy ? undefined : this.get()</font>, 而this.get()方法将自身依赖push给全局的targetStack数组中，并把Dep.target的指向指为当前Watcher。 当要获取属性的值的时候，相应属性自身的get方法之前，将会被之前observer数据拦截，此时Dep.target就存在值，就调用了内部的<font color=\"pink\" size=\"4\">dep.depend()</font>方法实现依赖关系，将当前Watcher放入当前Dep中，等待后期的数据更新。这样就行成了一个依赖环。</li>\n</ol>\n</blockquote>\n<p>最后贴一下官网的生命周期图<a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\" target=\"_blank\" rel=\"noopener\">Vue生命周期</a></p>\n<p>Vue的详细模板编译原理<a href=\"https://github.com/berwin/Blog/issues/18\" target=\"_blank\" rel=\"noopener\">传送门</a></p>"},{"title":"Webpack详解","date":"2018-11-26T08:29:24.000Z","_content":"<br/>\n\nWebpack\n===\n\n为什么要使用WebPack\n---\n现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法\n\n模块化，让我们可以把复杂的程序细化为小的文件;\n类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；\nScss，less等CSS预处理器\n...\n这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。\n\n什么是Webpack\n\n<!--more-->\n\n---\nwebpack可以看做是模块打包机：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用\n\nWebpack的工作方式\n---\nWebpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。\n\n开始使用Webpack\n===\n\n\n```\n// 全局安装\nnpm install -g webpack\nnpm install -g webpack-cli\nnpm install -g webpack-dev-server\n```\n\n正式使用webpack\n===\n\n####通过命令行使用\n```\n// entry file 表示入口文件\n// output file 表示出口文件的路径和文件名\nwebpack {entry file} {output file} \n在最新版本的使用方法\n// -o 参数表示指定之后的内容为输入文件\nwebpack {entry file} -o {output file}\n```\n\n####通过配置文件使用\n\n生成一个webpack.config.js文件，输入以下简单配置\n```\nmodule.exports = {\n  devtool: \"source-map\", // 打包方式，后续会提及\n  entry: __dirname + \"/app/main.js\", // 入口文件\n  output: {  // 出口文件\n    path: __dirname + \"/public/\",  // 出口文件路径\n    filename: 'bundle.js' // 出口文件名\n  }\n}\n```\n\n>__dirname 表示当前执行脚本的所在路径，为node环境的全局变量\n\nWebPack强大功能\n===\n####使用Source Maps（使调试更容易）\n\n| devtool选项 | 配置结果 |\n| :---------: | ----- |\n| source-map | 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；|\n| cheap-module-source-map | 在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便； |\n| eval-source-map | 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；|\n| cheap-module-eval-source-map | 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； |\n\n####使用Webpack构建本地服务器\n\n```vue\nmodule.exports = {\n  devtool: \"eval-source-map\", //\n  entry: __dirname + \"/app/main.js\",\n  output: {\n    path: __dirname + \"/public/\",\n    filename: 'bundle.js'\n  },\n  devServer: {\n    contentBase: './public', // 本地服务器所加载的页面所载目录\n    historyApiFallback: true, // 是否跳转\n    inline: true // 实时刷新\n  }\n```\n\n| devserver的配置 | 功能描述 |\n| :------------: | ----- |\n| contentBase | 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public\"目录）|\n| port | 设置默认监听端口，如果省略，默认为”8080“ |\n| inline | 设置为true，当源文件改变时会自动刷新页面 |\n| historyApiFallback | 在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html |\n####Loaders\n通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。\n对于Vue而言，使用Vue-loader进行解析各种Vue文件翻译成浏览器可编译的代码。\n\nwebpack官方推荐提供了两个utils\n```\nloader-utils // 提供很多有用的工具，其中最普遍使用的是获取options。\nschema-utils // 能够校验传来的options是否合法\n```\n\n#####Loader特性\n1. loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。\n2. loader 可以是同步的，也可以是异步的。\n3. loader 运行在 Node.js 中，并且能够执行任何可能的操作。\n4. loader 接收查询参数。用于对 loader 传递配置。\n5. loader 也能够使用 options 对象进行配置。\n6. 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。\n7. 插件(plugin)可以为 loader 带来更多特性。\n8. loader 能够产生额外的任意文件。\n\n\n####Babel\nBabel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：\n\n让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持；\n让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；\n\n#####Babel的安装和配置\nBabel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，对于每一个单独需要的功能的扩展，需要安装单独的包（常用的有解析Es6的babel-env-preset包）\n\n安装：\n>webpack 4.x | babel-loader 8.x | babel 7.x\n```vue\nnpm install -D babel-loader @babel/core @babel/preset-env webpack\n```\n>.babelrc文件配置\n```vue\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n>webpack 4.x | babel-loader 7.x | babel 6.x\n```vue\nnpm install -D babel-loader@7 babel-core babel-preset-env webpack\n```\n>.babelrc文件配置\n```vue\n{\n  \"presets\": [\n    [\n      \"env\",\n      {\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n\n####Plugins\n常用的插件\n\n| 插件名 | 说明 | 链接 |\n| :---: | ---- | ---- |\n| HtmlWebpackPlugin | 依据一个html模板，生成一个新的html文件，可做模板的替换，插入js | https://www.npmjs.com/package/html-webpack-plugin |\n| CleanWebpackPlugin | 在打包之前指定删除文件或文件夹 | https://www.npmjs.com/package/clean-webpack-plugin |\n| mini-css-extract-plugin | 将指定的内容从打包的文件分离，webpack4废除了extract-text-webpack-plugin这个插件 | https://www.npmjs.com/package/mini-css-extract-plugin |\n\n#####Webpack内置插件\n不做叙述https://www.webpackjs.com/plugins/\n\n#####编写一个Webpack插件\nWebpack插件由以下组成：\n>1. 一个JavaScript命名函数\n>2. 在插件函数的prototype上顶一个一个apply方法\n>3. 制定一个绑定webpack自身的事件钩子。\n>4. 处理webpack内部实例的特定数据。\n>5. 功能完成后调用webpack回调\n\n例：\n```vue\n// 一个 JavaScript 命名函数。\nconst pluginName = 'MyWebPackPlugin'\n\nclass FileListPlugin {\n  apply (compiler) {\n    compiler.hooks.run.tap(pluginName, (compilation) => {\n      console.log('Webpack开始构建中')\n    })\n  }\n}\n```\n\n其中有两个重要的回调：\n- compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。\n   - 使用方法\n   ```vue\n     compiler.hooks.someHook.tap(/* ... */);\n   ```\n   - someHook列表：https://webpack.js.org/api/compiler-hooks/\n  \n- compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。\n   - 使用方法\n   ```vue\n     compilation.hooks.someHook.tap(/* ... */);\n   ```\n   - someHook列表：https://webpack.js.org/api/compilation-hooks/\n\ntap方法表：\n\n| 方法名 | 功能描述 |\n| :---: | ----- |\n| tap | 同步方法，自动执行webpack的流程 |\n| tapAsync | 异步方法，必须在执行结束后调用webpack自己的callback()方法 |\n| tapPromise | 返回一个Promise方法，当异步任务完成后需要在添加resolve(）方法 |\n\n\n参考文档：\n- Webpack内部运行机制：https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，\n- Webpack4.0逐个击破：https://www.cnblogs.com/dashnowords/category/1284284.html\n- Webpack官网：https://webpack.js.org/ 【建议】\n\n\n### Webpack核心：tapable类\n\n```tapable```是```webpack```的核心框架（4.0以上版本的API已经发生了变化），是一个基于事件流的框架，或者叫做发布订阅模式，或观察者模式，```webpack```的整个生命周期及其开放的自定义插件系统都离不开```tapable```的支持，研究其运行原理是阅读```webpack```源代码的第一步。官方仓库master分支的代码是经过ES6重构的，模块化拆分非常细，且加入了很多非核心逻辑，阅读难度较大。建议先从官方仓库中0.2版本的分支开始学习，整个源码只有400行，相对容易理解。\n- 0.2版本链接：https://github.com/webpack/tapable/tree/tapable-0.2\n\n\n### 代码地址\nhttps://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project\n","source":"_posts/simpe-webpack-project.md","raw":"---\ntitle: Webpack详解\ndate: 2018年10月28日\n---\n<br/>\n\nWebpack\n===\n\n为什么要使用WebPack\n---\n现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法\n\n模块化，让我们可以把复杂的程序细化为小的文件;\n类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；\nScss，less等CSS预处理器\n...\n这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。\n\n什么是Webpack\n\n<!--more-->\n\n---\nwebpack可以看做是模块打包机：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用\n\nWebpack的工作方式\n---\nWebpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。\n\n开始使用Webpack\n===\n\n\n```\n// 全局安装\nnpm install -g webpack\nnpm install -g webpack-cli\nnpm install -g webpack-dev-server\n```\n\n正式使用webpack\n===\n\n####通过命令行使用\n```\n// entry file 表示入口文件\n// output file 表示出口文件的路径和文件名\nwebpack {entry file} {output file} \n在最新版本的使用方法\n// -o 参数表示指定之后的内容为输入文件\nwebpack {entry file} -o {output file}\n```\n\n####通过配置文件使用\n\n生成一个webpack.config.js文件，输入以下简单配置\n```\nmodule.exports = {\n  devtool: \"source-map\", // 打包方式，后续会提及\n  entry: __dirname + \"/app/main.js\", // 入口文件\n  output: {  // 出口文件\n    path: __dirname + \"/public/\",  // 出口文件路径\n    filename: 'bundle.js' // 出口文件名\n  }\n}\n```\n\n>__dirname 表示当前执行脚本的所在路径，为node环境的全局变量\n\nWebPack强大功能\n===\n####使用Source Maps（使调试更容易）\n\n| devtool选项 | 配置结果 |\n| :---------: | ----- |\n| source-map | 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；|\n| cheap-module-source-map | 在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便； |\n| eval-source-map | 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；|\n| cheap-module-eval-source-map | 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； |\n\n####使用Webpack构建本地服务器\n\n```vue\nmodule.exports = {\n  devtool: \"eval-source-map\", //\n  entry: __dirname + \"/app/main.js\",\n  output: {\n    path: __dirname + \"/public/\",\n    filename: 'bundle.js'\n  },\n  devServer: {\n    contentBase: './public', // 本地服务器所加载的页面所载目录\n    historyApiFallback: true, // 是否跳转\n    inline: true // 实时刷新\n  }\n```\n\n| devserver的配置 | 功能描述 |\n| :------------: | ----- |\n| contentBase | 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public\"目录）|\n| port | 设置默认监听端口，如果省略，默认为”8080“ |\n| inline | 设置为true，当源文件改变时会自动刷新页面 |\n| historyApiFallback | 在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html |\n####Loaders\n通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。\n对于Vue而言，使用Vue-loader进行解析各种Vue文件翻译成浏览器可编译的代码。\n\nwebpack官方推荐提供了两个utils\n```\nloader-utils // 提供很多有用的工具，其中最普遍使用的是获取options。\nschema-utils // 能够校验传来的options是否合法\n```\n\n#####Loader特性\n1. loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。\n2. loader 可以是同步的，也可以是异步的。\n3. loader 运行在 Node.js 中，并且能够执行任何可能的操作。\n4. loader 接收查询参数。用于对 loader 传递配置。\n5. loader 也能够使用 options 对象进行配置。\n6. 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。\n7. 插件(plugin)可以为 loader 带来更多特性。\n8. loader 能够产生额外的任意文件。\n\n\n####Babel\nBabel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：\n\n让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持；\n让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；\n\n#####Babel的安装和配置\nBabel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，对于每一个单独需要的功能的扩展，需要安装单独的包（常用的有解析Es6的babel-env-preset包）\n\n安装：\n>webpack 4.x | babel-loader 8.x | babel 7.x\n```vue\nnpm install -D babel-loader @babel/core @babel/preset-env webpack\n```\n>.babelrc文件配置\n```vue\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n>webpack 4.x | babel-loader 7.x | babel 6.x\n```vue\nnpm install -D babel-loader@7 babel-core babel-preset-env webpack\n```\n>.babelrc文件配置\n```vue\n{\n  \"presets\": [\n    [\n      \"env\",\n      {\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n\n####Plugins\n常用的插件\n\n| 插件名 | 说明 | 链接 |\n| :---: | ---- | ---- |\n| HtmlWebpackPlugin | 依据一个html模板，生成一个新的html文件，可做模板的替换，插入js | https://www.npmjs.com/package/html-webpack-plugin |\n| CleanWebpackPlugin | 在打包之前指定删除文件或文件夹 | https://www.npmjs.com/package/clean-webpack-plugin |\n| mini-css-extract-plugin | 将指定的内容从打包的文件分离，webpack4废除了extract-text-webpack-plugin这个插件 | https://www.npmjs.com/package/mini-css-extract-plugin |\n\n#####Webpack内置插件\n不做叙述https://www.webpackjs.com/plugins/\n\n#####编写一个Webpack插件\nWebpack插件由以下组成：\n>1. 一个JavaScript命名函数\n>2. 在插件函数的prototype上顶一个一个apply方法\n>3. 制定一个绑定webpack自身的事件钩子。\n>4. 处理webpack内部实例的特定数据。\n>5. 功能完成后调用webpack回调\n\n例：\n```vue\n// 一个 JavaScript 命名函数。\nconst pluginName = 'MyWebPackPlugin'\n\nclass FileListPlugin {\n  apply (compiler) {\n    compiler.hooks.run.tap(pluginName, (compilation) => {\n      console.log('Webpack开始构建中')\n    })\n  }\n}\n```\n\n其中有两个重要的回调：\n- compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。\n   - 使用方法\n   ```vue\n     compiler.hooks.someHook.tap(/* ... */);\n   ```\n   - someHook列表：https://webpack.js.org/api/compiler-hooks/\n  \n- compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。\n   - 使用方法\n   ```vue\n     compilation.hooks.someHook.tap(/* ... */);\n   ```\n   - someHook列表：https://webpack.js.org/api/compilation-hooks/\n\ntap方法表：\n\n| 方法名 | 功能描述 |\n| :---: | ----- |\n| tap | 同步方法，自动执行webpack的流程 |\n| tapAsync | 异步方法，必须在执行结束后调用webpack自己的callback()方法 |\n| tapPromise | 返回一个Promise方法，当异步任务完成后需要在添加resolve(）方法 |\n\n\n参考文档：\n- Webpack内部运行机制：https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，\n- Webpack4.0逐个击破：https://www.cnblogs.com/dashnowords/category/1284284.html\n- Webpack官网：https://webpack.js.org/ 【建议】\n\n\n### Webpack核心：tapable类\n\n```tapable```是```webpack```的核心框架（4.0以上版本的API已经发生了变化），是一个基于事件流的框架，或者叫做发布订阅模式，或观察者模式，```webpack```的整个生命周期及其开放的自定义插件系统都离不开```tapable```的支持，研究其运行原理是阅读```webpack```源代码的第一步。官方仓库master分支的代码是经过ES6重构的，模块化拆分非常细，且加入了很多非核心逻辑，阅读难度较大。建议先从官方仓库中0.2版本的分支开始学习，整个源码只有400行，相对容易理解。\n- 0.2版本链接：https://github.com/webpack/tapable/tree/tapable-0.2\n\n\n### 代码地址\nhttps://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project\n","slug":"simpe-webpack-project","published":1,"updated":"2018-11-26T08:29:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdsjt88d0004falvkgmy5yra","content":"<p><br></p>\n<h1 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h1><h2 id=\"为什么要使用WebPack\"><a href=\"#为什么要使用WebPack\" class=\"headerlink\" title=\"为什么要使用WebPack\"></a>为什么要使用WebPack</h2><p>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p>\n<p>模块化，让我们可以把复杂的程序细化为小的文件;<br>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；<br>Scss，less等CSS预处理器<br>…<br>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。</p>\n<p>什么是Webpack</p>\n<a id=\"more\"></a>\n<hr>\n<p>webpack可以看做是模块打包机：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用</p>\n<h2 id=\"Webpack的工作方式\"><a href=\"#Webpack的工作方式\" class=\"headerlink\" title=\"Webpack的工作方式\"></a>Webpack的工作方式</h2><p>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p>\n<h1 id=\"开始使用Webpack\"><a href=\"#开始使用Webpack\" class=\"headerlink\" title=\"开始使用Webpack\"></a>开始使用Webpack</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 全局安装</span><br><span class=\"line\">npm install -g webpack</span><br><span class=\"line\">npm install -g webpack-cli</span><br><span class=\"line\">npm install -g webpack-dev-server</span><br></pre></td></tr></table></figure>\n<h1 id=\"正式使用webpack\"><a href=\"#正式使用webpack\" class=\"headerlink\" title=\"正式使用webpack\"></a>正式使用webpack</h1><p>####通过命令行使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry file 表示入口文件</span><br><span class=\"line\">// output file 表示出口文件的路径和文件名</span><br><span class=\"line\">webpack &#123;entry file&#125; &#123;output file&#125; </span><br><span class=\"line\">在最新版本的使用方法</span><br><span class=\"line\">// -o 参数表示指定之后的内容为输入文件</span><br><span class=\"line\">webpack &#123;entry file&#125; -o &#123;output file&#125;</span><br></pre></td></tr></table></figure></p>\n<p>####通过配置文件使用</p>\n<p>生成一个webpack.config.js文件，输入以下简单配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &quot;source-map&quot;, // 打包方式，后续会提及</span><br><span class=\"line\">  entry: __dirname + &quot;/app/main.js&quot;, // 入口文件</span><br><span class=\"line\">  output: &#123;  // 出口文件</span><br><span class=\"line\">    path: __dirname + &quot;/public/&quot;,  // 出口文件路径</span><br><span class=\"line\">    filename: &apos;bundle.js&apos; // 出口文件名</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>__dirname 表示当前执行脚本的所在路径，为node环境的全局变量</p>\n</blockquote>\n<h1 id=\"WebPack强大功能\"><a href=\"#WebPack强大功能\" class=\"headerlink\" title=\"WebPack强大功能\"></a>WebPack强大功能</h1><p>####使用Source Maps（使调试更容易）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">devtool选项</th>\n<th>配置结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">source-map</td>\n<td>在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cheap-module-source-map</td>\n<td>在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">eval-source-map</td>\n<td>使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cheap-module-eval-source-map</td>\n<td>这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；</td>\n</tr>\n</tbody>\n</table>\n<p>####使用Webpack构建本地服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &quot;eval-source-map&quot;, //</span><br><span class=\"line\">  entry: __dirname + &quot;/app/main.js&quot;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/public/&quot;,</span><br><span class=\"line\">    filename: &apos;bundle.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    contentBase: &apos;./public&apos;, // 本地服务器所加载的页面所载目录</span><br><span class=\"line\">    historyApiFallback: true, // 是否跳转</span><br><span class=\"line\">    inline: true // 实时刷新</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">devserver的配置</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">contentBase</td>\n<td>默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">port</td>\n<td>设置默认监听端口，如果省略，默认为”8080“</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">inline</td>\n<td>设置为true，当源文件改变时会自动刷新页面</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">historyApiFallback</td>\n<td>在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</td>\n</tr>\n</tbody>\n</table>\n<p>####Loaders<br>通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。<br>对于Vue而言，使用Vue-loader进行解析各种Vue文件翻译成浏览器可编译的代码。</p>\n<p>webpack官方推荐提供了两个utils<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loader-utils // 提供很多有用的工具，其中最普遍使用的是获取options。</span><br><span class=\"line\">schema-utils // 能够校验传来的options是否合法</span><br></pre></td></tr></table></figure></p>\n<p>#####Loader特性</p>\n<ol>\n<li>loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。</li>\n<li>loader 可以是同步的，也可以是异步的。</li>\n<li>loader 运行在 Node.js 中，并且能够执行任何可能的操作。</li>\n<li>loader 接收查询参数。用于对 loader 传递配置。</li>\n<li>loader 也能够使用 options 对象进行配置。</li>\n<li>除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。</li>\n<li>插件(plugin)可以为 loader 带来更多特性。</li>\n<li>loader 能够产生额外的任意文件。</li>\n</ol>\n<p>####Babel<br>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：</p>\n<p>让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持；<br>让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；</p>\n<p>#####Babel的安装和配置<br>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，对于每一个单独需要的功能的扩展，需要安装单独的包（常用的有解析Es6的babel-env-preset包）</p>\n<p>安装：</p>\n<blockquote>\n<p>webpack 4.x | babel-loader 8.x | babel 7.x<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -D babel-loader @babel/core @babel/preset-env webpack</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>.babelrc文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;@babel/preset-env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>webpack 4.x | babel-loader 7.x | babel 6.x<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -D babel-loader@7 babel-core babel-preset-env webpack</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>.babelrc文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>####Plugins<br>常用的插件</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">插件名</th>\n<th>说明</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">HtmlWebpackPlugin</td>\n<td>依据一个html模板，生成一个新的html文件，可做模板的替换，插入js</td>\n<td><a href=\"https://www.npmjs.com/package/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/html-webpack-plugin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CleanWebpackPlugin</td>\n<td>在打包之前指定删除文件或文件夹</td>\n<td><a href=\"https://www.npmjs.com/package/clean-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/clean-webpack-plugin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mini-css-extract-plugin</td>\n<td>将指定的内容从打包的文件分离，webpack4废除了extract-text-webpack-plugin这个插件</td>\n<td><a href=\"https://www.npmjs.com/package/mini-css-extract-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/mini-css-extract-plugin</a></td>\n</tr>\n</tbody>\n</table>\n<p>#####Webpack内置插件<br>不做叙述<a href=\"https://www.webpackjs.com/plugins/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/plugins/</a></p>\n<p>#####编写一个Webpack插件<br>Webpack插件由以下组成：</p>\n<blockquote>\n<ol>\n<li>一个JavaScript命名函数</li>\n<li>在插件函数的prototype上顶一个一个apply方法</li>\n<li>制定一个绑定webpack自身的事件钩子。</li>\n<li>处理webpack内部实例的特定数据。</li>\n<li>功能完成后调用webpack回调</li>\n</ol>\n</blockquote>\n<p>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个 JavaScript 命名函数。</span><br><span class=\"line\">const pluginName = &apos;MyWebPackPlugin&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">class FileListPlugin &#123;</span><br><span class=\"line\">  apply (compiler) &#123;</span><br><span class=\"line\">    compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;Webpack开始构建中&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中有两个重要的回调：</p>\n<ul>\n<li><p>compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p>\n<ul>\n<li><p>使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compiler.hooks.someHook.tap(/* ... */);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>someHook列表：<a href=\"https://webpack.js.org/api/compiler-hooks/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/api/compiler-hooks/</a></p>\n</li>\n</ul>\n</li>\n<li><p>compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p>\n<ul>\n<li><p>使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compilation.hooks.someHook.tap(/* ... */);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>someHook列表：<a href=\"https://webpack.js.org/api/compilation-hooks/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/api/compilation-hooks/</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>tap方法表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法名</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">tap</td>\n<td>同步方法，自动执行webpack的流程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tapAsync</td>\n<td>异步方法，必须在执行结束后调用webpack自己的callback()方法</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tapPromise</td>\n<td>返回一个Promise方法，当异步任务完成后需要在添加resolve(）方法</td>\n</tr>\n</tbody>\n</table>\n<p>参考文档：</p>\n<ul>\n<li>Webpack内部运行机制：<a href=\"https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，\" target=\"_blank\" rel=\"noopener\">https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，</a></li>\n<li>Webpack4.0逐个击破：<a href=\"https://www.cnblogs.com/dashnowords/category/1284284.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dashnowords/category/1284284.html</a></li>\n<li>Webpack官网：<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/</a> 【建议】</li>\n</ul>\n<h3 id=\"Webpack核心：tapable类\"><a href=\"#Webpack核心：tapable类\" class=\"headerlink\" title=\"Webpack核心：tapable类\"></a>Webpack核心：tapable类</h3><p><code>tapable</code>是<code>webpack</code>的核心框架（4.0以上版本的API已经发生了变化），是一个基于事件流的框架，或者叫做发布订阅模式，或观察者模式，<code>webpack</code>的整个生命周期及其开放的自定义插件系统都离不开<code>tapable</code>的支持，研究其运行原理是阅读<code>webpack</code>源代码的第一步。官方仓库master分支的代码是经过ES6重构的，模块化拆分非常细，且加入了很多非核心逻辑，阅读难度较大。建议先从官方仓库中0.2版本的分支开始学习，整个源码只有400行，相对容易理解。</p>\n<ul>\n<li>0.2版本链接：<a href=\"https://github.com/webpack/tapable/tree/tapable-0.2\" target=\"_blank\" rel=\"noopener\">https://github.com/webpack/tapable/tree/tapable-0.2</a></li>\n</ul>\n<h3 id=\"代码地址\"><a href=\"#代码地址\" class=\"headerlink\" title=\"代码地址\"></a>代码地址</h3><p><a href=\"https://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project\" target=\"_blank\" rel=\"noopener\">https://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project</a></p>\n","site":{"data":{}},"excerpt":"<p><br></p>\n<h1 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h1><h2 id=\"为什么要使用WebPack\"><a href=\"#为什么要使用WebPack\" class=\"headerlink\" title=\"为什么要使用WebPack\"></a>为什么要使用WebPack</h2><p>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p>\n<p>模块化，让我们可以把复杂的程序细化为小的文件;<br>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；<br>Scss，less等CSS预处理器<br>…<br>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。</p>\n<p>什么是Webpack</p>","more":"<hr>\n<p>webpack可以看做是模块打包机：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用</p>\n<h2 id=\"Webpack的工作方式\"><a href=\"#Webpack的工作方式\" class=\"headerlink\" title=\"Webpack的工作方式\"></a>Webpack的工作方式</h2><p>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p>\n<h1 id=\"开始使用Webpack\"><a href=\"#开始使用Webpack\" class=\"headerlink\" title=\"开始使用Webpack\"></a>开始使用Webpack</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 全局安装</span><br><span class=\"line\">npm install -g webpack</span><br><span class=\"line\">npm install -g webpack-cli</span><br><span class=\"line\">npm install -g webpack-dev-server</span><br></pre></td></tr></table></figure>\n<h1 id=\"正式使用webpack\"><a href=\"#正式使用webpack\" class=\"headerlink\" title=\"正式使用webpack\"></a>正式使用webpack</h1><p>####通过命令行使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry file 表示入口文件</span><br><span class=\"line\">// output file 表示出口文件的路径和文件名</span><br><span class=\"line\">webpack &#123;entry file&#125; &#123;output file&#125; </span><br><span class=\"line\">在最新版本的使用方法</span><br><span class=\"line\">// -o 参数表示指定之后的内容为输入文件</span><br><span class=\"line\">webpack &#123;entry file&#125; -o &#123;output file&#125;</span><br></pre></td></tr></table></figure></p>\n<p>####通过配置文件使用</p>\n<p>生成一个webpack.config.js文件，输入以下简单配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &quot;source-map&quot;, // 打包方式，后续会提及</span><br><span class=\"line\">  entry: __dirname + &quot;/app/main.js&quot;, // 入口文件</span><br><span class=\"line\">  output: &#123;  // 出口文件</span><br><span class=\"line\">    path: __dirname + &quot;/public/&quot;,  // 出口文件路径</span><br><span class=\"line\">    filename: &apos;bundle.js&apos; // 出口文件名</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>__dirname 表示当前执行脚本的所在路径，为node环境的全局变量</p>\n</blockquote>\n<h1 id=\"WebPack强大功能\"><a href=\"#WebPack强大功能\" class=\"headerlink\" title=\"WebPack强大功能\"></a>WebPack强大功能</h1><p>####使用Source Maps（使调试更容易）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">devtool选项</th>\n<th>配置结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">source-map</td>\n<td>在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cheap-module-source-map</td>\n<td>在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">eval-source-map</td>\n<td>使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cheap-module-eval-source-map</td>\n<td>这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；</td>\n</tr>\n</tbody>\n</table>\n<p>####使用Webpack构建本地服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &quot;eval-source-map&quot;, //</span><br><span class=\"line\">  entry: __dirname + &quot;/app/main.js&quot;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/public/&quot;,</span><br><span class=\"line\">    filename: &apos;bundle.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    contentBase: &apos;./public&apos;, // 本地服务器所加载的页面所载目录</span><br><span class=\"line\">    historyApiFallback: true, // 是否跳转</span><br><span class=\"line\">    inline: true // 实时刷新</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">devserver的配置</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">contentBase</td>\n<td>默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">port</td>\n<td>设置默认监听端口，如果省略，默认为”8080“</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">inline</td>\n<td>设置为true，当源文件改变时会自动刷新页面</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">historyApiFallback</td>\n<td>在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</td>\n</tr>\n</tbody>\n</table>\n<p>####Loaders<br>通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。<br>对于Vue而言，使用Vue-loader进行解析各种Vue文件翻译成浏览器可编译的代码。</p>\n<p>webpack官方推荐提供了两个utils<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loader-utils // 提供很多有用的工具，其中最普遍使用的是获取options。</span><br><span class=\"line\">schema-utils // 能够校验传来的options是否合法</span><br></pre></td></tr></table></figure></p>\n<p>#####Loader特性</p>\n<ol>\n<li>loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。</li>\n<li>loader 可以是同步的，也可以是异步的。</li>\n<li>loader 运行在 Node.js 中，并且能够执行任何可能的操作。</li>\n<li>loader 接收查询参数。用于对 loader 传递配置。</li>\n<li>loader 也能够使用 options 对象进行配置。</li>\n<li>除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。</li>\n<li>插件(plugin)可以为 loader 带来更多特性。</li>\n<li>loader 能够产生额外的任意文件。</li>\n</ol>\n<p>####Babel<br>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：</p>\n<p>让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持；<br>让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；</p>\n<p>#####Babel的安装和配置<br>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，对于每一个单独需要的功能的扩展，需要安装单独的包（常用的有解析Es6的babel-env-preset包）</p>\n<p>安装：</p>\n<blockquote>\n<p>webpack 4.x | babel-loader 8.x | babel 7.x<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -D babel-loader @babel/core @babel/preset-env webpack</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>.babelrc文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;@babel/preset-env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>webpack 4.x | babel-loader 7.x | babel 6.x<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -D babel-loader@7 babel-core babel-preset-env webpack</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>.babelrc文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>####Plugins<br>常用的插件</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">插件名</th>\n<th>说明</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">HtmlWebpackPlugin</td>\n<td>依据一个html模板，生成一个新的html文件，可做模板的替换，插入js</td>\n<td><a href=\"https://www.npmjs.com/package/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/html-webpack-plugin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CleanWebpackPlugin</td>\n<td>在打包之前指定删除文件或文件夹</td>\n<td><a href=\"https://www.npmjs.com/package/clean-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/clean-webpack-plugin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mini-css-extract-plugin</td>\n<td>将指定的内容从打包的文件分离，webpack4废除了extract-text-webpack-plugin这个插件</td>\n<td><a href=\"https://www.npmjs.com/package/mini-css-extract-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/mini-css-extract-plugin</a></td>\n</tr>\n</tbody>\n</table>\n<p>#####Webpack内置插件<br>不做叙述<a href=\"https://www.webpackjs.com/plugins/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/plugins/</a></p>\n<p>#####编写一个Webpack插件<br>Webpack插件由以下组成：</p>\n<blockquote>\n<ol>\n<li>一个JavaScript命名函数</li>\n<li>在插件函数的prototype上顶一个一个apply方法</li>\n<li>制定一个绑定webpack自身的事件钩子。</li>\n<li>处理webpack内部实例的特定数据。</li>\n<li>功能完成后调用webpack回调</li>\n</ol>\n</blockquote>\n<p>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个 JavaScript 命名函数。</span><br><span class=\"line\">const pluginName = &apos;MyWebPackPlugin&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">class FileListPlugin &#123;</span><br><span class=\"line\">  apply (compiler) &#123;</span><br><span class=\"line\">    compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;Webpack开始构建中&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中有两个重要的回调：</p>\n<ul>\n<li><p>compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p>\n<ul>\n<li><p>使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compiler.hooks.someHook.tap(/* ... */);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>someHook列表：<a href=\"https://webpack.js.org/api/compiler-hooks/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/api/compiler-hooks/</a></p>\n</li>\n</ul>\n</li>\n<li><p>compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p>\n<ul>\n<li><p>使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compilation.hooks.someHook.tap(/* ... */);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>someHook列表：<a href=\"https://webpack.js.org/api/compilation-hooks/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/api/compilation-hooks/</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>tap方法表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法名</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">tap</td>\n<td>同步方法，自动执行webpack的流程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tapAsync</td>\n<td>异步方法，必须在执行结束后调用webpack自己的callback()方法</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tapPromise</td>\n<td>返回一个Promise方法，当异步任务完成后需要在添加resolve(）方法</td>\n</tr>\n</tbody>\n</table>\n<p>参考文档：</p>\n<ul>\n<li>Webpack内部运行机制：<a href=\"https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，\" target=\"_blank\" rel=\"noopener\">https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，</a></li>\n<li>Webpack4.0逐个击破：<a href=\"https://www.cnblogs.com/dashnowords/category/1284284.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dashnowords/category/1284284.html</a></li>\n<li>Webpack官网：<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/</a> 【建议】</li>\n</ul>\n<h3 id=\"Webpack核心：tapable类\"><a href=\"#Webpack核心：tapable类\" class=\"headerlink\" title=\"Webpack核心：tapable类\"></a>Webpack核心：tapable类</h3><p><code>tapable</code>是<code>webpack</code>的核心框架（4.0以上版本的API已经发生了变化），是一个基于事件流的框架，或者叫做发布订阅模式，或观察者模式，<code>webpack</code>的整个生命周期及其开放的自定义插件系统都离不开<code>tapable</code>的支持，研究其运行原理是阅读<code>webpack</code>源代码的第一步。官方仓库master分支的代码是经过ES6重构的，模块化拆分非常细，且加入了很多非核心逻辑，阅读难度较大。建议先从官方仓库中0.2版本的分支开始学习，整个源码只有400行，相对容易理解。</p>\n<ul>\n<li>0.2版本链接：<a href=\"https://github.com/webpack/tapable/tree/tapable-0.2\" target=\"_blank\" rel=\"noopener\">https://github.com/webpack/tapable/tree/tapable-0.2</a></li>\n</ul>\n<h3 id=\"代码地址\"><a href=\"#代码地址\" class=\"headerlink\" title=\"代码地址\"></a>代码地址</h3><p><a href=\"https://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project\" target=\"_blank\" rel=\"noopener\">https://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project</a></p>"},{"title":"AST入门","date":"2019-06-03T11:01:25.459Z","_content":"\n前言\n===\n\n<a href=\"https://astexplorer.net/\">AST Explore，可视化工具</a>\n\n现如今，许多各式各样的框架诞生，特别是多端生成的解决方案，例如：taro，Chameleon（卡梅隆），小程序框架: mpvue，wepy。\n又或者在其他场景，如：\n1. eslint对代码错误或风格的检查，发现一些潜在的错误\n2. IDE的错误提示、格式化、高亮、自动补全等.\n3. UglifyJS压缩代码.\n4. 代码打包工具webpack。\n\n万变不离其宗，都是站在AST这个巨人的肩膀上。\n且对于体力型的，或者重复性的工作，能用工具化，流程化解决就用他们解决。\n\n在了解编译器之前，了解一下babel的编译过程。<a href=\"https://yq.aliyun.com/articles/62671\">(来源)</a>\n\n![来源](https://user-gold-cdn.xitu.io/2018/12/24/167dfa8949b0401a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n<!--more-->\n\n\n## 什么是编译器\n\n编译器：能够把一种语言等价得转换为另一种目标语言。从现代高级编译器的角度讲，源语言是高级程序设计语言，\n容易阅读与编写，而目标语言是机器语言，即二进制代码，能够被计算机直接识别。\n语言系统的处理角度来看，由源程序生成可执行程序的整体工作流程如下所示。\n\n源程序 -> 预处理器 -> 编译器 -> 目标程序 -> .... -> 可执行程序\n\n编译器又分为前端和后端。前端包括词法分析、语法分析、语义分析、中间代码生成，具有机器无关性，比较有代表性的工具是 Flex、Bison。\n后端包括中间代码优化、目标代码生成，具有机器相关性，比较有代表性的工具是 LLVM。\n\n具体编译原理，查看这篇文章 <a href=\"https://zhuanlan.zhihu.com/p/31096468\">前端为什么要学习编译原理</a>\n\n## 编译器的编译过程\n\n### 1.词法分析\n\n获取原始代码，称为文法，scan，进行分析，转换为词法单元。token是一个不可再分割的最小单元，每个不可分割的最小单元\n都有能被唯一识别的类型和其他附加属性，并通过一个标记器将其拆分为这些命名标记的东西。最终生成一个tokens。\n对于token的验证，可以用正则表达式，一个一个进行扫描匹配，指针不断往后移直至不满足匹配规则或达到末尾。\n这个过程会过滤换行符和空格等等\n例如：\n```vue\n   const input = '(add 2 (subtract 4 \"abc\"))'\n// 转换为\n   const tokens = [ { type: 'paren', value: '(' },\n     { type: 'name', value: 'add' },\n     { type: 'number', value: '2' },\n     { type: 'paren', value: '(' },\n     { type: 'name', value: 'subtract' },\n     { type: 'number', value: '4' },\n     { type: 'number', value: '2' },\n     { type: 'paren', value: ')' },\n     { type: 'paren', value: ')' } ]\n```\n\n### 2.语法分析\n根据token的标记，逐个读入token，使用深度优先遍历并将其重新格式化为描述语法各个部分及其相互关系的表示形式，称为AST。\n遇到起始符号，如\"<\", \"(\", \"{\" 等，嵌套递归，直到遇到终结符号，退出遍历。\n这是一个深度嵌套的对象，以一种即方便使用又能提供大量信息的方式来表示的代码。\n例如:\n```vue\nconst ast = {\n  type: 'Program',\n  body: [{\n    type: 'CallExpression',\n    name: 'add',\n    params: [{\n      type: 'NumberLiteral',\n      value: '2'\n    }, {\n      type: 'CallExpression',\n      name: 'subtract',\n      params: [{\n        type: 'NumberLiteral',\n        value: '4'\n      }, {\n        type: 'NumberLiteral',\n        value: '2'\n      }]\n    }]\n  }]\n}\n```\n\n### 3.语义分析（转换）\n\n这个阶段是编译器对上一个AST进行转换，它可以用一种语言操作AST, 也可以翻译成全新的语言。在这个过程中，\n我们可以通过 添加/删除/替换属性来操作节点。并基于它创造一个新的AST。例如可以把wx全转为swan等等，或者\n在原先的代码基础上添加目标结果的一些特性。\n完成上述功能，必须通过递归进行遍历每一层。由于仅仅只需要访问每一个节点就足够了，因此利用visitor就可以解决这个问题。\n当遇到匹配类型的节点时，我们只需要调用对应visitor中的方法就可以解决问题。\nvisitor的方法可能如下：\n```vue\nvar visitor = {\n  NumberLiteral(node, parent) {},\n  CallExpression(node, parent) {},\n  ...\n};\n```\n但如果需要在离开当前节点的时候做一些操作呢？\n我们可以更新下visitor方法，如下所示:\n```vue\nconst visitor = {\n    NumberLiteral: {\n      enter(node, parent) {\n        parent._context.push({\n          type: 'NumberLiteral',\n          value: node.value\n        })\n      },\n      exit(node, parent) {\n         // do something\n      }\n    },\n    StringLiteral: {\n      enter(node, parent) {\n        parent._context.push({\n          type: 'StringLiteral',\n          value: node.value\n        })\n      }\n    },\n    ...\n  }\n```\n\n有了visitor对象，就可以在traverseNode（转换节点）的过程中, 对特定的节点进行转换操作，并做一些其他事情。\n具体流程如下：\n\n- → Program (enter)\n  - → CallExpression (enter)\n     - → NumberLiteral (enter)\n     - ← NumberLiteral (exit)\n     - → CallExpression (enter)\n       - → NumberLiteral (enter)\n       - ← NumberLiteral (exit)\n       - → NumberLiteral (enter)\n       - ← NumberLiteral (exit)\n     - ← CallExpression (exit)\n  - ← CallExpression (exit)\n- ← Program (exit)\n\n### 4. 代码生成\n\n代码生成器应当知道如何打印AST的所有不同类型的节点，并且递归调用来打印嵌套节点，直到生成最终代码。\n\n## 制作一个babel插件\n\n由于小程序开发比较多，有接触百度小程序和微信小程序等等，肯定会面临一个转换的问题，如 wx => swan 等。\n这里就尝试做一个类似的插件。\n\n### 1. 创建基础结构（插件的基础）\n\n```vue\nconst babel = require('babel-core');\n\n// 输入的文法\nconst input = `\nfunction test() {\n  wx.showModal({\n    title: \"modal\",\n    content: 'content'\n  })\n}\n`\n\n// 需要做的插件功能\nconst plugin = ({types: t}) => {\n  return {\n    visitor: {\n    }\n  }\n}\n\n// 利用插件\nconst res = babel.transform(input, {\n  plugins: [plugin]\n})\n\nconsole.log(res.code)\n```\n\n### 2. 使用https://astexplorer.net/ 进行AST分析。\n\n如图所示：\n![](https://img4.tuhu.org/PeccancyCheXingYi/Fi-8bDBlO2XddekCkb9NTbL1eXv3_w649_h800.jpeg@100Q.jpg)\n\n由于需要做的是 wx => swan, 因此要找到wx这个文法对应的表达式，这里找到的是 \"callee： MemberExpression\"， 然后修改plugin代码\n```vue\nconst plugin = ({types: t}) => {\n  return {\n    visitor: {\n      MemberExpression: {\n        enter(path, state) {\n          const node = path.node\n          const object = node.object\n          if (t.isMemberExpression(node) && t.isIdentifier(object, {name: 'wx'})) {\n            path.traverse({\n              Identifier(path) {\n                if (path.node.name === 'wx') {\n                  path.node.name = 'swan'\n                }\n              }\n            })\n          }\n        }\n      }\n    }\n  }\n}\n```\n其中 types 其实就是 babel.types这个库，在这里作为plugin会在回调的时候会把babel作为参数传入, 然后进行解构。\n可使用 types 来生成一个AST节点，或者来做浅层判断\n使用types.numericLiteral() 来生成一个数字类型的节点。\n使用types.isNumericLiteral() 来判断当前节点的name值是否为数字。\n\n在visitor中，path就是指当前访问者访问的节点。该对象下有许多属性和方法，例如\n```vue\n── 属性      \n  - node   当前节点\n  - parent  父节点\n  - parentPath 父path\n  - scope   作用域\n  - context  上下文\n  - ...\n── 方法\n  - get   当前节点\n  - findParent  向父节点搜寻节点\n  - getSibling 获取兄弟节点\n  - replaceWith  用AST节点替换该节点\n  - replaceWithSourceString  用资源字符串来代替这个节点，会在内部自动生成一个节点\n  - replaceWithMultiple 用多个AST节点替换该节点\n  - insertBefore  在节点前插入节点\n  - insertAfter 在节点后插入节点\n  - remove   删除节点\n  - ...\n```\n具体的可以查看babel-traverse\n\n### 3.执行插件\n\n结果为: \n```vue\nfunction test() {\n  swan.showModal({\n    title: \"modal\",\n    content: 'content'\n  });\n}\n```\n\n具体代码：\n<a href=\"https://github.com/SalterYu/MyBlog/blob/master/simple-bundler/babel-use/wx2swan.js\">wx2swan.js</a>\n<a href=\"https://github.com/SalterYu/MyBlog/tree/master/simple-compiler\">简易编译器</a>\n\n### 结尾\n分享几篇文章：\n- <a href=\"https://juejin.im/post/5c21b584e51d4548ac6f6c99\">Babel的深入了解</a> \n- <a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-writing-your-first-babel-plugin\">Babel插件手册</a> \n","source":"_posts/simple-compiler.md","raw":"---\ntitle: AST入门\ndate: 2019年03月18日\n---\n\n前言\n===\n\n<a href=\"https://astexplorer.net/\">AST Explore，可视化工具</a>\n\n现如今，许多各式各样的框架诞生，特别是多端生成的解决方案，例如：taro，Chameleon（卡梅隆），小程序框架: mpvue，wepy。\n又或者在其他场景，如：\n1. eslint对代码错误或风格的检查，发现一些潜在的错误\n2. IDE的错误提示、格式化、高亮、自动补全等.\n3. UglifyJS压缩代码.\n4. 代码打包工具webpack。\n\n万变不离其宗，都是站在AST这个巨人的肩膀上。\n且对于体力型的，或者重复性的工作，能用工具化，流程化解决就用他们解决。\n\n在了解编译器之前，了解一下babel的编译过程。<a href=\"https://yq.aliyun.com/articles/62671\">(来源)</a>\n\n![来源](https://user-gold-cdn.xitu.io/2018/12/24/167dfa8949b0401a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n<!--more-->\n\n\n## 什么是编译器\n\n编译器：能够把一种语言等价得转换为另一种目标语言。从现代高级编译器的角度讲，源语言是高级程序设计语言，\n容易阅读与编写，而目标语言是机器语言，即二进制代码，能够被计算机直接识别。\n语言系统的处理角度来看，由源程序生成可执行程序的整体工作流程如下所示。\n\n源程序 -> 预处理器 -> 编译器 -> 目标程序 -> .... -> 可执行程序\n\n编译器又分为前端和后端。前端包括词法分析、语法分析、语义分析、中间代码生成，具有机器无关性，比较有代表性的工具是 Flex、Bison。\n后端包括中间代码优化、目标代码生成，具有机器相关性，比较有代表性的工具是 LLVM。\n\n具体编译原理，查看这篇文章 <a href=\"https://zhuanlan.zhihu.com/p/31096468\">前端为什么要学习编译原理</a>\n\n## 编译器的编译过程\n\n### 1.词法分析\n\n获取原始代码，称为文法，scan，进行分析，转换为词法单元。token是一个不可再分割的最小单元，每个不可分割的最小单元\n都有能被唯一识别的类型和其他附加属性，并通过一个标记器将其拆分为这些命名标记的东西。最终生成一个tokens。\n对于token的验证，可以用正则表达式，一个一个进行扫描匹配，指针不断往后移直至不满足匹配规则或达到末尾。\n这个过程会过滤换行符和空格等等\n例如：\n```vue\n   const input = '(add 2 (subtract 4 \"abc\"))'\n// 转换为\n   const tokens = [ { type: 'paren', value: '(' },\n     { type: 'name', value: 'add' },\n     { type: 'number', value: '2' },\n     { type: 'paren', value: '(' },\n     { type: 'name', value: 'subtract' },\n     { type: 'number', value: '4' },\n     { type: 'number', value: '2' },\n     { type: 'paren', value: ')' },\n     { type: 'paren', value: ')' } ]\n```\n\n### 2.语法分析\n根据token的标记，逐个读入token，使用深度优先遍历并将其重新格式化为描述语法各个部分及其相互关系的表示形式，称为AST。\n遇到起始符号，如\"<\", \"(\", \"{\" 等，嵌套递归，直到遇到终结符号，退出遍历。\n这是一个深度嵌套的对象，以一种即方便使用又能提供大量信息的方式来表示的代码。\n例如:\n```vue\nconst ast = {\n  type: 'Program',\n  body: [{\n    type: 'CallExpression',\n    name: 'add',\n    params: [{\n      type: 'NumberLiteral',\n      value: '2'\n    }, {\n      type: 'CallExpression',\n      name: 'subtract',\n      params: [{\n        type: 'NumberLiteral',\n        value: '4'\n      }, {\n        type: 'NumberLiteral',\n        value: '2'\n      }]\n    }]\n  }]\n}\n```\n\n### 3.语义分析（转换）\n\n这个阶段是编译器对上一个AST进行转换，它可以用一种语言操作AST, 也可以翻译成全新的语言。在这个过程中，\n我们可以通过 添加/删除/替换属性来操作节点。并基于它创造一个新的AST。例如可以把wx全转为swan等等，或者\n在原先的代码基础上添加目标结果的一些特性。\n完成上述功能，必须通过递归进行遍历每一层。由于仅仅只需要访问每一个节点就足够了，因此利用visitor就可以解决这个问题。\n当遇到匹配类型的节点时，我们只需要调用对应visitor中的方法就可以解决问题。\nvisitor的方法可能如下：\n```vue\nvar visitor = {\n  NumberLiteral(node, parent) {},\n  CallExpression(node, parent) {},\n  ...\n};\n```\n但如果需要在离开当前节点的时候做一些操作呢？\n我们可以更新下visitor方法，如下所示:\n```vue\nconst visitor = {\n    NumberLiteral: {\n      enter(node, parent) {\n        parent._context.push({\n          type: 'NumberLiteral',\n          value: node.value\n        })\n      },\n      exit(node, parent) {\n         // do something\n      }\n    },\n    StringLiteral: {\n      enter(node, parent) {\n        parent._context.push({\n          type: 'StringLiteral',\n          value: node.value\n        })\n      }\n    },\n    ...\n  }\n```\n\n有了visitor对象，就可以在traverseNode（转换节点）的过程中, 对特定的节点进行转换操作，并做一些其他事情。\n具体流程如下：\n\n- → Program (enter)\n  - → CallExpression (enter)\n     - → NumberLiteral (enter)\n     - ← NumberLiteral (exit)\n     - → CallExpression (enter)\n       - → NumberLiteral (enter)\n       - ← NumberLiteral (exit)\n       - → NumberLiteral (enter)\n       - ← NumberLiteral (exit)\n     - ← CallExpression (exit)\n  - ← CallExpression (exit)\n- ← Program (exit)\n\n### 4. 代码生成\n\n代码生成器应当知道如何打印AST的所有不同类型的节点，并且递归调用来打印嵌套节点，直到生成最终代码。\n\n## 制作一个babel插件\n\n由于小程序开发比较多，有接触百度小程序和微信小程序等等，肯定会面临一个转换的问题，如 wx => swan 等。\n这里就尝试做一个类似的插件。\n\n### 1. 创建基础结构（插件的基础）\n\n```vue\nconst babel = require('babel-core');\n\n// 输入的文法\nconst input = `\nfunction test() {\n  wx.showModal({\n    title: \"modal\",\n    content: 'content'\n  })\n}\n`\n\n// 需要做的插件功能\nconst plugin = ({types: t}) => {\n  return {\n    visitor: {\n    }\n  }\n}\n\n// 利用插件\nconst res = babel.transform(input, {\n  plugins: [plugin]\n})\n\nconsole.log(res.code)\n```\n\n### 2. 使用https://astexplorer.net/ 进行AST分析。\n\n如图所示：\n![](https://img4.tuhu.org/PeccancyCheXingYi/Fi-8bDBlO2XddekCkb9NTbL1eXv3_w649_h800.jpeg@100Q.jpg)\n\n由于需要做的是 wx => swan, 因此要找到wx这个文法对应的表达式，这里找到的是 \"callee： MemberExpression\"， 然后修改plugin代码\n```vue\nconst plugin = ({types: t}) => {\n  return {\n    visitor: {\n      MemberExpression: {\n        enter(path, state) {\n          const node = path.node\n          const object = node.object\n          if (t.isMemberExpression(node) && t.isIdentifier(object, {name: 'wx'})) {\n            path.traverse({\n              Identifier(path) {\n                if (path.node.name === 'wx') {\n                  path.node.name = 'swan'\n                }\n              }\n            })\n          }\n        }\n      }\n    }\n  }\n}\n```\n其中 types 其实就是 babel.types这个库，在这里作为plugin会在回调的时候会把babel作为参数传入, 然后进行解构。\n可使用 types 来生成一个AST节点，或者来做浅层判断\n使用types.numericLiteral() 来生成一个数字类型的节点。\n使用types.isNumericLiteral() 来判断当前节点的name值是否为数字。\n\n在visitor中，path就是指当前访问者访问的节点。该对象下有许多属性和方法，例如\n```vue\n── 属性      \n  - node   当前节点\n  - parent  父节点\n  - parentPath 父path\n  - scope   作用域\n  - context  上下文\n  - ...\n── 方法\n  - get   当前节点\n  - findParent  向父节点搜寻节点\n  - getSibling 获取兄弟节点\n  - replaceWith  用AST节点替换该节点\n  - replaceWithSourceString  用资源字符串来代替这个节点，会在内部自动生成一个节点\n  - replaceWithMultiple 用多个AST节点替换该节点\n  - insertBefore  在节点前插入节点\n  - insertAfter 在节点后插入节点\n  - remove   删除节点\n  - ...\n```\n具体的可以查看babel-traverse\n\n### 3.执行插件\n\n结果为: \n```vue\nfunction test() {\n  swan.showModal({\n    title: \"modal\",\n    content: 'content'\n  });\n}\n```\n\n具体代码：\n<a href=\"https://github.com/SalterYu/MyBlog/blob/master/simple-bundler/babel-use/wx2swan.js\">wx2swan.js</a>\n<a href=\"https://github.com/SalterYu/MyBlog/tree/master/simple-compiler\">简易编译器</a>\n\n### 结尾\n分享几篇文章：\n- <a href=\"https://juejin.im/post/5c21b584e51d4548ac6f6c99\">Babel的深入了解</a> \n- <a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-writing-your-first-babel-plugin\">Babel插件手册</a> \n","slug":"simple-compiler","published":1,"updated":"2019-06-03T11:01:25.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdsjt88f0006falv9lszxixp","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p><a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener\">AST Explore，可视化工具</a></p>\n<p>现如今，许多各式各样的框架诞生，特别是多端生成的解决方案，例如：taro，Chameleon（卡梅隆），小程序框架: mpvue，wepy。<br>又或者在其他场景，如：</p>\n<ol>\n<li>eslint对代码错误或风格的检查，发现一些潜在的错误</li>\n<li>IDE的错误提示、格式化、高亮、自动补全等.</li>\n<li>UglifyJS压缩代码.</li>\n<li>代码打包工具webpack。</li>\n</ol>\n<p>万变不离其宗，都是站在AST这个巨人的肩膀上。<br>且对于体力型的，或者重复性的工作，能用工具化，流程化解决就用他们解决。</p>\n<p>在了解编译器之前，了解一下babel的编译过程。<a href=\"https://yq.aliyun.com/articles/62671\" target=\"_blank\" rel=\"noopener\">(来源)</a></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/24/167dfa8949b0401a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"来源\"><br><a id=\"more\"></a></p>\n<h2 id=\"什么是编译器\"><a href=\"#什么是编译器\" class=\"headerlink\" title=\"什么是编译器\"></a>什么是编译器</h2><p>编译器：能够把一种语言等价得转换为另一种目标语言。从现代高级编译器的角度讲，源语言是高级程序设计语言，<br>容易阅读与编写，而目标语言是机器语言，即二进制代码，能够被计算机直接识别。<br>语言系统的处理角度来看，由源程序生成可执行程序的整体工作流程如下所示。</p>\n<p>源程序 -&gt; 预处理器 -&gt; 编译器 -&gt; 目标程序 -&gt; …. -&gt; 可执行程序</p>\n<p>编译器又分为前端和后端。前端包括词法分析、语法分析、语义分析、中间代码生成，具有机器无关性，比较有代表性的工具是 Flex、Bison。<br>后端包括中间代码优化、目标代码生成，具有机器相关性，比较有代表性的工具是 LLVM。</p>\n<p>具体编译原理，查看这篇文章 <a href=\"https://zhuanlan.zhihu.com/p/31096468\" target=\"_blank\" rel=\"noopener\">前端为什么要学习编译原理</a></p>\n<h2 id=\"编译器的编译过程\"><a href=\"#编译器的编译过程\" class=\"headerlink\" title=\"编译器的编译过程\"></a>编译器的编译过程</h2><h3 id=\"1-词法分析\"><a href=\"#1-词法分析\" class=\"headerlink\" title=\"1.词法分析\"></a>1.词法分析</h3><p>获取原始代码，称为文法，scan，进行分析，转换为词法单元。token是一个不可再分割的最小单元，每个不可分割的最小单元<br>都有能被唯一识别的类型和其他附加属性，并通过一个标记器将其拆分为这些命名标记的东西。最终生成一个tokens。<br>对于token的验证，可以用正则表达式，一个一个进行扫描匹配，指针不断往后移直至不满足匹配规则或达到末尾。<br>这个过程会过滤换行符和空格等等<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const input = &apos;(add 2 (subtract 4 &quot;abc&quot;))&apos;</span><br><span class=\"line\">// 转换为</span><br><span class=\"line\">   const tokens = [ &#123; type: &apos;paren&apos;, value: &apos;(&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;name&apos;, value: &apos;add&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;number&apos;, value: &apos;2&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;paren&apos;, value: &apos;(&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;name&apos;, value: &apos;subtract&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;number&apos;, value: &apos;4&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;number&apos;, value: &apos;2&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;paren&apos;, value: &apos;)&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;paren&apos;, value: &apos;)&apos; &#125; ]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-语法分析\"><a href=\"#2-语法分析\" class=\"headerlink\" title=\"2.语法分析\"></a>2.语法分析</h3><p>根据token的标记，逐个读入token，使用深度优先遍历并将其重新格式化为描述语法各个部分及其相互关系的表示形式，称为AST。<br>遇到起始符号，如”&lt;”, “(“, “{“ 等，嵌套递归，直到遇到终结符号，退出遍历。<br>这是一个深度嵌套的对象，以一种即方便使用又能提供大量信息的方式来表示的代码。<br>例如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ast = &#123;</span><br><span class=\"line\">  type: &apos;Program&apos;,</span><br><span class=\"line\">  body: [&#123;</span><br><span class=\"line\">    type: &apos;CallExpression&apos;,</span><br><span class=\"line\">    name: &apos;add&apos;,</span><br><span class=\"line\">    params: [&#123;</span><br><span class=\"line\">      type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">      value: &apos;2&apos;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      type: &apos;CallExpression&apos;,</span><br><span class=\"line\">      name: &apos;subtract&apos;,</span><br><span class=\"line\">      params: [&#123;</span><br><span class=\"line\">        type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">        value: &apos;4&apos;</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">        value: &apos;2&apos;</span><br><span class=\"line\">      &#125;]</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-语义分析（转换）\"><a href=\"#3-语义分析（转换）\" class=\"headerlink\" title=\"3.语义分析（转换）\"></a>3.语义分析（转换）</h3><p>这个阶段是编译器对上一个AST进行转换，它可以用一种语言操作AST, 也可以翻译成全新的语言。在这个过程中，<br>我们可以通过 添加/删除/替换属性来操作节点。并基于它创造一个新的AST。例如可以把wx全转为swan等等，或者<br>在原先的代码基础上添加目标结果的一些特性。<br>完成上述功能，必须通过递归进行遍历每一层。由于仅仅只需要访问每一个节点就足够了，因此利用visitor就可以解决这个问题。<br>当遇到匹配类型的节点时，我们只需要调用对应visitor中的方法就可以解决问题。<br>visitor的方法可能如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var visitor = &#123;</span><br><span class=\"line\">  NumberLiteral(node, parent) &#123;&#125;,</span><br><span class=\"line\">  CallExpression(node, parent) &#123;&#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>但如果需要在离开当前节点的时候做一些操作呢？<br>我们可以更新下visitor方法，如下所示:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const visitor = &#123;</span><br><span class=\"line\">    NumberLiteral: &#123;</span><br><span class=\"line\">      enter(node, parent) &#123;</span><br><span class=\"line\">        parent._context.push(&#123;</span><br><span class=\"line\">          type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">          value: node.value</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      exit(node, parent) &#123;</span><br><span class=\"line\">         // do something</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    StringLiteral: &#123;</span><br><span class=\"line\">      enter(node, parent) &#123;</span><br><span class=\"line\">        parent._context.push(&#123;</span><br><span class=\"line\">          type: &apos;StringLiteral&apos;,</span><br><span class=\"line\">          value: node.value</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>有了visitor对象，就可以在traverseNode（转换节点）的过程中, 对特定的节点进行转换操作，并做一些其他事情。<br>具体流程如下：</p>\n<ul>\n<li>→ Program (enter)<ul>\n<li>→ CallExpression (enter)<ul>\n<li>→ NumberLiteral (enter)</li>\n<li>← NumberLiteral (exit)</li>\n<li>→ CallExpression (enter)<ul>\n<li>→ NumberLiteral (enter)</li>\n<li>← NumberLiteral (exit)</li>\n<li>→ NumberLiteral (enter)</li>\n<li>← NumberLiteral (exit)</li>\n</ul>\n</li>\n<li>← CallExpression (exit)</li>\n</ul>\n</li>\n<li>← CallExpression (exit)</li>\n</ul>\n</li>\n<li>← Program (exit)</li>\n</ul>\n<h3 id=\"4-代码生成\"><a href=\"#4-代码生成\" class=\"headerlink\" title=\"4. 代码生成\"></a>4. 代码生成</h3><p>代码生成器应当知道如何打印AST的所有不同类型的节点，并且递归调用来打印嵌套节点，直到生成最终代码。</p>\n<h2 id=\"制作一个babel插件\"><a href=\"#制作一个babel插件\" class=\"headerlink\" title=\"制作一个babel插件\"></a>制作一个babel插件</h2><p>由于小程序开发比较多，有接触百度小程序和微信小程序等等，肯定会面临一个转换的问题，如 wx =&gt; swan 等。<br>这里就尝试做一个类似的插件。</p>\n<h3 id=\"1-创建基础结构（插件的基础）\"><a href=\"#1-创建基础结构（插件的基础）\" class=\"headerlink\" title=\"1. 创建基础结构（插件的基础）\"></a>1. 创建基础结构（插件的基础）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const babel = require(&apos;babel-core&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输入的文法</span><br><span class=\"line\">const input = `</span><br><span class=\"line\">function test() &#123;</span><br><span class=\"line\">  wx.showModal(&#123;</span><br><span class=\"line\">    title: &quot;modal&quot;,</span><br><span class=\"line\">    content: &apos;content&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">`</span><br><span class=\"line\"></span><br><span class=\"line\">// 需要做的插件功能</span><br><span class=\"line\">const plugin = (&#123;types: t&#125;) =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    visitor: &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 利用插件</span><br><span class=\"line\">const res = babel.transform(input, &#123;</span><br><span class=\"line\">  plugins: [plugin]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(res.code)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用https-astexplorer-net-进行AST分析。\"><a href=\"#2-使用https-astexplorer-net-进行AST分析。\" class=\"headerlink\" title=\"2. 使用https://astexplorer.net/ 进行AST分析。\"></a>2. 使用<a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener\">https://astexplorer.net/</a> 进行AST分析。</h3><p>如图所示：<br><img src=\"https://img4.tuhu.org/PeccancyCheXingYi/Fi-8bDBlO2XddekCkb9NTbL1eXv3_w649_h800.jpeg@100Q.jpg\" alt=\"\"></p>\n<p>由于需要做的是 wx =&gt; swan, 因此要找到wx这个文法对应的表达式，这里找到的是 “callee： MemberExpression”， 然后修改plugin代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const plugin = (&#123;types: t&#125;) =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    visitor: &#123;</span><br><span class=\"line\">      MemberExpression: &#123;</span><br><span class=\"line\">        enter(path, state) &#123;</span><br><span class=\"line\">          const node = path.node</span><br><span class=\"line\">          const object = node.object</span><br><span class=\"line\">          if (t.isMemberExpression(node) &amp;&amp; t.isIdentifier(object, &#123;name: &apos;wx&apos;&#125;)) &#123;</span><br><span class=\"line\">            path.traverse(&#123;</span><br><span class=\"line\">              Identifier(path) &#123;</span><br><span class=\"line\">                if (path.node.name === &apos;wx&apos;) &#123;</span><br><span class=\"line\">                  path.node.name = &apos;swan&apos;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中 types 其实就是 babel.types这个库，在这里作为plugin会在回调的时候会把babel作为参数传入, 然后进行解构。<br>可使用 types 来生成一个AST节点，或者来做浅层判断<br>使用types.numericLiteral() 来生成一个数字类型的节点。<br>使用types.isNumericLiteral() 来判断当前节点的name值是否为数字。</p>\n<p>在visitor中，path就是指当前访问者访问的节点。该对象下有许多属性和方法，例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">── 属性      </span><br><span class=\"line\">  - node   当前节点</span><br><span class=\"line\">  - parent  父节点</span><br><span class=\"line\">  - parentPath 父path</span><br><span class=\"line\">  - scope   作用域</span><br><span class=\"line\">  - context  上下文</span><br><span class=\"line\">  - ...</span><br><span class=\"line\">── 方法</span><br><span class=\"line\">  - get   当前节点</span><br><span class=\"line\">  - findParent  向父节点搜寻节点</span><br><span class=\"line\">  - getSibling 获取兄弟节点</span><br><span class=\"line\">  - replaceWith  用AST节点替换该节点</span><br><span class=\"line\">  - replaceWithSourceString  用资源字符串来代替这个节点，会在内部自动生成一个节点</span><br><span class=\"line\">  - replaceWithMultiple 用多个AST节点替换该节点</span><br><span class=\"line\">  - insertBefore  在节点前插入节点</span><br><span class=\"line\">  - insertAfter 在节点后插入节点</span><br><span class=\"line\">  - remove   删除节点</span><br><span class=\"line\">  - ...</span><br></pre></td></tr></table></figure></p>\n<p>具体的可以查看babel-traverse</p>\n<h3 id=\"3-执行插件\"><a href=\"#3-执行插件\" class=\"headerlink\" title=\"3.执行插件\"></a>3.执行插件</h3><p>结果为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test() &#123;</span><br><span class=\"line\">  swan.showModal(&#123;</span><br><span class=\"line\">    title: &quot;modal&quot;,</span><br><span class=\"line\">    content: &apos;content&apos;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>具体代码：<br><a href=\"https://github.com/SalterYu/MyBlog/blob/master/simple-bundler/babel-use/wx2swan.js\" target=\"_blank\" rel=\"noopener\">wx2swan.js</a><br><a href=\"https://github.com/SalterYu/MyBlog/tree/master/simple-compiler\" target=\"_blank\" rel=\"noopener\">简易编译器</a></p>\n<h3 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h3><p>分享几篇文章：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5c21b584e51d4548ac6f6c99\" target=\"_blank\" rel=\"noopener\">Babel的深入了解</a> </li>\n<li><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-writing-your-first-babel-plugin\" target=\"_blank\" rel=\"noopener\">Babel插件手册</a> </li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p><a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener\">AST Explore，可视化工具</a></p>\n<p>现如今，许多各式各样的框架诞生，特别是多端生成的解决方案，例如：taro，Chameleon（卡梅隆），小程序框架: mpvue，wepy。<br>又或者在其他场景，如：</p>\n<ol>\n<li>eslint对代码错误或风格的检查，发现一些潜在的错误</li>\n<li>IDE的错误提示、格式化、高亮、自动补全等.</li>\n<li>UglifyJS压缩代码.</li>\n<li>代码打包工具webpack。</li>\n</ol>\n<p>万变不离其宗，都是站在AST这个巨人的肩膀上。<br>且对于体力型的，或者重复性的工作，能用工具化，流程化解决就用他们解决。</p>\n<p>在了解编译器之前，了解一下babel的编译过程。<a href=\"https://yq.aliyun.com/articles/62671\" target=\"_blank\" rel=\"noopener\">(来源)</a></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/24/167dfa8949b0401a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"来源\"><br>","more":"</p>\n<h2 id=\"什么是编译器\"><a href=\"#什么是编译器\" class=\"headerlink\" title=\"什么是编译器\"></a>什么是编译器</h2><p>编译器：能够把一种语言等价得转换为另一种目标语言。从现代高级编译器的角度讲，源语言是高级程序设计语言，<br>容易阅读与编写，而目标语言是机器语言，即二进制代码，能够被计算机直接识别。<br>语言系统的处理角度来看，由源程序生成可执行程序的整体工作流程如下所示。</p>\n<p>源程序 -&gt; 预处理器 -&gt; 编译器 -&gt; 目标程序 -&gt; …. -&gt; 可执行程序</p>\n<p>编译器又分为前端和后端。前端包括词法分析、语法分析、语义分析、中间代码生成，具有机器无关性，比较有代表性的工具是 Flex、Bison。<br>后端包括中间代码优化、目标代码生成，具有机器相关性，比较有代表性的工具是 LLVM。</p>\n<p>具体编译原理，查看这篇文章 <a href=\"https://zhuanlan.zhihu.com/p/31096468\" target=\"_blank\" rel=\"noopener\">前端为什么要学习编译原理</a></p>\n<h2 id=\"编译器的编译过程\"><a href=\"#编译器的编译过程\" class=\"headerlink\" title=\"编译器的编译过程\"></a>编译器的编译过程</h2><h3 id=\"1-词法分析\"><a href=\"#1-词法分析\" class=\"headerlink\" title=\"1.词法分析\"></a>1.词法分析</h3><p>获取原始代码，称为文法，scan，进行分析，转换为词法单元。token是一个不可再分割的最小单元，每个不可分割的最小单元<br>都有能被唯一识别的类型和其他附加属性，并通过一个标记器将其拆分为这些命名标记的东西。最终生成一个tokens。<br>对于token的验证，可以用正则表达式，一个一个进行扫描匹配，指针不断往后移直至不满足匹配规则或达到末尾。<br>这个过程会过滤换行符和空格等等<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const input = &apos;(add 2 (subtract 4 &quot;abc&quot;))&apos;</span><br><span class=\"line\">// 转换为</span><br><span class=\"line\">   const tokens = [ &#123; type: &apos;paren&apos;, value: &apos;(&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;name&apos;, value: &apos;add&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;number&apos;, value: &apos;2&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;paren&apos;, value: &apos;(&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;name&apos;, value: &apos;subtract&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;number&apos;, value: &apos;4&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;number&apos;, value: &apos;2&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;paren&apos;, value: &apos;)&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;paren&apos;, value: &apos;)&apos; &#125; ]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-语法分析\"><a href=\"#2-语法分析\" class=\"headerlink\" title=\"2.语法分析\"></a>2.语法分析</h3><p>根据token的标记，逐个读入token，使用深度优先遍历并将其重新格式化为描述语法各个部分及其相互关系的表示形式，称为AST。<br>遇到起始符号，如”&lt;”, “(“, “{“ 等，嵌套递归，直到遇到终结符号，退出遍历。<br>这是一个深度嵌套的对象，以一种即方便使用又能提供大量信息的方式来表示的代码。<br>例如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ast = &#123;</span><br><span class=\"line\">  type: &apos;Program&apos;,</span><br><span class=\"line\">  body: [&#123;</span><br><span class=\"line\">    type: &apos;CallExpression&apos;,</span><br><span class=\"line\">    name: &apos;add&apos;,</span><br><span class=\"line\">    params: [&#123;</span><br><span class=\"line\">      type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">      value: &apos;2&apos;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      type: &apos;CallExpression&apos;,</span><br><span class=\"line\">      name: &apos;subtract&apos;,</span><br><span class=\"line\">      params: [&#123;</span><br><span class=\"line\">        type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">        value: &apos;4&apos;</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">        value: &apos;2&apos;</span><br><span class=\"line\">      &#125;]</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-语义分析（转换）\"><a href=\"#3-语义分析（转换）\" class=\"headerlink\" title=\"3.语义分析（转换）\"></a>3.语义分析（转换）</h3><p>这个阶段是编译器对上一个AST进行转换，它可以用一种语言操作AST, 也可以翻译成全新的语言。在这个过程中，<br>我们可以通过 添加/删除/替换属性来操作节点。并基于它创造一个新的AST。例如可以把wx全转为swan等等，或者<br>在原先的代码基础上添加目标结果的一些特性。<br>完成上述功能，必须通过递归进行遍历每一层。由于仅仅只需要访问每一个节点就足够了，因此利用visitor就可以解决这个问题。<br>当遇到匹配类型的节点时，我们只需要调用对应visitor中的方法就可以解决问题。<br>visitor的方法可能如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var visitor = &#123;</span><br><span class=\"line\">  NumberLiteral(node, parent) &#123;&#125;,</span><br><span class=\"line\">  CallExpression(node, parent) &#123;&#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>但如果需要在离开当前节点的时候做一些操作呢？<br>我们可以更新下visitor方法，如下所示:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const visitor = &#123;</span><br><span class=\"line\">    NumberLiteral: &#123;</span><br><span class=\"line\">      enter(node, parent) &#123;</span><br><span class=\"line\">        parent._context.push(&#123;</span><br><span class=\"line\">          type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">          value: node.value</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      exit(node, parent) &#123;</span><br><span class=\"line\">         // do something</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    StringLiteral: &#123;</span><br><span class=\"line\">      enter(node, parent) &#123;</span><br><span class=\"line\">        parent._context.push(&#123;</span><br><span class=\"line\">          type: &apos;StringLiteral&apos;,</span><br><span class=\"line\">          value: node.value</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>有了visitor对象，就可以在traverseNode（转换节点）的过程中, 对特定的节点进行转换操作，并做一些其他事情。<br>具体流程如下：</p>\n<ul>\n<li>→ Program (enter)<ul>\n<li>→ CallExpression (enter)<ul>\n<li>→ NumberLiteral (enter)</li>\n<li>← NumberLiteral (exit)</li>\n<li>→ CallExpression (enter)<ul>\n<li>→ NumberLiteral (enter)</li>\n<li>← NumberLiteral (exit)</li>\n<li>→ NumberLiteral (enter)</li>\n<li>← NumberLiteral (exit)</li>\n</ul>\n</li>\n<li>← CallExpression (exit)</li>\n</ul>\n</li>\n<li>← CallExpression (exit)</li>\n</ul>\n</li>\n<li>← Program (exit)</li>\n</ul>\n<h3 id=\"4-代码生成\"><a href=\"#4-代码生成\" class=\"headerlink\" title=\"4. 代码生成\"></a>4. 代码生成</h3><p>代码生成器应当知道如何打印AST的所有不同类型的节点，并且递归调用来打印嵌套节点，直到生成最终代码。</p>\n<h2 id=\"制作一个babel插件\"><a href=\"#制作一个babel插件\" class=\"headerlink\" title=\"制作一个babel插件\"></a>制作一个babel插件</h2><p>由于小程序开发比较多，有接触百度小程序和微信小程序等等，肯定会面临一个转换的问题，如 wx =&gt; swan 等。<br>这里就尝试做一个类似的插件。</p>\n<h3 id=\"1-创建基础结构（插件的基础）\"><a href=\"#1-创建基础结构（插件的基础）\" class=\"headerlink\" title=\"1. 创建基础结构（插件的基础）\"></a>1. 创建基础结构（插件的基础）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const babel = require(&apos;babel-core&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输入的文法</span><br><span class=\"line\">const input = `</span><br><span class=\"line\">function test() &#123;</span><br><span class=\"line\">  wx.showModal(&#123;</span><br><span class=\"line\">    title: &quot;modal&quot;,</span><br><span class=\"line\">    content: &apos;content&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">`</span><br><span class=\"line\"></span><br><span class=\"line\">// 需要做的插件功能</span><br><span class=\"line\">const plugin = (&#123;types: t&#125;) =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    visitor: &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 利用插件</span><br><span class=\"line\">const res = babel.transform(input, &#123;</span><br><span class=\"line\">  plugins: [plugin]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(res.code)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用https-astexplorer-net-进行AST分析。\"><a href=\"#2-使用https-astexplorer-net-进行AST分析。\" class=\"headerlink\" title=\"2. 使用https://astexplorer.net/ 进行AST分析。\"></a>2. 使用<a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener\">https://astexplorer.net/</a> 进行AST分析。</h3><p>如图所示：<br><img src=\"https://img4.tuhu.org/PeccancyCheXingYi/Fi-8bDBlO2XddekCkb9NTbL1eXv3_w649_h800.jpeg@100Q.jpg\" alt=\"\"></p>\n<p>由于需要做的是 wx =&gt; swan, 因此要找到wx这个文法对应的表达式，这里找到的是 “callee： MemberExpression”， 然后修改plugin代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const plugin = (&#123;types: t&#125;) =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    visitor: &#123;</span><br><span class=\"line\">      MemberExpression: &#123;</span><br><span class=\"line\">        enter(path, state) &#123;</span><br><span class=\"line\">          const node = path.node</span><br><span class=\"line\">          const object = node.object</span><br><span class=\"line\">          if (t.isMemberExpression(node) &amp;&amp; t.isIdentifier(object, &#123;name: &apos;wx&apos;&#125;)) &#123;</span><br><span class=\"line\">            path.traverse(&#123;</span><br><span class=\"line\">              Identifier(path) &#123;</span><br><span class=\"line\">                if (path.node.name === &apos;wx&apos;) &#123;</span><br><span class=\"line\">                  path.node.name = &apos;swan&apos;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中 types 其实就是 babel.types这个库，在这里作为plugin会在回调的时候会把babel作为参数传入, 然后进行解构。<br>可使用 types 来生成一个AST节点，或者来做浅层判断<br>使用types.numericLiteral() 来生成一个数字类型的节点。<br>使用types.isNumericLiteral() 来判断当前节点的name值是否为数字。</p>\n<p>在visitor中，path就是指当前访问者访问的节点。该对象下有许多属性和方法，例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">── 属性      </span><br><span class=\"line\">  - node   当前节点</span><br><span class=\"line\">  - parent  父节点</span><br><span class=\"line\">  - parentPath 父path</span><br><span class=\"line\">  - scope   作用域</span><br><span class=\"line\">  - context  上下文</span><br><span class=\"line\">  - ...</span><br><span class=\"line\">── 方法</span><br><span class=\"line\">  - get   当前节点</span><br><span class=\"line\">  - findParent  向父节点搜寻节点</span><br><span class=\"line\">  - getSibling 获取兄弟节点</span><br><span class=\"line\">  - replaceWith  用AST节点替换该节点</span><br><span class=\"line\">  - replaceWithSourceString  用资源字符串来代替这个节点，会在内部自动生成一个节点</span><br><span class=\"line\">  - replaceWithMultiple 用多个AST节点替换该节点</span><br><span class=\"line\">  - insertBefore  在节点前插入节点</span><br><span class=\"line\">  - insertAfter 在节点后插入节点</span><br><span class=\"line\">  - remove   删除节点</span><br><span class=\"line\">  - ...</span><br></pre></td></tr></table></figure></p>\n<p>具体的可以查看babel-traverse</p>\n<h3 id=\"3-执行插件\"><a href=\"#3-执行插件\" class=\"headerlink\" title=\"3.执行插件\"></a>3.执行插件</h3><p>结果为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test() &#123;</span><br><span class=\"line\">  swan.showModal(&#123;</span><br><span class=\"line\">    title: &quot;modal&quot;,</span><br><span class=\"line\">    content: &apos;content&apos;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>具体代码：<br><a href=\"https://github.com/SalterYu/MyBlog/blob/master/simple-bundler/babel-use/wx2swan.js\" target=\"_blank\" rel=\"noopener\">wx2swan.js</a><br><a href=\"https://github.com/SalterYu/MyBlog/tree/master/simple-compiler\" target=\"_blank\" rel=\"noopener\">简易编译器</a></p>\n<h3 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h3><p>分享几篇文章：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5c21b584e51d4548ac6f6c99\" target=\"_blank\" rel=\"noopener\">Babel的深入了解</a> </li>\n<li><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-writing-your-first-babel-plugin\" target=\"_blank\" rel=\"noopener\">Babel插件手册</a> </li>\n</ul>"},{"title":"谈谈软件熵","date":"2020-04-22T03:10:22.455Z","_content":"\n## 谈谈软件熵\n\n#### 何为软件熵\n   软件熵（Software entropy）是指软件的无序程度。软件熵可用来说明软件在经过不断修改后，无序程度提高的现象。这是不可避免的情况。\n\n#### 为什么会产生\n1. 最先接手项目的人因为一时偷懒图方便增加代码无序性。\n2. 在无序性项目中的各种迭代，以至于有太多的逻辑判断和冗余代码。\n3. 当时开发的人的习惯或者心理状况。\n   例如: 很多元素可以崔进软件腐烂，其中最重要的一个似乎是开发项目时的心理（或文化），即使你的团队只有你一个人，你开发项目时的心理也可能是非常微妙的事情。尽管制定了最好的计划，拥有最好的开发者，项目在其生命周期中仍可能遭遇毁灭和衰败，而另一些项目，尽管遇到巨大的困难和接连而来的挫折，却成功的击败自然的无序倾向，设法取得相当好的结果。（这段内容来自互联网）\n4. 有人在一段风格整洁的项目中，放了一个污点，然后后人由于不了解原因则进行迭代将这个污点越扩越大。\n5. 不同人的开发习惯。\n\n#### 会产生什么后果\n1. 代码越来越复杂。\n2. 项目越来越难维护。\n3. 改动一处就出现奇奇怪怪的bug。明明自己没改过这地方。\n4. 会给之后的迭代造成不必要的麻烦。\n5. 后期开发成本逐渐上升，投入的资源也会增加。\n6. 之后维护的人心里也会发生变化。\n7. 当熵值达到一定程度会不可逆，最终只好重构。\n\n#### 如何避免\n1. 有一套良好的编码规范。\n2. 严格遵守这一套规范。（一旦有人不遵守，就会出现严重的恶化）\n3. 框架使用要恰当。\n4. 设计模式要多利用。\n5. 编码之前多考虑是否有更好的办法来解决，而不是靠复杂的逻辑判断。例如：函数式编程，封装等。\n6. 代码重构（能不重构就不重构）\n7. 在各种解决方案中做权衡。\n\n#### 总结\n我们编程的过程，实际上就是不断地向系统输入规则的过程。通过这些规则，我们将系统的运行状态限制在那些我们认为正确的状态上（即有序状态）。\n因此，避免系统出现那些不合法的、额外的状态（即混乱状态），是我们应该竭力去做的，哪怕那些状态初看起来是“无害”的。避免它，也是对我们能力的一种提升。\n","source":"_posts/software-entropy.md","raw":"---\ntitle: 谈谈软件熵\ndate: 2020年04月22日\n---\n\n## 谈谈软件熵\n\n#### 何为软件熵\n   软件熵（Software entropy）是指软件的无序程度。软件熵可用来说明软件在经过不断修改后，无序程度提高的现象。这是不可避免的情况。\n\n#### 为什么会产生\n1. 最先接手项目的人因为一时偷懒图方便增加代码无序性。\n2. 在无序性项目中的各种迭代，以至于有太多的逻辑判断和冗余代码。\n3. 当时开发的人的习惯或者心理状况。\n   例如: 很多元素可以崔进软件腐烂，其中最重要的一个似乎是开发项目时的心理（或文化），即使你的团队只有你一个人，你开发项目时的心理也可能是非常微妙的事情。尽管制定了最好的计划，拥有最好的开发者，项目在其生命周期中仍可能遭遇毁灭和衰败，而另一些项目，尽管遇到巨大的困难和接连而来的挫折，却成功的击败自然的无序倾向，设法取得相当好的结果。（这段内容来自互联网）\n4. 有人在一段风格整洁的项目中，放了一个污点，然后后人由于不了解原因则进行迭代将这个污点越扩越大。\n5. 不同人的开发习惯。\n\n#### 会产生什么后果\n1. 代码越来越复杂。\n2. 项目越来越难维护。\n3. 改动一处就出现奇奇怪怪的bug。明明自己没改过这地方。\n4. 会给之后的迭代造成不必要的麻烦。\n5. 后期开发成本逐渐上升，投入的资源也会增加。\n6. 之后维护的人心里也会发生变化。\n7. 当熵值达到一定程度会不可逆，最终只好重构。\n\n#### 如何避免\n1. 有一套良好的编码规范。\n2. 严格遵守这一套规范。（一旦有人不遵守，就会出现严重的恶化）\n3. 框架使用要恰当。\n4. 设计模式要多利用。\n5. 编码之前多考虑是否有更好的办法来解决，而不是靠复杂的逻辑判断。例如：函数式编程，封装等。\n6. 代码重构（能不重构就不重构）\n7. 在各种解决方案中做权衡。\n\n#### 总结\n我们编程的过程，实际上就是不断地向系统输入规则的过程。通过这些规则，我们将系统的运行状态限制在那些我们认为正确的状态上（即有序状态）。\n因此，避免系统出现那些不合法的、额外的状态（即混乱状态），是我们应该竭力去做的，哪怕那些状态初看起来是“无害”的。避免它，也是对我们能力的一种提升。\n","slug":"software-entropy","published":1,"updated":"2020-04-22T03:14:10.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdsjt88h0007falvmmmbladb","content":"<h2 id=\"谈谈软件熵\"><a href=\"#谈谈软件熵\" class=\"headerlink\" title=\"谈谈软件熵\"></a>谈谈软件熵</h2><h4 id=\"何为软件熵\"><a href=\"#何为软件熵\" class=\"headerlink\" title=\"何为软件熵\"></a>何为软件熵</h4><p>   软件熵（Software entropy）是指软件的无序程度。软件熵可用来说明软件在经过不断修改后，无序程度提高的现象。这是不可避免的情况。</p>\n<h4 id=\"为什么会产生\"><a href=\"#为什么会产生\" class=\"headerlink\" title=\"为什么会产生\"></a>为什么会产生</h4><ol>\n<li>最先接手项目的人因为一时偷懒图方便增加代码无序性。</li>\n<li>在无序性项目中的各种迭代，以至于有太多的逻辑判断和冗余代码。</li>\n<li>当时开发的人的习惯或者心理状况。<br>例如: 很多元素可以崔进软件腐烂，其中最重要的一个似乎是开发项目时的心理（或文化），即使你的团队只有你一个人，你开发项目时的心理也可能是非常微妙的事情。尽管制定了最好的计划，拥有最好的开发者，项目在其生命周期中仍可能遭遇毁灭和衰败，而另一些项目，尽管遇到巨大的困难和接连而来的挫折，却成功的击败自然的无序倾向，设法取得相当好的结果。（这段内容来自互联网）</li>\n<li>有人在一段风格整洁的项目中，放了一个污点，然后后人由于不了解原因则进行迭代将这个污点越扩越大。</li>\n<li>不同人的开发习惯。</li>\n</ol>\n<h4 id=\"会产生什么后果\"><a href=\"#会产生什么后果\" class=\"headerlink\" title=\"会产生什么后果\"></a>会产生什么后果</h4><ol>\n<li>代码越来越复杂。</li>\n<li>项目越来越难维护。</li>\n<li>改动一处就出现奇奇怪怪的bug。明明自己没改过这地方。</li>\n<li>会给之后的迭代造成不必要的麻烦。</li>\n<li>后期开发成本逐渐上升，投入的资源也会增加。</li>\n<li>之后维护的人心里也会发生变化。</li>\n<li>当熵值达到一定程度会不可逆，最终只好重构。</li>\n</ol>\n<h4 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h4><ol>\n<li>有一套良好的编码规范。</li>\n<li>严格遵守这一套规范。（一旦有人不遵守，就会出现严重的恶化）</li>\n<li>框架使用要恰当。</li>\n<li>设计模式要多利用。</li>\n<li>编码之前多考虑是否有更好的办法来解决，而不是靠复杂的逻辑判断。例如：函数式编程，封装等。</li>\n<li>代码重构（能不重构就不重构）</li>\n<li>在各种解决方案中做权衡。</li>\n</ol>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>我们编程的过程，实际上就是不断地向系统输入规则的过程。通过这些规则，我们将系统的运行状态限制在那些我们认为正确的状态上（即有序状态）。<br>因此，避免系统出现那些不合法的、额外的状态（即混乱状态），是我们应该竭力去做的，哪怕那些状态初看起来是“无害”的。避免它，也是对我们能力的一种提升。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"谈谈软件熵\"><a href=\"#谈谈软件熵\" class=\"headerlink\" title=\"谈谈软件熵\"></a>谈谈软件熵</h2><h4 id=\"何为软件熵\"><a href=\"#何为软件熵\" class=\"headerlink\" title=\"何为软件熵\"></a>何为软件熵</h4><p>   软件熵（Software entropy）是指软件的无序程度。软件熵可用来说明软件在经过不断修改后，无序程度提高的现象。这是不可避免的情况。</p>\n<h4 id=\"为什么会产生\"><a href=\"#为什么会产生\" class=\"headerlink\" title=\"为什么会产生\"></a>为什么会产生</h4><ol>\n<li>最先接手项目的人因为一时偷懒图方便增加代码无序性。</li>\n<li>在无序性项目中的各种迭代，以至于有太多的逻辑判断和冗余代码。</li>\n<li>当时开发的人的习惯或者心理状况。<br>例如: 很多元素可以崔进软件腐烂，其中最重要的一个似乎是开发项目时的心理（或文化），即使你的团队只有你一个人，你开发项目时的心理也可能是非常微妙的事情。尽管制定了最好的计划，拥有最好的开发者，项目在其生命周期中仍可能遭遇毁灭和衰败，而另一些项目，尽管遇到巨大的困难和接连而来的挫折，却成功的击败自然的无序倾向，设法取得相当好的结果。（这段内容来自互联网）</li>\n<li>有人在一段风格整洁的项目中，放了一个污点，然后后人由于不了解原因则进行迭代将这个污点越扩越大。</li>\n<li>不同人的开发习惯。</li>\n</ol>\n<h4 id=\"会产生什么后果\"><a href=\"#会产生什么后果\" class=\"headerlink\" title=\"会产生什么后果\"></a>会产生什么后果</h4><ol>\n<li>代码越来越复杂。</li>\n<li>项目越来越难维护。</li>\n<li>改动一处就出现奇奇怪怪的bug。明明自己没改过这地方。</li>\n<li>会给之后的迭代造成不必要的麻烦。</li>\n<li>后期开发成本逐渐上升，投入的资源也会增加。</li>\n<li>之后维护的人心里也会发生变化。</li>\n<li>当熵值达到一定程度会不可逆，最终只好重构。</li>\n</ol>\n<h4 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h4><ol>\n<li>有一套良好的编码规范。</li>\n<li>严格遵守这一套规范。（一旦有人不遵守，就会出现严重的恶化）</li>\n<li>框架使用要恰当。</li>\n<li>设计模式要多利用。</li>\n<li>编码之前多考虑是否有更好的办法来解决，而不是靠复杂的逻辑判断。例如：函数式编程，封装等。</li>\n<li>代码重构（能不重构就不重构）</li>\n<li>在各种解决方案中做权衡。</li>\n</ol>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>我们编程的过程，实际上就是不断地向系统输入规则的过程。通过这些规则，我们将系统的运行状态限制在那些我们认为正确的状态上（即有序状态）。<br>因此，避免系统出现那些不合法的、额外的状态（即混乱状态），是我们应该竭力去做的，哪怕那些状态初看起来是“无害”的。避免它，也是对我们能力的一种提升。</p>\n"},{"title":"在小程序使用面向对象的思想","date":"2020-03-25T01:50:21.266Z","_content":"\n在小程序使用面向对象的思想\n==========\n\n面向对象是啥就不说了，这里主要讲如何在小程序中使用，以及为何我习惯使用这种思想。\n\n### 案例\n比如，你有一个需求或者接到了一个业务线，这个业务线可能需要一直迭代，若每次改动都在小程序的视图js中改动，这会让视图代码很耦合。\n就好比现在的保养下单，在不了解业务的情况下，当改动一处功能，你以为完成了并且没有bug了，但说不准就影响了其他地方，直到测试的时候\n才出现。甚至了解业务的人，时间长了也会遗忘。现在的情况大多都是面向流程，毕竟这是js，不是其他后端语言。\n#### 面向过程\n具体面向流程的代码栗子：\n```vue\nconst delay = time => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve();\n    }, time);\n  });\n};\n\nconst getActivityId = () => {\n  return delay(2000).then(_ => ({ couponItem: '1234' }));\n};\nconst getProducts = (b) => {\n  return delay(3000).then(_ => ([{ id: 1, value: 1 }, { id: 2, value: 2 }]));\n};\n\nconst start = () => {\n  pro1().then(res1 => {\n    console.log('pro1');\n    pro2().then(res2 => {\n      console.log('pro2');\n    });\n  });\n};\n\nlet obj = {\n  data: {\n    couponItem: null,\n    viewData: []\n  },\n  onLoad() {\n    return this.getData();\n  },\n  getData() {\n    // 获取两次数据\n    return getActivityId().then(res1 => {\n      this.data.couponItem = res1.couponItem\n      return getProduct().then(res2 => {\n        this.res2 = res2\n        this.data.viewData = res2.map(item => {\n          return {\n            actId: this.data.couponItem,\n            ...item\n          }\n        })\n        // 设置数据进行渲染\n        return this.data.viewData\n      });\n    });\n  },\n  // 模拟用户点击操作, 用户点击，将这个viewData.data1变成了3\n  // 比如更改优惠券的选择，或者支付方式\n  mockTap() {\n    // 不使用优惠券，置为0000\n    this.data.couponItem = '0000'\n  },\n  postData() {\n    // 提交数据需要\n    // 提交的数据需要viewData的数据，因为用户不适用优惠券，\n    // 导致要重新执行一下初始化viewData的方法，\n    // 因为所有的项目都不需要优惠券才对\n    this.data.viewData = this.res2.map(item => {\n      return {\n        actId: '0000',\n        ...item\n      }\n    })\n    console.log(this.data.viewData);\n    // do post\n  }\n};\n\nobj.onLoad().then(res => {\n  console.log('res', res);\n  obj.mockTap()\n  obj.postData()\n})\n\n```\n上述代码是面向流程，主要是面向用户的使用角度。\n1. 用户打开小程序，需要页面数据，则初始化数据，展示给用户。\n2. 用户修改了优惠券信息。代码更改优惠券信息。\n3. 用户下单，则获取数据，进行提交。\n\n这就产生了一个问题，之后的人要维护代码，有需求说增加支付方式，因此初始化的时候也要加一个支付方式，提交的时候也要加支付方式\n这就要改两个地方。之后越改越多越改越难改。总结就是：代码过于耦合，维护起来困难。\n\n#### 面向对象\n如果换成面向对象的方式。就变成了这样几个步骤。\n1. 视图页面对象，也就是上面代码的obj。视图对象需要获取数据的功能，渲染数据的功能，处理数据的功能，提交数据功能。\n2. 数据对象，也就是上方的viewData，在上面的业务逻辑中需要初始化功能，更换优惠券id功能，\n   而viewData有个属性是一个Array<Product>.\n3. Product对象，初始化功能\n把代码处理下：\n```vue\nclass Product {\n  constructor(product, couponItem) {\n    this.id = product.id\n    this.value = product.value\n    this.couponItem = couponItem\n  }\n}\n\nclass ViewData {\n  constructor(couponItem, products) {\n    this.couponItem = couponItem\n    this._products = products\n    this._initProduct()\n  }\n\n  changeCouponItem(couponItem) {\n    this.couponItem = couponItem\n  }\n\n  _initProduct() {\n    this.products = this._products.map(item => new Product(item, this.couponItem))\n  }\n\n  getPostData() {\n    return this._products.map(item => new Product(item, this.couponItem))\n  }\n}\n\n// 把async await的方法做优化\nfunction to(\n  promise,\n  errorExt\n) {\n  return promise\n    .then((data) => [null, data])\n    .catch(err => {\n      if (errorExt) {\n        Object.assign(err, errorExt);\n      }\n      return [err, undefined];\n    });\n}\n\nlet obj2 = {\n  data: {\n    viewData: {}\n  },\n  onLoad() {\n    return this._init();\n  },\n  async _init() {\n    // 获取优惠券数据\n    // 这里用了一个方法将async await的内部错误作为err返回\n    const [err1, couponItem] = await to(getActivityId());\n    if (err1) {\n      return '没有数据'\n    }\n    const [err2, products] = await to(getProducts())\n    if (err2) {\n      return '没有产品数据'\n    }\n    this.data.viewData = new ViewData(couponItem.couponItem, products)\n    // 做渲染\n  },\n  // 模拟用户点击操作, 用户点击，将这个viewData.data1变成了3\n  // 比如更改优惠券的选择，或者支付方式\n  mockTap() {\n    // 不使用优惠券，置为0000\n    this.data.viewData.changeCouponItem('0000');\n  },\n  postData() {\n    // 提交数据需要\n    // 提交的数据需要viewData的数据，因为用户不适用优惠券，导致要重新执行一下初始化viewData的方法，\n    // 因为所有的项目都不需要优惠券才对\n    console.log(this.data.viewData.getPostData());\n    // do post\n  }\n};\n\nobj2.onLoad().then(_ => {\n  console.log(obj2.data.viewData);\n  obj2.mockTap()\n  obj2.postData()\n})\n```\n代码就变的比较简洁，且维护的时候容易知道哪一块功能做啥的，也会告诉别人该怎么对代码进行拓展。这样的做法进行了解耦，也增加了可扩展性。\n但坏处就是做之前要考虑好有哪些对象，需要进行声明。\n\n#### 总结\ntypescript就很好的支持了面向对象开发，有抽象，继承，多态，封装。就是为面向对象进行服务。如果类型声明的好，也可以直接靠ide进行相应对象内部的属性。\n\n现在小程序中有太多面向过程开发，这有太多是小程序自身的框架原因，诱导使用面向过程。面向过程关心的是先干什么，再干什么，如onLoad的时候做什么，onShow的时候做什么，\n一步一步往下走，而过程多了，代码就乱了。\n而面向对象，就是先根据业务需求，有哪些模型类，这个类（业务）要干什么，有什么属性，以及进行的状态，外部使用通过实例化建立联系，当需要完成什么功能，则可以通过\n执行对象的方法后返回结果，视图层再进行处理这个结果，这样也保护了数据的完整性，具体可以了解函数式编程。\n","source":"_posts/object-oriented-for-miniapp.md","raw":"---\ntitle: 在小程序使用面向对象的思想\ndate: 2020年03月25日\n---\n\n在小程序使用面向对象的思想\n==========\n\n面向对象是啥就不说了，这里主要讲如何在小程序中使用，以及为何我习惯使用这种思想。\n\n### 案例\n比如，你有一个需求或者接到了一个业务线，这个业务线可能需要一直迭代，若每次改动都在小程序的视图js中改动，这会让视图代码很耦合。\n就好比现在的保养下单，在不了解业务的情况下，当改动一处功能，你以为完成了并且没有bug了，但说不准就影响了其他地方，直到测试的时候\n才出现。甚至了解业务的人，时间长了也会遗忘。现在的情况大多都是面向流程，毕竟这是js，不是其他后端语言。\n#### 面向过程\n具体面向流程的代码栗子：\n```vue\nconst delay = time => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve();\n    }, time);\n  });\n};\n\nconst getActivityId = () => {\n  return delay(2000).then(_ => ({ couponItem: '1234' }));\n};\nconst getProducts = (b) => {\n  return delay(3000).then(_ => ([{ id: 1, value: 1 }, { id: 2, value: 2 }]));\n};\n\nconst start = () => {\n  pro1().then(res1 => {\n    console.log('pro1');\n    pro2().then(res2 => {\n      console.log('pro2');\n    });\n  });\n};\n\nlet obj = {\n  data: {\n    couponItem: null,\n    viewData: []\n  },\n  onLoad() {\n    return this.getData();\n  },\n  getData() {\n    // 获取两次数据\n    return getActivityId().then(res1 => {\n      this.data.couponItem = res1.couponItem\n      return getProduct().then(res2 => {\n        this.res2 = res2\n        this.data.viewData = res2.map(item => {\n          return {\n            actId: this.data.couponItem,\n            ...item\n          }\n        })\n        // 设置数据进行渲染\n        return this.data.viewData\n      });\n    });\n  },\n  // 模拟用户点击操作, 用户点击，将这个viewData.data1变成了3\n  // 比如更改优惠券的选择，或者支付方式\n  mockTap() {\n    // 不使用优惠券，置为0000\n    this.data.couponItem = '0000'\n  },\n  postData() {\n    // 提交数据需要\n    // 提交的数据需要viewData的数据，因为用户不适用优惠券，\n    // 导致要重新执行一下初始化viewData的方法，\n    // 因为所有的项目都不需要优惠券才对\n    this.data.viewData = this.res2.map(item => {\n      return {\n        actId: '0000',\n        ...item\n      }\n    })\n    console.log(this.data.viewData);\n    // do post\n  }\n};\n\nobj.onLoad().then(res => {\n  console.log('res', res);\n  obj.mockTap()\n  obj.postData()\n})\n\n```\n上述代码是面向流程，主要是面向用户的使用角度。\n1. 用户打开小程序，需要页面数据，则初始化数据，展示给用户。\n2. 用户修改了优惠券信息。代码更改优惠券信息。\n3. 用户下单，则获取数据，进行提交。\n\n这就产生了一个问题，之后的人要维护代码，有需求说增加支付方式，因此初始化的时候也要加一个支付方式，提交的时候也要加支付方式\n这就要改两个地方。之后越改越多越改越难改。总结就是：代码过于耦合，维护起来困难。\n\n#### 面向对象\n如果换成面向对象的方式。就变成了这样几个步骤。\n1. 视图页面对象，也就是上面代码的obj。视图对象需要获取数据的功能，渲染数据的功能，处理数据的功能，提交数据功能。\n2. 数据对象，也就是上方的viewData，在上面的业务逻辑中需要初始化功能，更换优惠券id功能，\n   而viewData有个属性是一个Array<Product>.\n3. Product对象，初始化功能\n把代码处理下：\n```vue\nclass Product {\n  constructor(product, couponItem) {\n    this.id = product.id\n    this.value = product.value\n    this.couponItem = couponItem\n  }\n}\n\nclass ViewData {\n  constructor(couponItem, products) {\n    this.couponItem = couponItem\n    this._products = products\n    this._initProduct()\n  }\n\n  changeCouponItem(couponItem) {\n    this.couponItem = couponItem\n  }\n\n  _initProduct() {\n    this.products = this._products.map(item => new Product(item, this.couponItem))\n  }\n\n  getPostData() {\n    return this._products.map(item => new Product(item, this.couponItem))\n  }\n}\n\n// 把async await的方法做优化\nfunction to(\n  promise,\n  errorExt\n) {\n  return promise\n    .then((data) => [null, data])\n    .catch(err => {\n      if (errorExt) {\n        Object.assign(err, errorExt);\n      }\n      return [err, undefined];\n    });\n}\n\nlet obj2 = {\n  data: {\n    viewData: {}\n  },\n  onLoad() {\n    return this._init();\n  },\n  async _init() {\n    // 获取优惠券数据\n    // 这里用了一个方法将async await的内部错误作为err返回\n    const [err1, couponItem] = await to(getActivityId());\n    if (err1) {\n      return '没有数据'\n    }\n    const [err2, products] = await to(getProducts())\n    if (err2) {\n      return '没有产品数据'\n    }\n    this.data.viewData = new ViewData(couponItem.couponItem, products)\n    // 做渲染\n  },\n  // 模拟用户点击操作, 用户点击，将这个viewData.data1变成了3\n  // 比如更改优惠券的选择，或者支付方式\n  mockTap() {\n    // 不使用优惠券，置为0000\n    this.data.viewData.changeCouponItem('0000');\n  },\n  postData() {\n    // 提交数据需要\n    // 提交的数据需要viewData的数据，因为用户不适用优惠券，导致要重新执行一下初始化viewData的方法，\n    // 因为所有的项目都不需要优惠券才对\n    console.log(this.data.viewData.getPostData());\n    // do post\n  }\n};\n\nobj2.onLoad().then(_ => {\n  console.log(obj2.data.viewData);\n  obj2.mockTap()\n  obj2.postData()\n})\n```\n代码就变的比较简洁，且维护的时候容易知道哪一块功能做啥的，也会告诉别人该怎么对代码进行拓展。这样的做法进行了解耦，也增加了可扩展性。\n但坏处就是做之前要考虑好有哪些对象，需要进行声明。\n\n#### 总结\ntypescript就很好的支持了面向对象开发，有抽象，继承，多态，封装。就是为面向对象进行服务。如果类型声明的好，也可以直接靠ide进行相应对象内部的属性。\n\n现在小程序中有太多面向过程开发，这有太多是小程序自身的框架原因，诱导使用面向过程。面向过程关心的是先干什么，再干什么，如onLoad的时候做什么，onShow的时候做什么，\n一步一步往下走，而过程多了，代码就乱了。\n而面向对象，就是先根据业务需求，有哪些模型类，这个类（业务）要干什么，有什么属性，以及进行的状态，外部使用通过实例化建立联系，当需要完成什么功能，则可以通过\n执行对象的方法后返回结果，视图层再进行处理这个结果，这样也保护了数据的完整性，具体可以了解函数式编程。\n","slug":"object-oriented-for-miniapp","published":1,"updated":"2020-04-22T02:16:24.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdsjt88i0008falvfdgqax87","content":"<h1 id=\"在小程序使用面向对象的思想\"><a href=\"#在小程序使用面向对象的思想\" class=\"headerlink\" title=\"在小程序使用面向对象的思想\"></a>在小程序使用面向对象的思想</h1><p>面向对象是啥就不说了，这里主要讲如何在小程序中使用，以及为何我习惯使用这种思想。</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><p>比如，你有一个需求或者接到了一个业务线，这个业务线可能需要一直迭代，若每次改动都在小程序的视图js中改动，这会让视图代码很耦合。<br>就好比现在的保养下单，在不了解业务的情况下，当改动一处功能，你以为完成了并且没有bug了，但说不准就影响了其他地方，直到测试的时候<br>才出现。甚至了解业务的人，时间长了也会遗忘。现在的情况大多都是面向流程，毕竟这是js，不是其他后端语言。</p>\n<h4 id=\"面向过程\"><a href=\"#面向过程\" class=\"headerlink\" title=\"面向过程\"></a>面向过程</h4><p>具体面向流程的代码栗子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const delay = time =&gt; &#123;</span><br><span class=\"line\">  return new Promise(resolve =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">    &#125;, time);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const getActivityId = () =&gt; &#123;</span><br><span class=\"line\">  return delay(2000).then(_ =&gt; (&#123; couponItem: &apos;1234&apos; &#125;));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const getProducts = (b) =&gt; &#123;</span><br><span class=\"line\">  return delay(3000).then(_ =&gt; ([&#123; id: 1, value: 1 &#125;, &#123; id: 2, value: 2 &#125;]));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const start = () =&gt; &#123;</span><br><span class=\"line\">  pro1().then(res1 =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;pro1&apos;);</span><br><span class=\"line\">    pro2().then(res2 =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;pro2&apos;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    couponItem: null,</span><br><span class=\"line\">    viewData: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onLoad() &#123;</span><br><span class=\"line\">    return this.getData();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getData() &#123;</span><br><span class=\"line\">    // 获取两次数据</span><br><span class=\"line\">    return getActivityId().then(res1 =&gt; &#123;</span><br><span class=\"line\">      this.data.couponItem = res1.couponItem</span><br><span class=\"line\">      return getProduct().then(res2 =&gt; &#123;</span><br><span class=\"line\">        this.res2 = res2</span><br><span class=\"line\">        this.data.viewData = res2.map(item =&gt; &#123;</span><br><span class=\"line\">          return &#123;</span><br><span class=\"line\">            actId: this.data.couponItem,</span><br><span class=\"line\">            ...item</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        // 设置数据进行渲染</span><br><span class=\"line\">        return this.data.viewData</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 模拟用户点击操作, 用户点击，将这个viewData.data1变成了3</span><br><span class=\"line\">  // 比如更改优惠券的选择，或者支付方式</span><br><span class=\"line\">  mockTap() &#123;</span><br><span class=\"line\">    // 不使用优惠券，置为0000</span><br><span class=\"line\">    this.data.couponItem = &apos;0000&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postData() &#123;</span><br><span class=\"line\">    // 提交数据需要</span><br><span class=\"line\">    // 提交的数据需要viewData的数据，因为用户不适用优惠券，</span><br><span class=\"line\">    // 导致要重新执行一下初始化viewData的方法，</span><br><span class=\"line\">    // 因为所有的项目都不需要优惠券才对</span><br><span class=\"line\">    this.data.viewData = this.res2.map(item =&gt; &#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        actId: &apos;0000&apos;,</span><br><span class=\"line\">        ...item</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    console.log(this.data.viewData);</span><br><span class=\"line\">    // do post</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.onLoad().then(res =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;res&apos;, res);</span><br><span class=\"line\">  obj.mockTap()</span><br><span class=\"line\">  obj.postData()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上述代码是面向流程，主要是面向用户的使用角度。</p>\n<ol>\n<li>用户打开小程序，需要页面数据，则初始化数据，展示给用户。</li>\n<li>用户修改了优惠券信息。代码更改优惠券信息。</li>\n<li>用户下单，则获取数据，进行提交。</li>\n</ol>\n<p>这就产生了一个问题，之后的人要维护代码，有需求说增加支付方式，因此初始化的时候也要加一个支付方式，提交的时候也要加支付方式<br>这就要改两个地方。之后越改越多越改越难改。总结就是：代码过于耦合，维护起来困难。</p>\n<h4 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h4><p>如果换成面向对象的方式。就变成了这样几个步骤。</p>\n<ol>\n<li>视图页面对象，也就是上面代码的obj。视图对象需要获取数据的功能，渲染数据的功能，处理数据的功能，提交数据功能。</li>\n<li>数据对象，也就是上方的viewData，在上面的业务逻辑中需要初始化功能，更换优惠券id功能，<br>而viewData有个属性是一个Array<product>.</product></li>\n<li>Product对象，初始化功能<br>把代码处理下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Product &#123;</span><br><span class=\"line\">  constructor(product, couponItem) &#123;</span><br><span class=\"line\">    this.id = product.id</span><br><span class=\"line\">    this.value = product.value</span><br><span class=\"line\">    this.couponItem = couponItem</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewData &#123;</span><br><span class=\"line\">  constructor(couponItem, products) &#123;</span><br><span class=\"line\">    this.couponItem = couponItem</span><br><span class=\"line\">    this._products = products</span><br><span class=\"line\">    this._initProduct()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  changeCouponItem(couponItem) &#123;</span><br><span class=\"line\">    this.couponItem = couponItem</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _initProduct() &#123;</span><br><span class=\"line\">    this.products = this._products.map(item =&gt; new Product(item, this.couponItem))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPostData() &#123;</span><br><span class=\"line\">    return this._products.map(item =&gt; new Product(item, this.couponItem))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把async await的方法做优化</span><br><span class=\"line\">function to(</span><br><span class=\"line\">  promise,</span><br><span class=\"line\">  errorExt</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  return promise</span><br><span class=\"line\">    .then((data) =&gt; [null, data])</span><br><span class=\"line\">    .catch(err =&gt; &#123;</span><br><span class=\"line\">      if (errorExt) &#123;</span><br><span class=\"line\">        Object.assign(err, errorExt);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return [err, undefined];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj2 = &#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    viewData: &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onLoad() &#123;</span><br><span class=\"line\">    return this._init();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  async _init() &#123;</span><br><span class=\"line\">    // 获取优惠券数据</span><br><span class=\"line\">    // 这里用了一个方法将async await的内部错误作为err返回</span><br><span class=\"line\">    const [err1, couponItem] = await to(getActivityId());</span><br><span class=\"line\">    if (err1) &#123;</span><br><span class=\"line\">      return &apos;没有数据&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const [err2, products] = await to(getProducts())</span><br><span class=\"line\">    if (err2) &#123;</span><br><span class=\"line\">      return &apos;没有产品数据&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.data.viewData = new ViewData(couponItem.couponItem, products)</span><br><span class=\"line\">    // 做渲染</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 模拟用户点击操作, 用户点击，将这个viewData.data1变成了3</span><br><span class=\"line\">  // 比如更改优惠券的选择，或者支付方式</span><br><span class=\"line\">  mockTap() &#123;</span><br><span class=\"line\">    // 不使用优惠券，置为0000</span><br><span class=\"line\">    this.data.viewData.changeCouponItem(&apos;0000&apos;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postData() &#123;</span><br><span class=\"line\">    // 提交数据需要</span><br><span class=\"line\">    // 提交的数据需要viewData的数据，因为用户不适用优惠券，导致要重新执行一下初始化viewData的方法，</span><br><span class=\"line\">    // 因为所有的项目都不需要优惠券才对</span><br><span class=\"line\">    console.log(this.data.viewData.getPostData());</span><br><span class=\"line\">    // do post</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj2.onLoad().then(_ =&gt; &#123;</span><br><span class=\"line\">  console.log(obj2.data.viewData);</span><br><span class=\"line\">  obj2.mockTap()</span><br><span class=\"line\">  obj2.postData()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>代码就变的比较简洁，且维护的时候容易知道哪一块功能做啥的，也会告诉别人该怎么对代码进行拓展。这样的做法进行了解耦，也增加了可扩展性。<br>但坏处就是做之前要考虑好有哪些对象，需要进行声明。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>typescript就很好的支持了面向对象开发，有抽象，继承，多态，封装。就是为面向对象进行服务。如果类型声明的好，也可以直接靠ide进行相应对象内部的属性。</p>\n<p>现在小程序中有太多面向过程开发，这有太多是小程序自身的框架原因，诱导使用面向过程。面向过程关心的是先干什么，再干什么，如onLoad的时候做什么，onShow的时候做什么，<br>一步一步往下走，而过程多了，代码就乱了。<br>而面向对象，就是先根据业务需求，有哪些模型类，这个类（业务）要干什么，有什么属性，以及进行的状态，外部使用通过实例化建立联系，当需要完成什么功能，则可以通过<br>执行对象的方法后返回结果，视图层再进行处理这个结果，这样也保护了数据的完整性，具体可以了解函数式编程。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"在小程序使用面向对象的思想\"><a href=\"#在小程序使用面向对象的思想\" class=\"headerlink\" title=\"在小程序使用面向对象的思想\"></a>在小程序使用面向对象的思想</h1><p>面向对象是啥就不说了，这里主要讲如何在小程序中使用，以及为何我习惯使用这种思想。</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><p>比如，你有一个需求或者接到了一个业务线，这个业务线可能需要一直迭代，若每次改动都在小程序的视图js中改动，这会让视图代码很耦合。<br>就好比现在的保养下单，在不了解业务的情况下，当改动一处功能，你以为完成了并且没有bug了，但说不准就影响了其他地方，直到测试的时候<br>才出现。甚至了解业务的人，时间长了也会遗忘。现在的情况大多都是面向流程，毕竟这是js，不是其他后端语言。</p>\n<h4 id=\"面向过程\"><a href=\"#面向过程\" class=\"headerlink\" title=\"面向过程\"></a>面向过程</h4><p>具体面向流程的代码栗子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const delay = time =&gt; &#123;</span><br><span class=\"line\">  return new Promise(resolve =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">    &#125;, time);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const getActivityId = () =&gt; &#123;</span><br><span class=\"line\">  return delay(2000).then(_ =&gt; (&#123; couponItem: &apos;1234&apos; &#125;));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const getProducts = (b) =&gt; &#123;</span><br><span class=\"line\">  return delay(3000).then(_ =&gt; ([&#123; id: 1, value: 1 &#125;, &#123; id: 2, value: 2 &#125;]));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const start = () =&gt; &#123;</span><br><span class=\"line\">  pro1().then(res1 =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;pro1&apos;);</span><br><span class=\"line\">    pro2().then(res2 =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;pro2&apos;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    couponItem: null,</span><br><span class=\"line\">    viewData: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onLoad() &#123;</span><br><span class=\"line\">    return this.getData();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getData() &#123;</span><br><span class=\"line\">    // 获取两次数据</span><br><span class=\"line\">    return getActivityId().then(res1 =&gt; &#123;</span><br><span class=\"line\">      this.data.couponItem = res1.couponItem</span><br><span class=\"line\">      return getProduct().then(res2 =&gt; &#123;</span><br><span class=\"line\">        this.res2 = res2</span><br><span class=\"line\">        this.data.viewData = res2.map(item =&gt; &#123;</span><br><span class=\"line\">          return &#123;</span><br><span class=\"line\">            actId: this.data.couponItem,</span><br><span class=\"line\">            ...item</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        // 设置数据进行渲染</span><br><span class=\"line\">        return this.data.viewData</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 模拟用户点击操作, 用户点击，将这个viewData.data1变成了3</span><br><span class=\"line\">  // 比如更改优惠券的选择，或者支付方式</span><br><span class=\"line\">  mockTap() &#123;</span><br><span class=\"line\">    // 不使用优惠券，置为0000</span><br><span class=\"line\">    this.data.couponItem = &apos;0000&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postData() &#123;</span><br><span class=\"line\">    // 提交数据需要</span><br><span class=\"line\">    // 提交的数据需要viewData的数据，因为用户不适用优惠券，</span><br><span class=\"line\">    // 导致要重新执行一下初始化viewData的方法，</span><br><span class=\"line\">    // 因为所有的项目都不需要优惠券才对</span><br><span class=\"line\">    this.data.viewData = this.res2.map(item =&gt; &#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        actId: &apos;0000&apos;,</span><br><span class=\"line\">        ...item</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    console.log(this.data.viewData);</span><br><span class=\"line\">    // do post</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.onLoad().then(res =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;res&apos;, res);</span><br><span class=\"line\">  obj.mockTap()</span><br><span class=\"line\">  obj.postData()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上述代码是面向流程，主要是面向用户的使用角度。</p>\n<ol>\n<li>用户打开小程序，需要页面数据，则初始化数据，展示给用户。</li>\n<li>用户修改了优惠券信息。代码更改优惠券信息。</li>\n<li>用户下单，则获取数据，进行提交。</li>\n</ol>\n<p>这就产生了一个问题，之后的人要维护代码，有需求说增加支付方式，因此初始化的时候也要加一个支付方式，提交的时候也要加支付方式<br>这就要改两个地方。之后越改越多越改越难改。总结就是：代码过于耦合，维护起来困难。</p>\n<h4 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h4><p>如果换成面向对象的方式。就变成了这样几个步骤。</p>\n<ol>\n<li>视图页面对象，也就是上面代码的obj。视图对象需要获取数据的功能，渲染数据的功能，处理数据的功能，提交数据功能。</li>\n<li>数据对象，也就是上方的viewData，在上面的业务逻辑中需要初始化功能，更换优惠券id功能，<br>而viewData有个属性是一个Array<product>.</product></li>\n<li>Product对象，初始化功能<br>把代码处理下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Product &#123;</span><br><span class=\"line\">  constructor(product, couponItem) &#123;</span><br><span class=\"line\">    this.id = product.id</span><br><span class=\"line\">    this.value = product.value</span><br><span class=\"line\">    this.couponItem = couponItem</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewData &#123;</span><br><span class=\"line\">  constructor(couponItem, products) &#123;</span><br><span class=\"line\">    this.couponItem = couponItem</span><br><span class=\"line\">    this._products = products</span><br><span class=\"line\">    this._initProduct()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  changeCouponItem(couponItem) &#123;</span><br><span class=\"line\">    this.couponItem = couponItem</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _initProduct() &#123;</span><br><span class=\"line\">    this.products = this._products.map(item =&gt; new Product(item, this.couponItem))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPostData() &#123;</span><br><span class=\"line\">    return this._products.map(item =&gt; new Product(item, this.couponItem))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把async await的方法做优化</span><br><span class=\"line\">function to(</span><br><span class=\"line\">  promise,</span><br><span class=\"line\">  errorExt</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  return promise</span><br><span class=\"line\">    .then((data) =&gt; [null, data])</span><br><span class=\"line\">    .catch(err =&gt; &#123;</span><br><span class=\"line\">      if (errorExt) &#123;</span><br><span class=\"line\">        Object.assign(err, errorExt);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return [err, undefined];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj2 = &#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    viewData: &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onLoad() &#123;</span><br><span class=\"line\">    return this._init();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  async _init() &#123;</span><br><span class=\"line\">    // 获取优惠券数据</span><br><span class=\"line\">    // 这里用了一个方法将async await的内部错误作为err返回</span><br><span class=\"line\">    const [err1, couponItem] = await to(getActivityId());</span><br><span class=\"line\">    if (err1) &#123;</span><br><span class=\"line\">      return &apos;没有数据&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const [err2, products] = await to(getProducts())</span><br><span class=\"line\">    if (err2) &#123;</span><br><span class=\"line\">      return &apos;没有产品数据&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.data.viewData = new ViewData(couponItem.couponItem, products)</span><br><span class=\"line\">    // 做渲染</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 模拟用户点击操作, 用户点击，将这个viewData.data1变成了3</span><br><span class=\"line\">  // 比如更改优惠券的选择，或者支付方式</span><br><span class=\"line\">  mockTap() &#123;</span><br><span class=\"line\">    // 不使用优惠券，置为0000</span><br><span class=\"line\">    this.data.viewData.changeCouponItem(&apos;0000&apos;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postData() &#123;</span><br><span class=\"line\">    // 提交数据需要</span><br><span class=\"line\">    // 提交的数据需要viewData的数据，因为用户不适用优惠券，导致要重新执行一下初始化viewData的方法，</span><br><span class=\"line\">    // 因为所有的项目都不需要优惠券才对</span><br><span class=\"line\">    console.log(this.data.viewData.getPostData());</span><br><span class=\"line\">    // do post</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj2.onLoad().then(_ =&gt; &#123;</span><br><span class=\"line\">  console.log(obj2.data.viewData);</span><br><span class=\"line\">  obj2.mockTap()</span><br><span class=\"line\">  obj2.postData()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>代码就变的比较简洁，且维护的时候容易知道哪一块功能做啥的，也会告诉别人该怎么对代码进行拓展。这样的做法进行了解耦，也增加了可扩展性。<br>但坏处就是做之前要考虑好有哪些对象，需要进行声明。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>typescript就很好的支持了面向对象开发，有抽象，继承，多态，封装。就是为面向对象进行服务。如果类型声明的好，也可以直接靠ide进行相应对象内部的属性。</p>\n<p>现在小程序中有太多面向过程开发，这有太多是小程序自身的框架原因，诱导使用面向过程。面向过程关心的是先干什么，再干什么，如onLoad的时候做什么，onShow的时候做什么，<br>一步一步往下走，而过程多了，代码就乱了。<br>而面向对象，就是先根据业务需求，有哪些模型类，这个类（业务）要干什么，有什么属性，以及进行的状态，外部使用通过实例化建立联系，当需要完成什么功能，则可以通过<br>执行对象的方法后返回结果，视图层再进行处理这个结果，这样也保护了数据的完整性，具体可以了解函数式编程。</p>\n"},{"_content":"浏览器运行机制\n=========\n\n了解浏览器运行机制才能写出更好的代码和更贴合用户体验。\n\n### 进程和线程\n在了解浏览器运行机制之前，先复习下线程和进程的概念。\n进程：进程是计算机资源分配和调度的最小单位，可以申请和拥有计算机资源，进程是程序的基本执行实体。\n线程：线程是操作系统能够运算调度的最小单位，一个进程可以并发多个线程，每个线程并行执行不同的任务。\n\n进程间通信方式：\n  1. 管道。（是一种半双工单向通信模式，用于父子之间进程通信）\n  2. 命名管道。（也是一种半双工通信方式，但可以对非亲缘进程通信）\n  3. 信号。用于通知接收进程某个事件已经发生。\n  4. 信号量。可用来控制多个进程之间共享资源的访问，常用于锁机制。防止一个进程访问资源后，另一个进程也在访问。\n  5. 套接字。又称socket，可以在不同设备之间的进程中进行通信\n  6. 共享内存。映射一段能被其他进程访问的内存。\n  7. 消息队列。\n\n线程间通信方式：\n  1. 锁机制。读写锁，互斥锁，条件变量。\n     1). 读写锁：允许多个线程同时读共享数据，但对写操作是排斥。\n     2). 互斥锁：已排他的方式阻止其他线程对数据结构进行修改的方法。\n     3). 条件变量：以原子的方式阻塞当前进程，直到某个条件为真为止。始终与互斥锁一起使用。\n  2. 信号量。\n  3. 信号。\n \n\n### 浏览器，以下以chrome为例。\nchrome是基于开源的chromium, 而浏览器本身也是多进程模式。\n浏览器分以下几个子进程：\n  1. browser进程。（只有一个，浏览器工具栏那块）。负责用户界面，包括地址栏书签，以及负责和其他进程协调工作。\n  2. 渲染器进程。（一个tab有可能页面一个渲染器进程, 后面会解释为什么一个页面一个进程）。用于显示tab标签页的所有内容。\n  3. 插件进程。网站使用的插件，例如flash。（不是Chrome市场的扩展）\n  4. GPU进程。负责浏览器界面渲染。\n  5. 网络进程。发起接受网络请求。\n  6. 缓存进程。\n  .....\n  \n![image 浏览器架构](https://raw.githubusercontent.com/SalterYu/images/master/browser/browser-framwork.png)\n\n\n### 浏览器的基本功能\n1. 用户界面。\n2. 浏览器引擎。负责数据存储持久层，帮助存储\n3. 渲染器引擎。负责网络，js解析器，不同浏览器的内核引擎不同\n\n### 为什么浏览器是多进程结构\n如果浏览器不是多进程，那么当开启多个tab页面后会出现性能上的影响。\n1. 不稳定。一个线程卡死会导致进程出问题。即一个tab也线程卡死可能会导致浏览器无法正常运行。\n2. 不安全。由于线程之间是可以直接共享数据，那么js就可以随意访问浏览器进程内的数据。\n3. 不流畅。一个进程要处理太多东西会导致运行效率的问题。\n\n基于以上三点，浏览器采用多进程结构。根据进程不同来拆解浏览器。\n\n### 从浏览器输入一个内容发生了什么。\n1. 浏览器进程的ui线程会捕捉输入内容，如果访问的是网址，则UI线程会启动一个网络线程来请求DNS进行域名解析，开始获取数据。如果不是地址，则会通过配置的默认搜索引擎进行查询。\n2. 当网络线程获取到数据后，会通过safe browsing来检查站点是否是恶意站点。这里会利用google的api对页面数据进行检测，并查看站点是否在黑名单中。当返回数据准备完毕并且安全校验通过后，网络线程会通知UI线程唤醒渲染。\n3. UI线程会创建一个渲染器进程来渲染页面，浏览器进程将数据通过IPC管道传给渲染器进程正式进入渲染流程。\n4. 渲染就进程接收到的html数据，它的核心任务就是把html,css,js,image等资源渲染成用户可以交互的web页面。渲染器进程的主线程将html进行解析，构造dom树结构。\n5. html首先经过tokeniser标记化，通过词法分析将输入的html内容解析成多个标记，创建DOM树。在创建的过程中，创建document对象，然后以document为根节点的DOM树不断进行修改，向其添加各种元素。这个过程称之为html树解析。\n6. html解析过程中会遇到图片，css，js资源。图片和css会通过缓存或者网络下载，<font color=#A52A2A size=4 >这些资源不会阻塞html解析</font>。但script标签会<font color=#A52A2A size=4 >停止html解析流程</font>，反而去加载script脚本。因为浏览器不知道执行js会不会改变当前html结构，如果js代码有修改html的过程，那么之前解析就没有任何意义。因此要把script标签放在合适的位置，或者用defer、async。(遇到async标签的脚本，会异步下载脚本，下载完毕后立即执行，意味着执行过程中可能会暂停html解析，且乱序加载。遇到defer的标签的脚本，异步下载，异步执行，只有当dom解析完成后才会执行js脚本。)\n\n<img src=\"https://raw.githubusercontent.com/SalterYu/images/master/browser/html-resolve1.png\" width = \"80%\" height = \"80%\" div align=center />\n\n7. 在html解析完成后，会获得一个DOM tree。但还不知道每个dom树的节点长什么样子，因此主线程需要解析css，这个过程和解析html是并行的。因此<font color=#A52A2A size=4 >css的加载不会阻塞浏览器解析，但是会阻塞浏览器渲染</font>。因为需要知道css是咋样的，才可以执行渲染（layout）。\n8. 在知道DOM结构和每个节点的样式后，接下来需要知道每个节点要放在页面哪个位置，也就是节点的坐标以及占用多大区域。这个阶段称之为layout布局。\n9. 主线程通过遍历dom和计算好的样式，会生成一个layout tree。这棵树上每个节点都记录了x，y坐标和边框尺寸。DOM树和Layout树不是一一对应的。因为有display:none 和伪元素的存在。display为none的元素不会出现在layout树，content的元素不会出现在DOM树中。这是因为dom树是根据html解析获得，并不关心样式，而layout树是根据DOM树加计算好的样式生成。\n10. 但知道了layout树还不够，我们需要知道怎么样的顺序来绘制节点。例如z-index会影响节点绘制的层级关系。\n\n```html\n<style>\n.A {\n  width: 100px;\n  height: 100px;\n  background-color: burlywood;\n  position: absolute;\n  z-index: 10;\n}\n\n.B {\n  width: 50px;\n  height: 50px;\n  background-color: cadetblue;\n  position: absolute;\n  top: 0;\n  z-index: 5;\n}\n\nbody {\n  position: relative;\n}\n</style>\n<body>\n<body>\n  <div class=\"A\"></div>\n  <div class=\"B\"></div>\n</body>\n</body>\n```\n这段html，在没有绘制顺序的情况下，应该是B盖在A上面，但受z-index影响，改变了他们的绘制顺序，因此A盖在了B的上面。\n11. 因此为了保证屏幕上显示正确的层级，主线程遍历layout tree创建一个绘制记录表（Paint Record）,代表记录了绘制的顺序，这个阶段就称之为<font color=#A52A2A size=4 >绘制（paint）</font>\n12. 现在知道了文档的绘制顺序，那就要这些信息转化为像素点了展示在屏幕上的时候了。（栅格化流程）\n13. 现在的栅格化流程是一种复杂的栅格化，称之为合成。将页面各个部分分成多个图层，分别对其进行栅格化，并在合成器线程单独进行页面合成。即页面所有的元素，按照某种规则进行分图层，然后只需要将可视区域的内容组合成一帧展示。\n\n### 如何进行合成\n1. 主线程遍历layout tree生成layer tree（图层树），当layer tree生成完毕和绘制顺序后，主线程将这些信息传达给<font color=#A52A2A size=4 >合成器线程</font>，并将每个图层栅格化，并将其切分成许多图块，然后将每个图块发送给<font color=#A52A2A size=4 >栅格化线程</font>，栅格化线程栅格化图块后，并存储在GPU内存中，当图块栅格化完毕后，合成器线程会收集称为“draw quads”的图块信息，这些信息记录了图块在内存中的位置和在页面的哪个位置绘制图块信息，根据这些信息合成词线程生成一个合成器帧，再通过IPC传给浏览器进程，然后浏览器将其传给GPU，然后GPU渲染到屏幕上。每次页面滚动，或者发生变化，都会合成一个新的合成器帧，重复上述流程。\n\n### 总结\n浏览器进程：浏览器进程的网络线程获取到html内容 => 通过IPC将数据传给渲染器进程的主线程\n渲染器进程的主线程：将html解析构造DOM树，并计算样式 => 生成layout tree（Layer）=> 通过遍历layout tree生成绘制顺序表（paint）=> 生成 layer tree => 将绘制顺序表和layer tree传给合成器线程\n合成器线程：按规则进行分图层 => 分成更小的图块传给栅格线程进行栅格化 => 合成器线程获得栅格线程传来的draw quads图块信息 => \n根据图块信息生成合成器帧frame => 通过IPC传回给浏览器进程 => 传给GPU进行渲染。\n\n![image 渲染流程](https://raw.githubusercontent.com/SalterYu/images/master/browser/render-process.png)\n当改变元素尺寸位置属性时，会在主线程重新进行样式计算，layout，paint之后的所有流程，这种行为称之为<font color=#A52A2A size=4 >重排</font>\n当改变某个元素的颜色属性时，不会重新触发layout，但还是会触发样式计算和绘制，这称之为<font color=#A52A2A size=4 >重绘</font>\n\n重排和重绘都会占用主线程，而且js也会占用主线程。当页面以每秒60帧刷新率是才不会让用户觉得卡顿，这个时候如果有靠重排和重绘来运行动画的（例如改变绝对定位的top、left、right、bottom值），且又有大量的js计算，这个时候会出现掉帧的情况。\n![image 动画和js](https://raw.githubusercontent.com/SalterYu/images/master/browser/animation1.png)\n\n![image 动画和js](https://raw.githubusercontent.com/SalterYu/images/master/browser/animation2.png)\n（上图就是js占用了三帧，导致在下一帧绘制动画的时候没有按时渲染，就会出现页面动画卡顿，掉帧的情况。）\n\n优化手段：\n1. requestAnimationFrame()方法会在每一帧之间调用，及时让js归还主线程。\n2. 利用transform：栅格化的整个流程不会占用主线程，直接在合成器线程和栅格线程中运行。\n\n\n### 参考文献\n[《Inside look at modern web browser1-4》](https://developers.google.com/web/updates/2018/09/inside-browser-part1)\n[彻底搞懂浏览器运行机制](https://segmentfault.com/a/1190000019706953)\n","source":"_posts/browser-process.md","raw":"浏览器运行机制\n=========\n\n了解浏览器运行机制才能写出更好的代码和更贴合用户体验。\n\n### 进程和线程\n在了解浏览器运行机制之前，先复习下线程和进程的概念。\n进程：进程是计算机资源分配和调度的最小单位，可以申请和拥有计算机资源，进程是程序的基本执行实体。\n线程：线程是操作系统能够运算调度的最小单位，一个进程可以并发多个线程，每个线程并行执行不同的任务。\n\n进程间通信方式：\n  1. 管道。（是一种半双工单向通信模式，用于父子之间进程通信）\n  2. 命名管道。（也是一种半双工通信方式，但可以对非亲缘进程通信）\n  3. 信号。用于通知接收进程某个事件已经发生。\n  4. 信号量。可用来控制多个进程之间共享资源的访问，常用于锁机制。防止一个进程访问资源后，另一个进程也在访问。\n  5. 套接字。又称socket，可以在不同设备之间的进程中进行通信\n  6. 共享内存。映射一段能被其他进程访问的内存。\n  7. 消息队列。\n\n线程间通信方式：\n  1. 锁机制。读写锁，互斥锁，条件变量。\n     1). 读写锁：允许多个线程同时读共享数据，但对写操作是排斥。\n     2). 互斥锁：已排他的方式阻止其他线程对数据结构进行修改的方法。\n     3). 条件变量：以原子的方式阻塞当前进程，直到某个条件为真为止。始终与互斥锁一起使用。\n  2. 信号量。\n  3. 信号。\n \n\n### 浏览器，以下以chrome为例。\nchrome是基于开源的chromium, 而浏览器本身也是多进程模式。\n浏览器分以下几个子进程：\n  1. browser进程。（只有一个，浏览器工具栏那块）。负责用户界面，包括地址栏书签，以及负责和其他进程协调工作。\n  2. 渲染器进程。（一个tab有可能页面一个渲染器进程, 后面会解释为什么一个页面一个进程）。用于显示tab标签页的所有内容。\n  3. 插件进程。网站使用的插件，例如flash。（不是Chrome市场的扩展）\n  4. GPU进程。负责浏览器界面渲染。\n  5. 网络进程。发起接受网络请求。\n  6. 缓存进程。\n  .....\n  \n![image 浏览器架构](https://raw.githubusercontent.com/SalterYu/images/master/browser/browser-framwork.png)\n\n\n### 浏览器的基本功能\n1. 用户界面。\n2. 浏览器引擎。负责数据存储持久层，帮助存储\n3. 渲染器引擎。负责网络，js解析器，不同浏览器的内核引擎不同\n\n### 为什么浏览器是多进程结构\n如果浏览器不是多进程，那么当开启多个tab页面后会出现性能上的影响。\n1. 不稳定。一个线程卡死会导致进程出问题。即一个tab也线程卡死可能会导致浏览器无法正常运行。\n2. 不安全。由于线程之间是可以直接共享数据，那么js就可以随意访问浏览器进程内的数据。\n3. 不流畅。一个进程要处理太多东西会导致运行效率的问题。\n\n基于以上三点，浏览器采用多进程结构。根据进程不同来拆解浏览器。\n\n### 从浏览器输入一个内容发生了什么。\n1. 浏览器进程的ui线程会捕捉输入内容，如果访问的是网址，则UI线程会启动一个网络线程来请求DNS进行域名解析，开始获取数据。如果不是地址，则会通过配置的默认搜索引擎进行查询。\n2. 当网络线程获取到数据后，会通过safe browsing来检查站点是否是恶意站点。这里会利用google的api对页面数据进行检测，并查看站点是否在黑名单中。当返回数据准备完毕并且安全校验通过后，网络线程会通知UI线程唤醒渲染。\n3. UI线程会创建一个渲染器进程来渲染页面，浏览器进程将数据通过IPC管道传给渲染器进程正式进入渲染流程。\n4. 渲染就进程接收到的html数据，它的核心任务就是把html,css,js,image等资源渲染成用户可以交互的web页面。渲染器进程的主线程将html进行解析，构造dom树结构。\n5. html首先经过tokeniser标记化，通过词法分析将输入的html内容解析成多个标记，创建DOM树。在创建的过程中，创建document对象，然后以document为根节点的DOM树不断进行修改，向其添加各种元素。这个过程称之为html树解析。\n6. html解析过程中会遇到图片，css，js资源。图片和css会通过缓存或者网络下载，<font color=#A52A2A size=4 >这些资源不会阻塞html解析</font>。但script标签会<font color=#A52A2A size=4 >停止html解析流程</font>，反而去加载script脚本。因为浏览器不知道执行js会不会改变当前html结构，如果js代码有修改html的过程，那么之前解析就没有任何意义。因此要把script标签放在合适的位置，或者用defer、async。(遇到async标签的脚本，会异步下载脚本，下载完毕后立即执行，意味着执行过程中可能会暂停html解析，且乱序加载。遇到defer的标签的脚本，异步下载，异步执行，只有当dom解析完成后才会执行js脚本。)\n\n<img src=\"https://raw.githubusercontent.com/SalterYu/images/master/browser/html-resolve1.png\" width = \"80%\" height = \"80%\" div align=center />\n\n7. 在html解析完成后，会获得一个DOM tree。但还不知道每个dom树的节点长什么样子，因此主线程需要解析css，这个过程和解析html是并行的。因此<font color=#A52A2A size=4 >css的加载不会阻塞浏览器解析，但是会阻塞浏览器渲染</font>。因为需要知道css是咋样的，才可以执行渲染（layout）。\n8. 在知道DOM结构和每个节点的样式后，接下来需要知道每个节点要放在页面哪个位置，也就是节点的坐标以及占用多大区域。这个阶段称之为layout布局。\n9. 主线程通过遍历dom和计算好的样式，会生成一个layout tree。这棵树上每个节点都记录了x，y坐标和边框尺寸。DOM树和Layout树不是一一对应的。因为有display:none 和伪元素的存在。display为none的元素不会出现在layout树，content的元素不会出现在DOM树中。这是因为dom树是根据html解析获得，并不关心样式，而layout树是根据DOM树加计算好的样式生成。\n10. 但知道了layout树还不够，我们需要知道怎么样的顺序来绘制节点。例如z-index会影响节点绘制的层级关系。\n\n```html\n<style>\n.A {\n  width: 100px;\n  height: 100px;\n  background-color: burlywood;\n  position: absolute;\n  z-index: 10;\n}\n\n.B {\n  width: 50px;\n  height: 50px;\n  background-color: cadetblue;\n  position: absolute;\n  top: 0;\n  z-index: 5;\n}\n\nbody {\n  position: relative;\n}\n</style>\n<body>\n<body>\n  <div class=\"A\"></div>\n  <div class=\"B\"></div>\n</body>\n</body>\n```\n这段html，在没有绘制顺序的情况下，应该是B盖在A上面，但受z-index影响，改变了他们的绘制顺序，因此A盖在了B的上面。\n11. 因此为了保证屏幕上显示正确的层级，主线程遍历layout tree创建一个绘制记录表（Paint Record）,代表记录了绘制的顺序，这个阶段就称之为<font color=#A52A2A size=4 >绘制（paint）</font>\n12. 现在知道了文档的绘制顺序，那就要这些信息转化为像素点了展示在屏幕上的时候了。（栅格化流程）\n13. 现在的栅格化流程是一种复杂的栅格化，称之为合成。将页面各个部分分成多个图层，分别对其进行栅格化，并在合成器线程单独进行页面合成。即页面所有的元素，按照某种规则进行分图层，然后只需要将可视区域的内容组合成一帧展示。\n\n### 如何进行合成\n1. 主线程遍历layout tree生成layer tree（图层树），当layer tree生成完毕和绘制顺序后，主线程将这些信息传达给<font color=#A52A2A size=4 >合成器线程</font>，并将每个图层栅格化，并将其切分成许多图块，然后将每个图块发送给<font color=#A52A2A size=4 >栅格化线程</font>，栅格化线程栅格化图块后，并存储在GPU内存中，当图块栅格化完毕后，合成器线程会收集称为“draw quads”的图块信息，这些信息记录了图块在内存中的位置和在页面的哪个位置绘制图块信息，根据这些信息合成词线程生成一个合成器帧，再通过IPC传给浏览器进程，然后浏览器将其传给GPU，然后GPU渲染到屏幕上。每次页面滚动，或者发生变化，都会合成一个新的合成器帧，重复上述流程。\n\n### 总结\n浏览器进程：浏览器进程的网络线程获取到html内容 => 通过IPC将数据传给渲染器进程的主线程\n渲染器进程的主线程：将html解析构造DOM树，并计算样式 => 生成layout tree（Layer）=> 通过遍历layout tree生成绘制顺序表（paint）=> 生成 layer tree => 将绘制顺序表和layer tree传给合成器线程\n合成器线程：按规则进行分图层 => 分成更小的图块传给栅格线程进行栅格化 => 合成器线程获得栅格线程传来的draw quads图块信息 => \n根据图块信息生成合成器帧frame => 通过IPC传回给浏览器进程 => 传给GPU进行渲染。\n\n![image 渲染流程](https://raw.githubusercontent.com/SalterYu/images/master/browser/render-process.png)\n当改变元素尺寸位置属性时，会在主线程重新进行样式计算，layout，paint之后的所有流程，这种行为称之为<font color=#A52A2A size=4 >重排</font>\n当改变某个元素的颜色属性时，不会重新触发layout，但还是会触发样式计算和绘制，这称之为<font color=#A52A2A size=4 >重绘</font>\n\n重排和重绘都会占用主线程，而且js也会占用主线程。当页面以每秒60帧刷新率是才不会让用户觉得卡顿，这个时候如果有靠重排和重绘来运行动画的（例如改变绝对定位的top、left、right、bottom值），且又有大量的js计算，这个时候会出现掉帧的情况。\n![image 动画和js](https://raw.githubusercontent.com/SalterYu/images/master/browser/animation1.png)\n\n![image 动画和js](https://raw.githubusercontent.com/SalterYu/images/master/browser/animation2.png)\n（上图就是js占用了三帧，导致在下一帧绘制动画的时候没有按时渲染，就会出现页面动画卡顿，掉帧的情况。）\n\n优化手段：\n1. requestAnimationFrame()方法会在每一帧之间调用，及时让js归还主线程。\n2. 利用transform：栅格化的整个流程不会占用主线程，直接在合成器线程和栅格线程中运行。\n\n\n### 参考文献\n[《Inside look at modern web browser1-4》](https://developers.google.com/web/updates/2018/09/inside-browser-part1)\n[彻底搞懂浏览器运行机制](https://segmentfault.com/a/1190000019706953)\n","slug":"browser-process","published":1,"date":"2020-07-10T07:48:11.967Z","updated":"2020-07-17T01:34:01.883Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdsjt88k0009falvfpg1jtur","content":"<h1 id=\"浏览器运行机制\"><a href=\"#浏览器运行机制\" class=\"headerlink\" title=\"浏览器运行机制\"></a>浏览器运行机制</h1><p>了解浏览器运行机制才能写出更好的代码和更贴合用户体验。</p>\n<h3 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h3><p>在了解浏览器运行机制之前，先复习下线程和进程的概念。<br>进程：进程是计算机资源分配和调度的最小单位，可以申请和拥有计算机资源，进程是程序的基本执行实体。<br>线程：线程是操作系统能够运算调度的最小单位，一个进程可以并发多个线程，每个线程并行执行不同的任务。</p>\n<p>进程间通信方式：</p>\n<ol>\n<li>管道。（是一种半双工单向通信模式，用于父子之间进程通信）</li>\n<li>命名管道。（也是一种半双工通信方式，但可以对非亲缘进程通信）</li>\n<li>信号。用于通知接收进程某个事件已经发生。</li>\n<li>信号量。可用来控制多个进程之间共享资源的访问，常用于锁机制。防止一个进程访问资源后，另一个进程也在访问。</li>\n<li>套接字。又称socket，可以在不同设备之间的进程中进行通信</li>\n<li>共享内存。映射一段能被其他进程访问的内存。</li>\n<li>消息队列。</li>\n</ol>\n<p>线程间通信方式：</p>\n<ol>\n<li>锁机制。读写锁，互斥锁，条件变量。<br>1). 读写锁：允许多个线程同时读共享数据，但对写操作是排斥。<br>2). 互斥锁：已排他的方式阻止其他线程对数据结构进行修改的方法。<br>3). 条件变量：以原子的方式阻塞当前进程，直到某个条件为真为止。始终与互斥锁一起使用。</li>\n<li>信号量。</li>\n<li>信号。</li>\n</ol>\n<h3 id=\"浏览器，以下以chrome为例。\"><a href=\"#浏览器，以下以chrome为例。\" class=\"headerlink\" title=\"浏览器，以下以chrome为例。\"></a>浏览器，以下以chrome为例。</h3><p>chrome是基于开源的chromium, 而浏览器本身也是多进程模式。<br>浏览器分以下几个子进程：</p>\n<ol>\n<li>browser进程。（只有一个，浏览器工具栏那块）。负责用户界面，包括地址栏书签，以及负责和其他进程协调工作。</li>\n<li>渲染器进程。（一个tab有可能页面一个渲染器进程, 后面会解释为什么一个页面一个进程）。用于显示tab标签页的所有内容。</li>\n<li>插件进程。网站使用的插件，例如flash。（不是Chrome市场的扩展）</li>\n<li>GPU进程。负责浏览器界面渲染。</li>\n<li>网络进程。发起接受网络请求。</li>\n<li>缓存进程。<br>…..</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/SalterYu/images/master/browser/browser-framwork.png\" alt=\"image 浏览器架构\"></p>\n<h3 id=\"浏览器的基本功能\"><a href=\"#浏览器的基本功能\" class=\"headerlink\" title=\"浏览器的基本功能\"></a>浏览器的基本功能</h3><ol>\n<li>用户界面。</li>\n<li>浏览器引擎。负责数据存储持久层，帮助存储</li>\n<li>渲染器引擎。负责网络，js解析器，不同浏览器的内核引擎不同</li>\n</ol>\n<h3 id=\"为什么浏览器是多进程结构\"><a href=\"#为什么浏览器是多进程结构\" class=\"headerlink\" title=\"为什么浏览器是多进程结构\"></a>为什么浏览器是多进程结构</h3><p>如果浏览器不是多进程，那么当开启多个tab页面后会出现性能上的影响。</p>\n<ol>\n<li>不稳定。一个线程卡死会导致进程出问题。即一个tab也线程卡死可能会导致浏览器无法正常运行。</li>\n<li>不安全。由于线程之间是可以直接共享数据，那么js就可以随意访问浏览器进程内的数据。</li>\n<li>不流畅。一个进程要处理太多东西会导致运行效率的问题。</li>\n</ol>\n<p>基于以上三点，浏览器采用多进程结构。根据进程不同来拆解浏览器。</p>\n<h3 id=\"从浏览器输入一个内容发生了什么。\"><a href=\"#从浏览器输入一个内容发生了什么。\" class=\"headerlink\" title=\"从浏览器输入一个内容发生了什么。\"></a>从浏览器输入一个内容发生了什么。</h3><ol>\n<li>浏览器进程的ui线程会捕捉输入内容，如果访问的是网址，则UI线程会启动一个网络线程来请求DNS进行域名解析，开始获取数据。如果不是地址，则会通过配置的默认搜索引擎进行查询。</li>\n<li>当网络线程获取到数据后，会通过safe browsing来检查站点是否是恶意站点。这里会利用google的api对页面数据进行检测，并查看站点是否在黑名单中。当返回数据准备完毕并且安全校验通过后，网络线程会通知UI线程唤醒渲染。</li>\n<li>UI线程会创建一个渲染器进程来渲染页面，浏览器进程将数据通过IPC管道传给渲染器进程正式进入渲染流程。</li>\n<li>渲染就进程接收到的html数据，它的核心任务就是把html,css,js,image等资源渲染成用户可以交互的web页面。渲染器进程的主线程将html进行解析，构造dom树结构。</li>\n<li>html首先经过tokeniser标记化，通过词法分析将输入的html内容解析成多个标记，创建DOM树。在创建的过程中，创建document对象，然后以document为根节点的DOM树不断进行修改，向其添加各种元素。这个过程称之为html树解析。</li>\n<li>html解析过程中会遇到图片，css，js资源。图片和css会通过缓存或者网络下载，<font color=\"#A52A2A\" size=\"4\">这些资源不会阻塞html解析</font>。但script标签会<font color=\"#A52A2A\" size=\"4\">停止html解析流程</font>，反而去加载script脚本。因为浏览器不知道执行js会不会改变当前html结构，如果js代码有修改html的过程，那么之前解析就没有任何意义。因此要把script标签放在合适的位置，或者用defer、async。(遇到async标签的脚本，会异步下载脚本，下载完毕后立即执行，意味着执行过程中可能会暂停html解析，且乱序加载。遇到defer的标签的脚本，异步下载，异步执行，只有当dom解析完成后才会执行js脚本。)</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/SalterYu/images/master/browser/html-resolve1.png\" width=\"80%\" height=\"80%\" div=\"\" align=\"center\"></p>\n<ol start=\"7\">\n<li>在html解析完成后，会获得一个DOM tree。但还不知道每个dom树的节点长什么样子，因此主线程需要解析css，这个过程和解析html是并行的。因此<font color=\"#A52A2A\" size=\"4\">css的加载不会阻塞浏览器解析，但是会阻塞浏览器渲染</font>。因为需要知道css是咋样的，才可以执行渲染（layout）。</li>\n<li>在知道DOM结构和每个节点的样式后，接下来需要知道每个节点要放在页面哪个位置，也就是节点的坐标以及占用多大区域。这个阶段称之为layout布局。</li>\n<li>主线程通过遍历dom和计算好的样式，会生成一个layout tree。这棵树上每个节点都记录了x，y坐标和边框尺寸。DOM树和Layout树不是一一对应的。因为有display:none 和伪元素的存在。display为none的元素不会出现在layout树，content的元素不会出现在DOM树中。这是因为dom树是根据html解析获得，并不关心样式，而layout树是根据DOM树加计算好的样式生成。</li>\n<li>但知道了layout树还不够，我们需要知道怎么样的顺序来绘制节点。例如z-index会影响节点绘制的层级关系。</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">.A &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  width: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">  height: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">  background-color: burlywood;</span></span><br><span class=\"line\"><span class=\"undefined\">  position: absolute;</span></span><br><span class=\"line\"><span class=\"undefined\">  z-index: 10;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">.B &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  width: 50px;</span></span><br><span class=\"line\"><span class=\"undefined\">  height: 50px;</span></span><br><span class=\"line\"><span class=\"undefined\">  background-color: cadetblue;</span></span><br><span class=\"line\"><span class=\"undefined\">  position: absolute;</span></span><br><span class=\"line\"><span class=\"undefined\">  top: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">  z-index: 5;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">body &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  position: relative;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"A\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"B\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这段html，在没有绘制顺序的情况下，应该是B盖在A上面，但受z-index影响，改变了他们的绘制顺序，因此A盖在了B的上面。</p>\n<ol start=\"11\">\n<li>因此为了保证屏幕上显示正确的层级，主线程遍历layout tree创建一个绘制记录表（Paint Record）,代表记录了绘制的顺序，这个阶段就称之为<font color=\"#A52A2A\" size=\"4\">绘制（paint）</font></li>\n<li>现在知道了文档的绘制顺序，那就要这些信息转化为像素点了展示在屏幕上的时候了。（栅格化流程）</li>\n<li>现在的栅格化流程是一种复杂的栅格化，称之为合成。将页面各个部分分成多个图层，分别对其进行栅格化，并在合成器线程单独进行页面合成。即页面所有的元素，按照某种规则进行分图层，然后只需要将可视区域的内容组合成一帧展示。</li>\n</ol>\n<h3 id=\"如何进行合成\"><a href=\"#如何进行合成\" class=\"headerlink\" title=\"如何进行合成\"></a>如何进行合成</h3><ol>\n<li>主线程遍历layout tree生成layer tree（图层树），当layer tree生成完毕和绘制顺序后，主线程将这些信息传达给<font color=\"#A52A2A\" size=\"4\">合成器线程</font>，并将每个图层栅格化，并将其切分成许多图块，然后将每个图块发送给<font color=\"#A52A2A\" size=\"4\">栅格化线程</font>，栅格化线程栅格化图块后，并存储在GPU内存中，当图块栅格化完毕后，合成器线程会收集称为“draw quads”的图块信息，这些信息记录了图块在内存中的位置和在页面的哪个位置绘制图块信息，根据这些信息合成词线程生成一个合成器帧，再通过IPC传给浏览器进程，然后浏览器将其传给GPU，然后GPU渲染到屏幕上。每次页面滚动，或者发生变化，都会合成一个新的合成器帧，重复上述流程。</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>浏览器进程：浏览器进程的网络线程获取到html内容 =&gt; 通过IPC将数据传给渲染器进程的主线程<br>渲染器进程的主线程：将html解析构造DOM树，并计算样式 =&gt; 生成layout tree（Layer）=&gt; 通过遍历layout tree生成绘制顺序表（paint）=&gt; 生成 layer tree =&gt; 将绘制顺序表和layer tree传给合成器线程<br>合成器线程：按规则进行分图层 =&gt; 分成更小的图块传给栅格线程进行栅格化 =&gt; 合成器线程获得栅格线程传来的draw quads图块信息 =&gt;<br>根据图块信息生成合成器帧frame =&gt; 通过IPC传回给浏览器进程 =&gt; 传给GPU进行渲染。</p>\n<p><img src=\"https://raw.githubusercontent.com/SalterYu/images/master/browser/render-process.png\" alt=\"image 渲染流程\"><br>当改变元素尺寸位置属性时，会在主线程重新进行样式计算，layout，paint之后的所有流程，这种行为称之为<font color=\"#A52A2A\" size=\"4\">重排</font><br>当改变某个元素的颜色属性时，不会重新触发layout，但还是会触发样式计算和绘制，这称之为<font color=\"#A52A2A\" size=\"4\">重绘</font></p>\n<p>重排和重绘都会占用主线程，而且js也会占用主线程。当页面以每秒60帧刷新率是才不会让用户觉得卡顿，这个时候如果有靠重排和重绘来运行动画的（例如改变绝对定位的top、left、right、bottom值），且又有大量的js计算，这个时候会出现掉帧的情况。<br><img src=\"https://raw.githubusercontent.com/SalterYu/images/master/browser/animation1.png\" alt=\"image 动画和js\"></p>\n<p><img src=\"https://raw.githubusercontent.com/SalterYu/images/master/browser/animation2.png\" alt=\"image 动画和js\"><br>（上图就是js占用了三帧，导致在下一帧绘制动画的时候没有按时渲染，就会出现页面动画卡顿，掉帧的情况。）</p>\n<p>优化手段：</p>\n<ol>\n<li>requestAnimationFrame()方法会在每一帧之间调用，及时让js归还主线程。</li>\n<li>利用transform：栅格化的整个流程不会占用主线程，直接在合成器线程和栅格线程中运行。</li>\n</ol>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://developers.google.com/web/updates/2018/09/inside-browser-part1\" target=\"_blank\" rel=\"noopener\">《Inside look at modern web browser1-4》</a><br><a href=\"https://segmentfault.com/a/1190000019706953\" target=\"_blank\" rel=\"noopener\">彻底搞懂浏览器运行机制</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器运行机制\"><a href=\"#浏览器运行机制\" class=\"headerlink\" title=\"浏览器运行机制\"></a>浏览器运行机制</h1><p>了解浏览器运行机制才能写出更好的代码和更贴合用户体验。</p>\n<h3 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h3><p>在了解浏览器运行机制之前，先复习下线程和进程的概念。<br>进程：进程是计算机资源分配和调度的最小单位，可以申请和拥有计算机资源，进程是程序的基本执行实体。<br>线程：线程是操作系统能够运算调度的最小单位，一个进程可以并发多个线程，每个线程并行执行不同的任务。</p>\n<p>进程间通信方式：</p>\n<ol>\n<li>管道。（是一种半双工单向通信模式，用于父子之间进程通信）</li>\n<li>命名管道。（也是一种半双工通信方式，但可以对非亲缘进程通信）</li>\n<li>信号。用于通知接收进程某个事件已经发生。</li>\n<li>信号量。可用来控制多个进程之间共享资源的访问，常用于锁机制。防止一个进程访问资源后，另一个进程也在访问。</li>\n<li>套接字。又称socket，可以在不同设备之间的进程中进行通信</li>\n<li>共享内存。映射一段能被其他进程访问的内存。</li>\n<li>消息队列。</li>\n</ol>\n<p>线程间通信方式：</p>\n<ol>\n<li>锁机制。读写锁，互斥锁，条件变量。<br>1). 读写锁：允许多个线程同时读共享数据，但对写操作是排斥。<br>2). 互斥锁：已排他的方式阻止其他线程对数据结构进行修改的方法。<br>3). 条件变量：以原子的方式阻塞当前进程，直到某个条件为真为止。始终与互斥锁一起使用。</li>\n<li>信号量。</li>\n<li>信号。</li>\n</ol>\n<h3 id=\"浏览器，以下以chrome为例。\"><a href=\"#浏览器，以下以chrome为例。\" class=\"headerlink\" title=\"浏览器，以下以chrome为例。\"></a>浏览器，以下以chrome为例。</h3><p>chrome是基于开源的chromium, 而浏览器本身也是多进程模式。<br>浏览器分以下几个子进程：</p>\n<ol>\n<li>browser进程。（只有一个，浏览器工具栏那块）。负责用户界面，包括地址栏书签，以及负责和其他进程协调工作。</li>\n<li>渲染器进程。（一个tab有可能页面一个渲染器进程, 后面会解释为什么一个页面一个进程）。用于显示tab标签页的所有内容。</li>\n<li>插件进程。网站使用的插件，例如flash。（不是Chrome市场的扩展）</li>\n<li>GPU进程。负责浏览器界面渲染。</li>\n<li>网络进程。发起接受网络请求。</li>\n<li>缓存进程。<br>…..</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/SalterYu/images/master/browser/browser-framwork.png\" alt=\"image 浏览器架构\"></p>\n<h3 id=\"浏览器的基本功能\"><a href=\"#浏览器的基本功能\" class=\"headerlink\" title=\"浏览器的基本功能\"></a>浏览器的基本功能</h3><ol>\n<li>用户界面。</li>\n<li>浏览器引擎。负责数据存储持久层，帮助存储</li>\n<li>渲染器引擎。负责网络，js解析器，不同浏览器的内核引擎不同</li>\n</ol>\n<h3 id=\"为什么浏览器是多进程结构\"><a href=\"#为什么浏览器是多进程结构\" class=\"headerlink\" title=\"为什么浏览器是多进程结构\"></a>为什么浏览器是多进程结构</h3><p>如果浏览器不是多进程，那么当开启多个tab页面后会出现性能上的影响。</p>\n<ol>\n<li>不稳定。一个线程卡死会导致进程出问题。即一个tab也线程卡死可能会导致浏览器无法正常运行。</li>\n<li>不安全。由于线程之间是可以直接共享数据，那么js就可以随意访问浏览器进程内的数据。</li>\n<li>不流畅。一个进程要处理太多东西会导致运行效率的问题。</li>\n</ol>\n<p>基于以上三点，浏览器采用多进程结构。根据进程不同来拆解浏览器。</p>\n<h3 id=\"从浏览器输入一个内容发生了什么。\"><a href=\"#从浏览器输入一个内容发生了什么。\" class=\"headerlink\" title=\"从浏览器输入一个内容发生了什么。\"></a>从浏览器输入一个内容发生了什么。</h3><ol>\n<li>浏览器进程的ui线程会捕捉输入内容，如果访问的是网址，则UI线程会启动一个网络线程来请求DNS进行域名解析，开始获取数据。如果不是地址，则会通过配置的默认搜索引擎进行查询。</li>\n<li>当网络线程获取到数据后，会通过safe browsing来检查站点是否是恶意站点。这里会利用google的api对页面数据进行检测，并查看站点是否在黑名单中。当返回数据准备完毕并且安全校验通过后，网络线程会通知UI线程唤醒渲染。</li>\n<li>UI线程会创建一个渲染器进程来渲染页面，浏览器进程将数据通过IPC管道传给渲染器进程正式进入渲染流程。</li>\n<li>渲染就进程接收到的html数据，它的核心任务就是把html,css,js,image等资源渲染成用户可以交互的web页面。渲染器进程的主线程将html进行解析，构造dom树结构。</li>\n<li>html首先经过tokeniser标记化，通过词法分析将输入的html内容解析成多个标记，创建DOM树。在创建的过程中，创建document对象，然后以document为根节点的DOM树不断进行修改，向其添加各种元素。这个过程称之为html树解析。</li>\n<li>html解析过程中会遇到图片，css，js资源。图片和css会通过缓存或者网络下载，<font color=\"#A52A2A\" size=\"4\">这些资源不会阻塞html解析</font>。但script标签会<font color=\"#A52A2A\" size=\"4\">停止html解析流程</font>，反而去加载script脚本。因为浏览器不知道执行js会不会改变当前html结构，如果js代码有修改html的过程，那么之前解析就没有任何意义。因此要把script标签放在合适的位置，或者用defer、async。(遇到async标签的脚本，会异步下载脚本，下载完毕后立即执行，意味着执行过程中可能会暂停html解析，且乱序加载。遇到defer的标签的脚本，异步下载，异步执行，只有当dom解析完成后才会执行js脚本。)</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/SalterYu/images/master/browser/html-resolve1.png\" width=\"80%\" height=\"80%\" div=\"\" align=\"center\"></p>\n<ol start=\"7\">\n<li>在html解析完成后，会获得一个DOM tree。但还不知道每个dom树的节点长什么样子，因此主线程需要解析css，这个过程和解析html是并行的。因此<font color=\"#A52A2A\" size=\"4\">css的加载不会阻塞浏览器解析，但是会阻塞浏览器渲染</font>。因为需要知道css是咋样的，才可以执行渲染（layout）。</li>\n<li>在知道DOM结构和每个节点的样式后，接下来需要知道每个节点要放在页面哪个位置，也就是节点的坐标以及占用多大区域。这个阶段称之为layout布局。</li>\n<li>主线程通过遍历dom和计算好的样式，会生成一个layout tree。这棵树上每个节点都记录了x，y坐标和边框尺寸。DOM树和Layout树不是一一对应的。因为有display:none 和伪元素的存在。display为none的元素不会出现在layout树，content的元素不会出现在DOM树中。这是因为dom树是根据html解析获得，并不关心样式，而layout树是根据DOM树加计算好的样式生成。</li>\n<li>但知道了layout树还不够，我们需要知道怎么样的顺序来绘制节点。例如z-index会影响节点绘制的层级关系。</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">.A &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  width: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">  height: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">  background-color: burlywood;</span></span><br><span class=\"line\"><span class=\"undefined\">  position: absolute;</span></span><br><span class=\"line\"><span class=\"undefined\">  z-index: 10;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">.B &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  width: 50px;</span></span><br><span class=\"line\"><span class=\"undefined\">  height: 50px;</span></span><br><span class=\"line\"><span class=\"undefined\">  background-color: cadetblue;</span></span><br><span class=\"line\"><span class=\"undefined\">  position: absolute;</span></span><br><span class=\"line\"><span class=\"undefined\">  top: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">  z-index: 5;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">body &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  position: relative;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"A\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"B\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这段html，在没有绘制顺序的情况下，应该是B盖在A上面，但受z-index影响，改变了他们的绘制顺序，因此A盖在了B的上面。</p>\n<ol start=\"11\">\n<li>因此为了保证屏幕上显示正确的层级，主线程遍历layout tree创建一个绘制记录表（Paint Record）,代表记录了绘制的顺序，这个阶段就称之为<font color=\"#A52A2A\" size=\"4\">绘制（paint）</font></li>\n<li>现在知道了文档的绘制顺序，那就要这些信息转化为像素点了展示在屏幕上的时候了。（栅格化流程）</li>\n<li>现在的栅格化流程是一种复杂的栅格化，称之为合成。将页面各个部分分成多个图层，分别对其进行栅格化，并在合成器线程单独进行页面合成。即页面所有的元素，按照某种规则进行分图层，然后只需要将可视区域的内容组合成一帧展示。</li>\n</ol>\n<h3 id=\"如何进行合成\"><a href=\"#如何进行合成\" class=\"headerlink\" title=\"如何进行合成\"></a>如何进行合成</h3><ol>\n<li>主线程遍历layout tree生成layer tree（图层树），当layer tree生成完毕和绘制顺序后，主线程将这些信息传达给<font color=\"#A52A2A\" size=\"4\">合成器线程</font>，并将每个图层栅格化，并将其切分成许多图块，然后将每个图块发送给<font color=\"#A52A2A\" size=\"4\">栅格化线程</font>，栅格化线程栅格化图块后，并存储在GPU内存中，当图块栅格化完毕后，合成器线程会收集称为“draw quads”的图块信息，这些信息记录了图块在内存中的位置和在页面的哪个位置绘制图块信息，根据这些信息合成词线程生成一个合成器帧，再通过IPC传给浏览器进程，然后浏览器将其传给GPU，然后GPU渲染到屏幕上。每次页面滚动，或者发生变化，都会合成一个新的合成器帧，重复上述流程。</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>浏览器进程：浏览器进程的网络线程获取到html内容 =&gt; 通过IPC将数据传给渲染器进程的主线程<br>渲染器进程的主线程：将html解析构造DOM树，并计算样式 =&gt; 生成layout tree（Layer）=&gt; 通过遍历layout tree生成绘制顺序表（paint）=&gt; 生成 layer tree =&gt; 将绘制顺序表和layer tree传给合成器线程<br>合成器线程：按规则进行分图层 =&gt; 分成更小的图块传给栅格线程进行栅格化 =&gt; 合成器线程获得栅格线程传来的draw quads图块信息 =&gt;<br>根据图块信息生成合成器帧frame =&gt; 通过IPC传回给浏览器进程 =&gt; 传给GPU进行渲染。</p>\n<p><img src=\"https://raw.githubusercontent.com/SalterYu/images/master/browser/render-process.png\" alt=\"image 渲染流程\"><br>当改变元素尺寸位置属性时，会在主线程重新进行样式计算，layout，paint之后的所有流程，这种行为称之为<font color=\"#A52A2A\" size=\"4\">重排</font><br>当改变某个元素的颜色属性时，不会重新触发layout，但还是会触发样式计算和绘制，这称之为<font color=\"#A52A2A\" size=\"4\">重绘</font></p>\n<p>重排和重绘都会占用主线程，而且js也会占用主线程。当页面以每秒60帧刷新率是才不会让用户觉得卡顿，这个时候如果有靠重排和重绘来运行动画的（例如改变绝对定位的top、left、right、bottom值），且又有大量的js计算，这个时候会出现掉帧的情况。<br><img src=\"https://raw.githubusercontent.com/SalterYu/images/master/browser/animation1.png\" alt=\"image 动画和js\"></p>\n<p><img src=\"https://raw.githubusercontent.com/SalterYu/images/master/browser/animation2.png\" alt=\"image 动画和js\"><br>（上图就是js占用了三帧，导致在下一帧绘制动画的时候没有按时渲染，就会出现页面动画卡顿，掉帧的情况。）</p>\n<p>优化手段：</p>\n<ol>\n<li>requestAnimationFrame()方法会在每一帧之间调用，及时让js归还主线程。</li>\n<li>利用transform：栅格化的整个流程不会占用主线程，直接在合成器线程和栅格线程中运行。</li>\n</ol>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://developers.google.com/web/updates/2018/09/inside-browser-part1\" target=\"_blank\" rel=\"noopener\">《Inside look at modern web browser1-4》</a><br><a href=\"https://segmentfault.com/a/1190000019706953\" target=\"_blank\" rel=\"noopener\">彻底搞懂浏览器运行机制</a></p>\n"},{"title":"websocket原理","date":"2020-01-07T07:44:07.196Z","_content":"\n## 何谓websocket\n简而言之就是实现了服务器和客户端全双工通信，服务器可以直接推送数据给客户端，而客户端也可以直接发送数据个服务器。\n在http请求中，一个request 对应一个response，而且这个response是被动的，不能主动发起。而websocket则解决了这个问题。\n具体其他的原理不赘述，可以查阅\n<a href=\"https://juejin.im/post/5b1a7189e51d45068b496cf0\">RFC6455 Websocket协议(翻译版)</a>\n\n<a href=\"https://tools.ietf.org/html/rfc6455\">RFC6455 Websocket协议(原版)</a>\n\n## 从简单的tcp连接开始\n先用node起一个简单的server端和client端，建立一个tcp连接\n\nserver代码\n```vue\nconst net = require('net')\n\nconst server = net.createServer()\n\nserver.on('connection', sock => {\n\n  sock.setEncoding('utf8');\n\n  sock.on('error', function(err){\n    console.log('socket error - ', err);\n  });\n\n  sock.on('data', data => {\n    console.log('data', data)\n  })\n})\n\n\nserver.listen(8080, () => {\n  console.log('start on 8080')\n})\n\n```\n\nclient代码\n```vue\nconst net = require('net')\n\nconst client = net.connect({\n  port: 8080\n}, () => {\n  console.log('server connected')\n  client.setEncoding('utf8');\n  client.write('Hello Echo Server\\r\\n');\n})\n\n```\n\nnet模块是一个node的网络通信小工具，包含了创建服务器/客户端的方法。connect成功后会发送hello Echo Server,\n并且服务器会监听到事件（此处是**data**事件）。\n\n## 升级为websocket\n\n浏览器的WebSocket类已经做好的很多封装，如：握手功能，加密功能（根据 websocket protocol来制定的一套规则），等其他功能。下面具体讲一讲这两个功能。\n因此new一个WebSocket类的时候就完成了握手功能。\n\n### 模拟握手功能。\n\n先上代码\n```vue\nfunction startHandShake(cb) {\n  let str, i, key, headers\n  // 创建一个16字节长度的空缓冲区\n  key = Buffer.alloc(16)\n  // 用一个随机数进行填满\n  for (i = 0; i < 16; i++) {\n    key[i] = Math.floor(Math.random() * 256)\n  }\n  // 用base64加密\n  key = key.toString('base64')\n  // 设置请求头\n  headers = {\n    Host: '127.0.0.1',\n    Upgrade: 'websocket',\n    Connection: 'Upgrade',\n    'Sec-WebSocket-Key': key,\n    'Sec-WebSocket-Version': '13'\n  }\n\n  headers['Sec-WebSocket-Protocol'] = 'chat'\n\n  str = buildRequest('GET ' + '/' + ' HTTP/1.1', headers)\n  console.log(str)\n  // 开始握手\n  client.write(str, cb)\n}\n\n// 创建request请求参数，把一个对象变成一行一个条件\nfunction buildRequest(requestLine, headers) {\n  let headerString = requestLine + '\\r\\n',\n    headerName\n\n  for (headerName in headers) {\n    headerString += headerName + ': ' + headers[headerName] + '\\r\\n'\n  }\n\n  return headerString + '\\r\\n'\n}\n\n```\n上述代码根据websocket协议制定了一套握手规则，主要是生成`Sec-Websocket-Key`,而这个Key是由一套规定的协议制成，\n将16个随机字节的缓冲区转为base64生成的字符串作为这个参数的值。并设置`Upgrade``为websocket`, Connection为Upgrade\n来告知服务器需要升级。而服务器根据Sec-Websocket-Key再结合一段规定的`GUID:'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'`\n进行`sha1`加密，返回给客户端，并告知客户端连接成功。且只需要一次握手，之后就可以通过on监听事件来做各种处理，通过send对\n进行事件发送。\n\n服务代码：\n```vue\nconst GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'\nconst key = headers['sec-websocket-key']\nconst hash = crypto.createHash('sha1')\nhash.update(`${key}${GUID}`)\nconst result = hash.digest('base64')\nconst header = `HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-Websocket-Accept: ${result}\\r\\n\\r\\n` // 生成供前端校验用的请求头\nsocket.write(header)\n```\n\n这个时候就可以进行对话了，但有一个问题，数据都是被加密的，需要做一些处理。\n\n#### 数据的解密：\n\n在解密之前先说一下websocket协议的基础帧，这也在<a href=\"https://juejin.im/post/5c32f906f265da6136229fac#heading-3\">基础帧</a>有说。\n说的挺详细。\n而我们这只做了当Masking-key 被设置为1 的情况。想要看详细的解密，可以去看nodejs-websocket源码\n传送门: https://github.com/sitegui/nodejs-websocket/blob/master/Connection.js, 第496行\n\n借用了官方的模型\n```vue\n      0                   1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-------+-+-------------+-------------------------------+\n     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n     |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n     | |1|2|3|       |K|             |                               |\n     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n     |     Extended payload length continued, if payload len == 127  |\n     + - - - - - - - - - - - - - - - +-------------------------------+\n     |                               |Masking-key, if MASK set to 1  |\n     +-------------------------------+-------------------------------+\n     | Masking-key (continued)       |          Payload Data         |\n     +-------------------------------- - - - - - - - - - - - - - - - +\n     :                     Payload Data continued ...                :\n     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n     |                     Payload Data continued ...                |\n     +---------------------------------------------------------------+\n\n```\n因此解密的时候需要根据这个模型来进行操作。\n\n按照之前的代码，服务器会接受一串buffer。\n例如我浏览器send了一个字符：1\n服务器接收后打印为\n\n```<Buffer 81 81 95 78 24 f1 a4>```\n\n光拿出这个实在很难看懂，当然官方文档在后面的描述中也有详细介绍，看完后再回头来看图表才能看明白。这里就说我自己的理解。  \n现在再看左上角上面的图标，左上角的四个小列，也就是4位，第一位是FIN，后面三位是RSV1到3。官方文档上说RSV是预留的空间，正常为0，\n这就意味着，正常情况下他们可以当做0填充，那么前4位只有第一位的FIN需要设置，FIN表示帧结束，由于这篇中它不重要就不特别介绍了。\n接着后面的四位是储存opcode的值，这个opcode是标识数据类型的。这样数据的第一个字节我们就能理解它的含义了，看上面16进制的数据的第一个字节81换成二进制是1000001，\n第一个1是FIN的值，最后一个1是opcode的值, 表示一个文本帧（具体帧类型可以看文档）。  \n接着是第二个字节的数据，它由1位的MASK和7位的PayloadLen组成，MASK标识这个数据帧的数据是否使用掩码，PayloadLen表示数据部分的长度。但是PayloadLen只有7位，\n换成无符号整型的话只有0到127的取值，这么小的数值当然无法描述较大的数据，因此规定当数据长度小于或等于125时候它才作为数据长度的描述，如果这个值为126，\n则时候后面的两个字节来储存储存数据长度，如果为127则用后面四个字节来储存数据长度。所以上面的图片第一行的最右侧那块和第二行看起来有些颓然。从我们的示例数据来看，\n第二个字节中81(十六进制)变为二进制`10000001`, 最前面的是1，这意味着MASK为1，后面的1表示这个数据部分有1个字节\n再接着是上面图表中的MaskingKey，它占四个字节，储存掩码的实体部分。但是只有在前面的MASK被设置为1时候才存在这个数据，否则不使用掩码也就没有这个数据了。\n看我们的示例数据，由于前面的MASK为1，所以3到6字节的“95 78 24 f1”是数据的掩码实体。  \n最后是数据部分，如果掩码存在，那么所有数据都需要与掩码做一次异或运算，四个字节的掩码与所有数据字节轮流进行位运算或者逻辑运算。如果不存在掩码，那么后面的数据就可以直接使用。\n\n* FIN：1 bit\n表示这是不是消息的最后一帧。第一帧也有可能是最后一帧。 %x0： 还有后续帧 %x1：最后一帧\n\n* RSV1、RSV2、RSV3：1 bit\n扩展字段，除非一个扩展经过协商赋予了非零值的某种含义，否则必须为0\n\n* opcode：4 bit\n解释 payload data 的类型，如果收到识别不了的opcode，直接断开。分类值如下： %x0：连续的帧 %x1：text帧 %x2：binary帧 %x3 - 7：为非控制帧而预留的 %x8：关闭握手帧 %x9：ping帧 %xA：pong帧 %xB - F：为非控制帧而预留的\n\n* MASK：1 bit\n标识 Payload data 是否经过掩码处理，如果是 1，Masking-key域的数据即为掩码密钥，用于解码Payload data。协议规定客户端数据需要进行掩码处理，所以此位为1\n\n* Payload len：7 bit | 7+16 bit | 7+64 bit\n表示了 “有效负荷数据 Payload data”，以字节为单位： - 如果是 0~125，那么就直接表示了 payload 长度 - 如果是 126，那么 先存储 0x7E（=126）接下来的两个字节表示的 16位无符号整型数的值就是 payload 长度 - 如果是 127，那么 先存储 0x7E（=126）接下来的八个字节表示的 64位无符号整型数的值就是 payload 长度\n\n* Masking-key：0 | 4 bytes 掩码密钥，所有从客户端发送到服务端的帧都包含一个 32bits 的掩码（如果mask被设置成1），否则为0。一旦掩码被设置，所有接收到的 payload data 都必须与该值以一种算法做异或运算来获取真实值。\nws协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法，那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）\n答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题\n\n* Payload data：(x+y) bytes\n它是 Extension data 和 Application data 数据的总和，但是一般扩展数据为空。\n\n* Extension data：x bytes\n除非扩展被定义，否则就是0\n\n* Application data：y bytes\n占据 Extension data 后面的所有空间\n\n一个简易的解密方法\n```vue\nfunction decodeDataFrame2(buffer) {\n  const frame = {};\n  let start = 0;\n  frame.FIN = buffer[ start ] >> 7;\n  frame.Qpcode = buffer[ start++ ] & 0b1111; // opcode占四个二进制，进行与运算来获取opcode的值\n  frame.Mask = buffer[ start ] >> 7;\n  frame.PayloadLength = buffer[ start++ ] & 0b1111111; // 获取payload len，由于payload len的存储占7个二进制\n\n  if (!frame.FIN) {\n    // 表示为终结\n    return false\n  }\n\n  let s = undefined;\n\n  if (frame.PayloadLength == 126) {\n    // 表示后面的两个字节来储存储存数据长度\n    // frame.PayloadLength = buffer.readUInt16BE(2);\n    frame.PayloadLength = (buffer[ start++ ] << 8) + buffer[ start++ ];\n  } else if (frame.PayloadLength == 127) {\n    // 则用后面四个字节来储存数据长度\n    // frame.PayloadLength = buffer.readUInt16BE(4);\n    frame.PayloadLength = (buffer[ start++ ] << (8 * 3)) + (buffer[ start++ ] << (8 * 2)) + (buffer[ start++ ] << 8) + buffer[ start++ ]\n  }\n\n  if (frame.Mask) {\n    frame.MaskingKey = [buffer[ start++ ], buffer[ start++ ], buffer[ start++ ], buffer[ start++ ]];\n    s = []\n    for (let i = 0; i < frame.PayloadLength; i++) {\n      s.push( buffer[start + i] ^= frame.MaskingKey[i % 4]);\n    }\n  } else {\n    s = buffer.slice(start, frame.PayloadLength)\n  }\n  s = Buffer.from(s)\n  frame.PayloadData = s\n  return frame\n}\n```\n\n### 报文发送的加密方法（使用的nodejs-websocket）\n```vue\nfunction createTextFrame (data, masked) {\n\tvar payload, meta\n\n\tpayload = Buffer.from(data)\n\tmeta = generateMetaData(true, 1, masked === undefined ? false : masked, payload)\n\n\treturn Buffer.concat([meta, payload], meta.length + payload.length)\n}\n\nfunction generateMetaData(fin, opcode, masked, payload) {\n\tvar len, meta, start, mask, i\n\n\tlen = payload.length\n\n\t// Creates the buffer for meta-data\n\tmeta = Buffer.alloc(2 + (len < 126 ? 0 : (len < 65536 ? 2 : 8)) + (masked ? 4 : 0))\n\n\t// Sets fin and opcode\n\tmeta[0] = (fin ? 128 : 0) + opcode\n\n\t// Sets the mask and length\n\tmeta[1] = masked ? 128 : 0\n\tstart = 2\n\tif (len < 126) {\n\t\tmeta[1] += len\n\t} else if (len < 65536) {\n\t\tmeta[1] += 126\n\t\tmeta.writeUInt16BE(len, 2)\n\t\tstart += 2\n\t} else {\n\t\t// Warning: JS doesn't support integers greater than 2^53\n\t\tmeta[1] += 127\n\t\tmeta.writeUInt32BE(Math.floor(len / Math.pow(2, 32)), 2)\n\t\tmeta.writeUInt32BE(len % Math.pow(2, 32), 6)\n\t\tstart += 8\n\t}\n\n\t// Set the mask-key\n\tif (masked) {\n\t\tmask = Buffer.alloc(4)\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tmeta[start + i] = mask[i] = Math.floor(Math.random() * 256)\n\t\t}\n\t\tfor (i = 0; i < payload.length; i++) {\n\t\t\tpayload[i] ^= mask[i % 4]\n\t\t}\n\t\tstart += 4\n\t}\n\n\treturn meta\n}\n```\n\n\n\n\n\n\n","source":"_posts/socket.md","raw":"---\ntitle: websocket原理\ndate: 2019年12月25日\n---\n\n## 何谓websocket\n简而言之就是实现了服务器和客户端全双工通信，服务器可以直接推送数据给客户端，而客户端也可以直接发送数据个服务器。\n在http请求中，一个request 对应一个response，而且这个response是被动的，不能主动发起。而websocket则解决了这个问题。\n具体其他的原理不赘述，可以查阅\n<a href=\"https://juejin.im/post/5b1a7189e51d45068b496cf0\">RFC6455 Websocket协议(翻译版)</a>\n\n<a href=\"https://tools.ietf.org/html/rfc6455\">RFC6455 Websocket协议(原版)</a>\n\n## 从简单的tcp连接开始\n先用node起一个简单的server端和client端，建立一个tcp连接\n\nserver代码\n```vue\nconst net = require('net')\n\nconst server = net.createServer()\n\nserver.on('connection', sock => {\n\n  sock.setEncoding('utf8');\n\n  sock.on('error', function(err){\n    console.log('socket error - ', err);\n  });\n\n  sock.on('data', data => {\n    console.log('data', data)\n  })\n})\n\n\nserver.listen(8080, () => {\n  console.log('start on 8080')\n})\n\n```\n\nclient代码\n```vue\nconst net = require('net')\n\nconst client = net.connect({\n  port: 8080\n}, () => {\n  console.log('server connected')\n  client.setEncoding('utf8');\n  client.write('Hello Echo Server\\r\\n');\n})\n\n```\n\nnet模块是一个node的网络通信小工具，包含了创建服务器/客户端的方法。connect成功后会发送hello Echo Server,\n并且服务器会监听到事件（此处是**data**事件）。\n\n## 升级为websocket\n\n浏览器的WebSocket类已经做好的很多封装，如：握手功能，加密功能（根据 websocket protocol来制定的一套规则），等其他功能。下面具体讲一讲这两个功能。\n因此new一个WebSocket类的时候就完成了握手功能。\n\n### 模拟握手功能。\n\n先上代码\n```vue\nfunction startHandShake(cb) {\n  let str, i, key, headers\n  // 创建一个16字节长度的空缓冲区\n  key = Buffer.alloc(16)\n  // 用一个随机数进行填满\n  for (i = 0; i < 16; i++) {\n    key[i] = Math.floor(Math.random() * 256)\n  }\n  // 用base64加密\n  key = key.toString('base64')\n  // 设置请求头\n  headers = {\n    Host: '127.0.0.1',\n    Upgrade: 'websocket',\n    Connection: 'Upgrade',\n    'Sec-WebSocket-Key': key,\n    'Sec-WebSocket-Version': '13'\n  }\n\n  headers['Sec-WebSocket-Protocol'] = 'chat'\n\n  str = buildRequest('GET ' + '/' + ' HTTP/1.1', headers)\n  console.log(str)\n  // 开始握手\n  client.write(str, cb)\n}\n\n// 创建request请求参数，把一个对象变成一行一个条件\nfunction buildRequest(requestLine, headers) {\n  let headerString = requestLine + '\\r\\n',\n    headerName\n\n  for (headerName in headers) {\n    headerString += headerName + ': ' + headers[headerName] + '\\r\\n'\n  }\n\n  return headerString + '\\r\\n'\n}\n\n```\n上述代码根据websocket协议制定了一套握手规则，主要是生成`Sec-Websocket-Key`,而这个Key是由一套规定的协议制成，\n将16个随机字节的缓冲区转为base64生成的字符串作为这个参数的值。并设置`Upgrade``为websocket`, Connection为Upgrade\n来告知服务器需要升级。而服务器根据Sec-Websocket-Key再结合一段规定的`GUID:'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'`\n进行`sha1`加密，返回给客户端，并告知客户端连接成功。且只需要一次握手，之后就可以通过on监听事件来做各种处理，通过send对\n进行事件发送。\n\n服务代码：\n```vue\nconst GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'\nconst key = headers['sec-websocket-key']\nconst hash = crypto.createHash('sha1')\nhash.update(`${key}${GUID}`)\nconst result = hash.digest('base64')\nconst header = `HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-Websocket-Accept: ${result}\\r\\n\\r\\n` // 生成供前端校验用的请求头\nsocket.write(header)\n```\n\n这个时候就可以进行对话了，但有一个问题，数据都是被加密的，需要做一些处理。\n\n#### 数据的解密：\n\n在解密之前先说一下websocket协议的基础帧，这也在<a href=\"https://juejin.im/post/5c32f906f265da6136229fac#heading-3\">基础帧</a>有说。\n说的挺详细。\n而我们这只做了当Masking-key 被设置为1 的情况。想要看详细的解密，可以去看nodejs-websocket源码\n传送门: https://github.com/sitegui/nodejs-websocket/blob/master/Connection.js, 第496行\n\n借用了官方的模型\n```vue\n      0                   1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-------+-+-------------+-------------------------------+\n     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n     |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n     | |1|2|3|       |K|             |                               |\n     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n     |     Extended payload length continued, if payload len == 127  |\n     + - - - - - - - - - - - - - - - +-------------------------------+\n     |                               |Masking-key, if MASK set to 1  |\n     +-------------------------------+-------------------------------+\n     | Masking-key (continued)       |          Payload Data         |\n     +-------------------------------- - - - - - - - - - - - - - - - +\n     :                     Payload Data continued ...                :\n     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n     |                     Payload Data continued ...                |\n     +---------------------------------------------------------------+\n\n```\n因此解密的时候需要根据这个模型来进行操作。\n\n按照之前的代码，服务器会接受一串buffer。\n例如我浏览器send了一个字符：1\n服务器接收后打印为\n\n```<Buffer 81 81 95 78 24 f1 a4>```\n\n光拿出这个实在很难看懂，当然官方文档在后面的描述中也有详细介绍，看完后再回头来看图表才能看明白。这里就说我自己的理解。  \n现在再看左上角上面的图标，左上角的四个小列，也就是4位，第一位是FIN，后面三位是RSV1到3。官方文档上说RSV是预留的空间，正常为0，\n这就意味着，正常情况下他们可以当做0填充，那么前4位只有第一位的FIN需要设置，FIN表示帧结束，由于这篇中它不重要就不特别介绍了。\n接着后面的四位是储存opcode的值，这个opcode是标识数据类型的。这样数据的第一个字节我们就能理解它的含义了，看上面16进制的数据的第一个字节81换成二进制是1000001，\n第一个1是FIN的值，最后一个1是opcode的值, 表示一个文本帧（具体帧类型可以看文档）。  \n接着是第二个字节的数据，它由1位的MASK和7位的PayloadLen组成，MASK标识这个数据帧的数据是否使用掩码，PayloadLen表示数据部分的长度。但是PayloadLen只有7位，\n换成无符号整型的话只有0到127的取值，这么小的数值当然无法描述较大的数据，因此规定当数据长度小于或等于125时候它才作为数据长度的描述，如果这个值为126，\n则时候后面的两个字节来储存储存数据长度，如果为127则用后面四个字节来储存数据长度。所以上面的图片第一行的最右侧那块和第二行看起来有些颓然。从我们的示例数据来看，\n第二个字节中81(十六进制)变为二进制`10000001`, 最前面的是1，这意味着MASK为1，后面的1表示这个数据部分有1个字节\n再接着是上面图表中的MaskingKey，它占四个字节，储存掩码的实体部分。但是只有在前面的MASK被设置为1时候才存在这个数据，否则不使用掩码也就没有这个数据了。\n看我们的示例数据，由于前面的MASK为1，所以3到6字节的“95 78 24 f1”是数据的掩码实体。  \n最后是数据部分，如果掩码存在，那么所有数据都需要与掩码做一次异或运算，四个字节的掩码与所有数据字节轮流进行位运算或者逻辑运算。如果不存在掩码，那么后面的数据就可以直接使用。\n\n* FIN：1 bit\n表示这是不是消息的最后一帧。第一帧也有可能是最后一帧。 %x0： 还有后续帧 %x1：最后一帧\n\n* RSV1、RSV2、RSV3：1 bit\n扩展字段，除非一个扩展经过协商赋予了非零值的某种含义，否则必须为0\n\n* opcode：4 bit\n解释 payload data 的类型，如果收到识别不了的opcode，直接断开。分类值如下： %x0：连续的帧 %x1：text帧 %x2：binary帧 %x3 - 7：为非控制帧而预留的 %x8：关闭握手帧 %x9：ping帧 %xA：pong帧 %xB - F：为非控制帧而预留的\n\n* MASK：1 bit\n标识 Payload data 是否经过掩码处理，如果是 1，Masking-key域的数据即为掩码密钥，用于解码Payload data。协议规定客户端数据需要进行掩码处理，所以此位为1\n\n* Payload len：7 bit | 7+16 bit | 7+64 bit\n表示了 “有效负荷数据 Payload data”，以字节为单位： - 如果是 0~125，那么就直接表示了 payload 长度 - 如果是 126，那么 先存储 0x7E（=126）接下来的两个字节表示的 16位无符号整型数的值就是 payload 长度 - 如果是 127，那么 先存储 0x7E（=126）接下来的八个字节表示的 64位无符号整型数的值就是 payload 长度\n\n* Masking-key：0 | 4 bytes 掩码密钥，所有从客户端发送到服务端的帧都包含一个 32bits 的掩码（如果mask被设置成1），否则为0。一旦掩码被设置，所有接收到的 payload data 都必须与该值以一种算法做异或运算来获取真实值。\nws协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法，那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）\n答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题\n\n* Payload data：(x+y) bytes\n它是 Extension data 和 Application data 数据的总和，但是一般扩展数据为空。\n\n* Extension data：x bytes\n除非扩展被定义，否则就是0\n\n* Application data：y bytes\n占据 Extension data 后面的所有空间\n\n一个简易的解密方法\n```vue\nfunction decodeDataFrame2(buffer) {\n  const frame = {};\n  let start = 0;\n  frame.FIN = buffer[ start ] >> 7;\n  frame.Qpcode = buffer[ start++ ] & 0b1111; // opcode占四个二进制，进行与运算来获取opcode的值\n  frame.Mask = buffer[ start ] >> 7;\n  frame.PayloadLength = buffer[ start++ ] & 0b1111111; // 获取payload len，由于payload len的存储占7个二进制\n\n  if (!frame.FIN) {\n    // 表示为终结\n    return false\n  }\n\n  let s = undefined;\n\n  if (frame.PayloadLength == 126) {\n    // 表示后面的两个字节来储存储存数据长度\n    // frame.PayloadLength = buffer.readUInt16BE(2);\n    frame.PayloadLength = (buffer[ start++ ] << 8) + buffer[ start++ ];\n  } else if (frame.PayloadLength == 127) {\n    // 则用后面四个字节来储存数据长度\n    // frame.PayloadLength = buffer.readUInt16BE(4);\n    frame.PayloadLength = (buffer[ start++ ] << (8 * 3)) + (buffer[ start++ ] << (8 * 2)) + (buffer[ start++ ] << 8) + buffer[ start++ ]\n  }\n\n  if (frame.Mask) {\n    frame.MaskingKey = [buffer[ start++ ], buffer[ start++ ], buffer[ start++ ], buffer[ start++ ]];\n    s = []\n    for (let i = 0; i < frame.PayloadLength; i++) {\n      s.push( buffer[start + i] ^= frame.MaskingKey[i % 4]);\n    }\n  } else {\n    s = buffer.slice(start, frame.PayloadLength)\n  }\n  s = Buffer.from(s)\n  frame.PayloadData = s\n  return frame\n}\n```\n\n### 报文发送的加密方法（使用的nodejs-websocket）\n```vue\nfunction createTextFrame (data, masked) {\n\tvar payload, meta\n\n\tpayload = Buffer.from(data)\n\tmeta = generateMetaData(true, 1, masked === undefined ? false : masked, payload)\n\n\treturn Buffer.concat([meta, payload], meta.length + payload.length)\n}\n\nfunction generateMetaData(fin, opcode, masked, payload) {\n\tvar len, meta, start, mask, i\n\n\tlen = payload.length\n\n\t// Creates the buffer for meta-data\n\tmeta = Buffer.alloc(2 + (len < 126 ? 0 : (len < 65536 ? 2 : 8)) + (masked ? 4 : 0))\n\n\t// Sets fin and opcode\n\tmeta[0] = (fin ? 128 : 0) + opcode\n\n\t// Sets the mask and length\n\tmeta[1] = masked ? 128 : 0\n\tstart = 2\n\tif (len < 126) {\n\t\tmeta[1] += len\n\t} else if (len < 65536) {\n\t\tmeta[1] += 126\n\t\tmeta.writeUInt16BE(len, 2)\n\t\tstart += 2\n\t} else {\n\t\t// Warning: JS doesn't support integers greater than 2^53\n\t\tmeta[1] += 127\n\t\tmeta.writeUInt32BE(Math.floor(len / Math.pow(2, 32)), 2)\n\t\tmeta.writeUInt32BE(len % Math.pow(2, 32), 6)\n\t\tstart += 8\n\t}\n\n\t// Set the mask-key\n\tif (masked) {\n\t\tmask = Buffer.alloc(4)\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tmeta[start + i] = mask[i] = Math.floor(Math.random() * 256)\n\t\t}\n\t\tfor (i = 0; i < payload.length; i++) {\n\t\t\tpayload[i] ^= mask[i % 4]\n\t\t}\n\t\tstart += 4\n\t}\n\n\treturn meta\n}\n```\n\n\n\n\n\n\n","slug":"socket","published":1,"updated":"2020-08-13T05:33:02.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdsjt88l000afalvx6r5cw6w","content":"<h2 id=\"何谓websocket\"><a href=\"#何谓websocket\" class=\"headerlink\" title=\"何谓websocket\"></a>何谓websocket</h2><p>简而言之就是实现了服务器和客户端全双工通信，服务器可以直接推送数据给客户端，而客户端也可以直接发送数据个服务器。<br>在http请求中，一个request 对应一个response，而且这个response是被动的，不能主动发起。而websocket则解决了这个问题。<br>具体其他的原理不赘述，可以查阅<br><a href=\"https://juejin.im/post/5b1a7189e51d45068b496cf0\" target=\"_blank\" rel=\"noopener\">RFC6455 Websocket协议(翻译版)</a></p>\n<p><a href=\"https://tools.ietf.org/html/rfc6455\" target=\"_blank\" rel=\"noopener\">RFC6455 Websocket协议(原版)</a></p>\n<h2 id=\"从简单的tcp连接开始\"><a href=\"#从简单的tcp连接开始\" class=\"headerlink\" title=\"从简单的tcp连接开始\"></a>从简单的tcp连接开始</h2><p>先用node起一个简单的server端和client端，建立一个tcp连接</p>\n<p>server代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const net = require(&apos;net&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">const server = net.createServer()</span><br><span class=\"line\"></span><br><span class=\"line\">server.on(&apos;connection&apos;, sock =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  sock.setEncoding(&apos;utf8&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  sock.on(&apos;error&apos;, function(err)&#123;</span><br><span class=\"line\">    console.log(&apos;socket error - &apos;, err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  sock.on(&apos;data&apos;, data =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;data&apos;, data)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8080, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;start on 8080&apos;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>client代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const net = require(&apos;net&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">const client = net.connect(&#123;</span><br><span class=\"line\">  port: 8080</span><br><span class=\"line\">&#125;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;server connected&apos;)</span><br><span class=\"line\">  client.setEncoding(&apos;utf8&apos;);</span><br><span class=\"line\">  client.write(&apos;Hello Echo Server\\r\\n&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>net模块是一个node的网络通信小工具，包含了创建服务器/客户端的方法。connect成功后会发送hello Echo Server,<br>并且服务器会监听到事件（此处是<strong>data</strong>事件）。</p>\n<h2 id=\"升级为websocket\"><a href=\"#升级为websocket\" class=\"headerlink\" title=\"升级为websocket\"></a>升级为websocket</h2><p>浏览器的WebSocket类已经做好的很多封装，如：握手功能，加密功能（根据 websocket protocol来制定的一套规则），等其他功能。下面具体讲一讲这两个功能。<br>因此new一个WebSocket类的时候就完成了握手功能。</p>\n<h3 id=\"模拟握手功能。\"><a href=\"#模拟握手功能。\" class=\"headerlink\" title=\"模拟握手功能。\"></a>模拟握手功能。</h3><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function startHandShake(cb) &#123;</span><br><span class=\"line\">  let str, i, key, headers</span><br><span class=\"line\">  // 创建一个16字节长度的空缓冲区</span><br><span class=\"line\">  key = Buffer.alloc(16)</span><br><span class=\"line\">  // 用一个随机数进行填满</span><br><span class=\"line\">  for (i = 0; i &lt; 16; i++) &#123;</span><br><span class=\"line\">    key[i] = Math.floor(Math.random() * 256)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 用base64加密</span><br><span class=\"line\">  key = key.toString(&apos;base64&apos;)</span><br><span class=\"line\">  // 设置请求头</span><br><span class=\"line\">  headers = &#123;</span><br><span class=\"line\">    Host: &apos;127.0.0.1&apos;,</span><br><span class=\"line\">    Upgrade: &apos;websocket&apos;,</span><br><span class=\"line\">    Connection: &apos;Upgrade&apos;,</span><br><span class=\"line\">    &apos;Sec-WebSocket-Key&apos;: key,</span><br><span class=\"line\">    &apos;Sec-WebSocket-Version&apos;: &apos;13&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  headers[&apos;Sec-WebSocket-Protocol&apos;] = &apos;chat&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">  str = buildRequest(&apos;GET &apos; + &apos;/&apos; + &apos; HTTP/1.1&apos;, headers)</span><br><span class=\"line\">  console.log(str)</span><br><span class=\"line\">  // 开始握手</span><br><span class=\"line\">  client.write(str, cb)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建request请求参数，把一个对象变成一行一个条件</span><br><span class=\"line\">function buildRequest(requestLine, headers) &#123;</span><br><span class=\"line\">  let headerString = requestLine + &apos;\\r\\n&apos;,</span><br><span class=\"line\">    headerName</span><br><span class=\"line\"></span><br><span class=\"line\">  for (headerName in headers) &#123;</span><br><span class=\"line\">    headerString += headerName + &apos;: &apos; + headers[headerName] + &apos;\\r\\n&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return headerString + &apos;\\r\\n&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述代码根据websocket协议制定了一套握手规则，主要是生成<code>Sec-Websocket-Key</code>,而这个Key是由一套规定的协议制成，<br>将16个随机字节的缓冲区转为base64生成的字符串作为这个参数的值。并设置<code>Upgrade`</code>为websocket<code>, Connection为Upgrade\n来告知服务器需要升级。而服务器根据Sec-Websocket-Key再结合一段规定的</code>GUID:’258EAFA5-E914-47DA-95CA-C5AB0DC85B11’<code>进行</code>sha1`加密，返回给客户端，并告知客户端连接成功。且只需要一次握手，之后就可以通过on监听事件来做各种处理，通过send对<br>进行事件发送。</p>\n<p>服务代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const GUID = &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;</span><br><span class=\"line\">const key = headers[&apos;sec-websocket-key&apos;]</span><br><span class=\"line\">const hash = crypto.createHash(&apos;sha1&apos;)</span><br><span class=\"line\">hash.update(`$&#123;key&#125;$&#123;GUID&#125;`)</span><br><span class=\"line\">const result = hash.digest(&apos;base64&apos;)</span><br><span class=\"line\">const header = `HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-Websocket-Accept: $&#123;result&#125;\\r\\n\\r\\n` // 生成供前端校验用的请求头</span><br><span class=\"line\">socket.write(header)</span><br></pre></td></tr></table></figure></p>\n<p>这个时候就可以进行对话了，但有一个问题，数据都是被加密的，需要做一些处理。</p>\n<h4 id=\"数据的解密：\"><a href=\"#数据的解密：\" class=\"headerlink\" title=\"数据的解密：\"></a>数据的解密：</h4><p>在解密之前先说一下websocket协议的基础帧，这也在<a href=\"https://juejin.im/post/5c32f906f265da6136229fac#heading-3\" target=\"_blank\" rel=\"noopener\">基础帧</a>有说。<br>说的挺详细。<br>而我们这只做了当Masking-key 被设置为1 的情况。想要看详细的解密，可以去看nodejs-websocket源码<br>传送门: <a href=\"https://github.com/sitegui/nodejs-websocket/blob/master/Connection.js\" target=\"_blank\" rel=\"noopener\">https://github.com/sitegui/nodejs-websocket/blob/master/Connection.js</a>, 第496行</p>\n<p>借用了官方的模型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 0                   1                   2                   3</span><br><span class=\"line\"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class=\"line\">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class=\"line\">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class=\"line\">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class=\"line\">| |1|2|3|       |K|             |                               |</span><br><span class=\"line\">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class=\"line\">|     Extended payload length continued, if payload len == 127  |</span><br><span class=\"line\">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class=\"line\">|                               |Masking-key, if MASK set to 1  |</span><br><span class=\"line\">+-------------------------------+-------------------------------+</span><br><span class=\"line\">| Masking-key (continued)       |          Payload Data         |</span><br><span class=\"line\">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class=\"line\">:                     Payload Data continued ...                :</span><br><span class=\"line\">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class=\"line\">|                     Payload Data continued ...                |</span><br><span class=\"line\">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure></p>\n<p>因此解密的时候需要根据这个模型来进行操作。</p>\n<p>按照之前的代码，服务器会接受一串buffer。<br>例如我浏览器send了一个字符：1<br>服务器接收后打印为</p>\n<figure class=\"highlight plain\"><figcaption><span>81 81 95 78 24 f1 a4>```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">光拿出这个实在很难看懂，当然官方文档在后面的描述中也有详细介绍，看完后再回头来看图表才能看明白。这里就说我自己的理解。  </span><br><span class=\"line\">现在再看左上角上面的图标，左上角的四个小列，也就是4位，第一位是FIN，后面三位是RSV1到3。官方文档上说RSV是预留的空间，正常为0，</span><br><span class=\"line\">这就意味着，正常情况下他们可以当做0填充，那么前4位只有第一位的FIN需要设置，FIN表示帧结束，由于这篇中它不重要就不特别介绍了。</span><br><span class=\"line\">接着后面的四位是储存opcode的值，这个opcode是标识数据类型的。这样数据的第一个字节我们就能理解它的含义了，看上面16进制的数据的第一个字节81换成二进制是1000001，</span><br><span class=\"line\">第一个1是FIN的值，最后一个1是opcode的值, 表示一个文本帧（具体帧类型可以看文档）。  </span><br><span class=\"line\">接着是第二个字节的数据，它由1位的MASK和7位的PayloadLen组成，MASK标识这个数据帧的数据是否使用掩码，PayloadLen表示数据部分的长度。但是PayloadLen只有7位，</span><br><span class=\"line\">换成无符号整型的话只有0到127的取值，这么小的数值当然无法描述较大的数据，因此规定当数据长度小于或等于125时候它才作为数据长度的描述，如果这个值为126，</span><br><span class=\"line\">则时候后面的两个字节来储存储存数据长度，如果为127则用后面四个字节来储存数据长度。所以上面的图片第一行的最右侧那块和第二行看起来有些颓然。从我们的示例数据来看，</span><br><span class=\"line\">第二个字节中81(十六进制)变为二进制`10000001`, 最前面的是1，这意味着MASK为1，后面的1表示这个数据部分有1个字节</span><br><span class=\"line\">再接着是上面图表中的MaskingKey，它占四个字节，储存掩码的实体部分。但是只有在前面的MASK被设置为1时候才存在这个数据，否则不使用掩码也就没有这个数据了。</span><br><span class=\"line\">看我们的示例数据，由于前面的MASK为1，所以3到6字节的“95 78 24 f1”是数据的掩码实体。  </span><br><span class=\"line\">最后是数据部分，如果掩码存在，那么所有数据都需要与掩码做一次异或运算，四个字节的掩码与所有数据字节轮流进行位运算或者逻辑运算。如果不存在掩码，那么后面的数据就可以直接使用。</span><br><span class=\"line\"></span><br><span class=\"line\">* FIN：1 bit</span><br><span class=\"line\">表示这是不是消息的最后一帧。第一帧也有可能是最后一帧。 %x0： 还有后续帧 %x1：最后一帧</span><br><span class=\"line\"></span><br><span class=\"line\">* RSV1、RSV2、RSV3：1 bit</span><br><span class=\"line\">扩展字段，除非一个扩展经过协商赋予了非零值的某种含义，否则必须为0</span><br><span class=\"line\"></span><br><span class=\"line\">* opcode：4 bit</span><br><span class=\"line\">解释 payload data 的类型，如果收到识别不了的opcode，直接断开。分类值如下： %x0：连续的帧 %x1：text帧 %x2：binary帧 %x3 - 7：为非控制帧而预留的 %x8：关闭握手帧 %x9：ping帧 %xA：pong帧 %xB - F：为非控制帧而预留的</span><br><span class=\"line\"></span><br><span class=\"line\">* MASK：1 bit</span><br><span class=\"line\">标识 Payload data 是否经过掩码处理，如果是 1，Masking-key域的数据即为掩码密钥，用于解码Payload data。协议规定客户端数据需要进行掩码处理，所以此位为1</span><br><span class=\"line\"></span><br><span class=\"line\">* Payload len：7 bit | 7+16 bit | 7+64 bit</span><br><span class=\"line\">表示了 “有效负荷数据 Payload data”，以字节为单位： - 如果是 0~125，那么就直接表示了 payload 长度 - 如果是 126，那么 先存储 0x7E（=126）接下来的两个字节表示的 16位无符号整型数的值就是 payload 长度 - 如果是 127，那么 先存储 0x7E（=126）接下来的八个字节表示的 64位无符号整型数的值就是 payload 长度</span><br><span class=\"line\"></span><br><span class=\"line\">* Masking-key：0 | 4 bytes 掩码密钥，所有从客户端发送到服务端的帧都包含一个 32bits 的掩码（如果mask被设置成1），否则为0。一旦掩码被设置，所有接收到的 payload data 都必须与该值以一种算法做异或运算来获取真实值。</span><br><span class=\"line\">ws协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法，那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）</span><br><span class=\"line\">答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题</span><br><span class=\"line\"></span><br><span class=\"line\">* Payload data：(x+y) bytes</span><br><span class=\"line\">它是 Extension data 和 Application data 数据的总和，但是一般扩展数据为空。</span><br><span class=\"line\"></span><br><span class=\"line\">* Extension data：x bytes</span><br><span class=\"line\">除非扩展被定义，否则就是0</span><br><span class=\"line\"></span><br><span class=\"line\">* Application data：y bytes</span><br><span class=\"line\">占据 Extension data 后面的所有空间</span><br><span class=\"line\"></span><br><span class=\"line\">一个简易的解密方法</span><br><span class=\"line\">```vue</span><br><span class=\"line\">function decodeDataFrame2(buffer) &#123;</span><br><span class=\"line\">  const frame = &#123;&#125;;</span><br><span class=\"line\">  let start = 0;</span><br><span class=\"line\">  frame.FIN = buffer[ start ] &gt;&gt; 7;</span><br><span class=\"line\">  frame.Qpcode = buffer[ start++ ] &amp; 0b1111; // opcode占四个二进制，进行与运算来获取opcode的值</span><br><span class=\"line\">  frame.Mask = buffer[ start ] &gt;&gt; 7;</span><br><span class=\"line\">  frame.PayloadLength = buffer[ start++ ] &amp; 0b1111111; // 获取payload len，由于payload len的存储占7个二进制</span><br><span class=\"line\"></span><br><span class=\"line\">  if (!frame.FIN) &#123;</span><br><span class=\"line\">    // 表示为终结</span><br><span class=\"line\">    return false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  let s = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (frame.PayloadLength == 126) &#123;</span><br><span class=\"line\">    // 表示后面的两个字节来储存储存数据长度</span><br><span class=\"line\">    // frame.PayloadLength = buffer.readUInt16BE(2);</span><br><span class=\"line\">    frame.PayloadLength = (buffer[ start++ ] &lt;&lt; 8) + buffer[ start++ ];</span><br><span class=\"line\">  &#125; else if (frame.PayloadLength == 127) &#123;</span><br><span class=\"line\">    // 则用后面四个字节来储存数据长度</span><br><span class=\"line\">    // frame.PayloadLength = buffer.readUInt16BE(4);</span><br><span class=\"line\">    frame.PayloadLength = (buffer[ start++ ] &lt;&lt; (8 * 3)) + (buffer[ start++ ] &lt;&lt; (8 * 2)) + (buffer[ start++ ] &lt;&lt; 8) + buffer[ start++ ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (frame.Mask) &#123;</span><br><span class=\"line\">    frame.MaskingKey = [buffer[ start++ ], buffer[ start++ ], buffer[ start++ ], buffer[ start++ ]];</span><br><span class=\"line\">    s = []</span><br><span class=\"line\">    for (let i = 0; i &lt; frame.PayloadLength; i++) &#123;</span><br><span class=\"line\">      s.push( buffer[start + i] ^= frame.MaskingKey[i % 4]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    s = buffer.slice(start, frame.PayloadLength)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  s = Buffer.from(s)</span><br><span class=\"line\">  frame.PayloadData = s</span><br><span class=\"line\">  return frame</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"报文发送的加密方法（使用的nodejs-websocket）\"><a href=\"#报文发送的加密方法（使用的nodejs-websocket）\" class=\"headerlink\" title=\"报文发送的加密方法（使用的nodejs-websocket）\"></a>报文发送的加密方法（使用的nodejs-websocket）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createTextFrame (data, masked) &#123;</span><br><span class=\"line\">\tvar payload, meta</span><br><span class=\"line\"></span><br><span class=\"line\">\tpayload = Buffer.from(data)</span><br><span class=\"line\">\tmeta = generateMetaData(true, 1, masked === undefined ? false : masked, payload)</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn Buffer.concat([meta, payload], meta.length + payload.length)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function generateMetaData(fin, opcode, masked, payload) &#123;</span><br><span class=\"line\">\tvar len, meta, start, mask, i</span><br><span class=\"line\"></span><br><span class=\"line\">\tlen = payload.length</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Creates the buffer for meta-data</span><br><span class=\"line\">\tmeta = Buffer.alloc(2 + (len &lt; 126 ? 0 : (len &lt; 65536 ? 2 : 8)) + (masked ? 4 : 0))</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Sets fin and opcode</span><br><span class=\"line\">\tmeta[0] = (fin ? 128 : 0) + opcode</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Sets the mask and length</span><br><span class=\"line\">\tmeta[1] = masked ? 128 : 0</span><br><span class=\"line\">\tstart = 2</span><br><span class=\"line\">\tif (len &lt; 126) &#123;</span><br><span class=\"line\">\t\tmeta[1] += len</span><br><span class=\"line\">\t&#125; else if (len &lt; 65536) &#123;</span><br><span class=\"line\">\t\tmeta[1] += 126</span><br><span class=\"line\">\t\tmeta.writeUInt16BE(len, 2)</span><br><span class=\"line\">\t\tstart += 2</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\t// Warning: JS doesn&apos;t support integers greater than 2^53</span><br><span class=\"line\">\t\tmeta[1] += 127</span><br><span class=\"line\">\t\tmeta.writeUInt32BE(Math.floor(len / Math.pow(2, 32)), 2)</span><br><span class=\"line\">\t\tmeta.writeUInt32BE(len % Math.pow(2, 32), 6)</span><br><span class=\"line\">\t\tstart += 8</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Set the mask-key</span><br><span class=\"line\">\tif (masked) &#123;</span><br><span class=\"line\">\t\tmask = Buffer.alloc(4)</span><br><span class=\"line\">\t\tfor (i = 0; i &lt; 4; i++) &#123;</span><br><span class=\"line\">\t\t\tmeta[start + i] = mask[i] = Math.floor(Math.random() * 256)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor (i = 0; i &lt; payload.length; i++) &#123;</span><br><span class=\"line\">\t\t\tpayload[i] ^= mask[i % 4]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstart += 4</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn meta</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"何谓websocket\"><a href=\"#何谓websocket\" class=\"headerlink\" title=\"何谓websocket\"></a>何谓websocket</h2><p>简而言之就是实现了服务器和客户端全双工通信，服务器可以直接推送数据给客户端，而客户端也可以直接发送数据个服务器。<br>在http请求中，一个request 对应一个response，而且这个response是被动的，不能主动发起。而websocket则解决了这个问题。<br>具体其他的原理不赘述，可以查阅<br><a href=\"https://juejin.im/post/5b1a7189e51d45068b496cf0\" target=\"_blank\" rel=\"noopener\">RFC6455 Websocket协议(翻译版)</a></p>\n<p><a href=\"https://tools.ietf.org/html/rfc6455\" target=\"_blank\" rel=\"noopener\">RFC6455 Websocket协议(原版)</a></p>\n<h2 id=\"从简单的tcp连接开始\"><a href=\"#从简单的tcp连接开始\" class=\"headerlink\" title=\"从简单的tcp连接开始\"></a>从简单的tcp连接开始</h2><p>先用node起一个简单的server端和client端，建立一个tcp连接</p>\n<p>server代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const net = require(&apos;net&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">const server = net.createServer()</span><br><span class=\"line\"></span><br><span class=\"line\">server.on(&apos;connection&apos;, sock =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  sock.setEncoding(&apos;utf8&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  sock.on(&apos;error&apos;, function(err)&#123;</span><br><span class=\"line\">    console.log(&apos;socket error - &apos;, err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  sock.on(&apos;data&apos;, data =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;data&apos;, data)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8080, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;start on 8080&apos;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>client代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const net = require(&apos;net&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">const client = net.connect(&#123;</span><br><span class=\"line\">  port: 8080</span><br><span class=\"line\">&#125;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;server connected&apos;)</span><br><span class=\"line\">  client.setEncoding(&apos;utf8&apos;);</span><br><span class=\"line\">  client.write(&apos;Hello Echo Server\\r\\n&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>net模块是一个node的网络通信小工具，包含了创建服务器/客户端的方法。connect成功后会发送hello Echo Server,<br>并且服务器会监听到事件（此处是<strong>data</strong>事件）。</p>\n<h2 id=\"升级为websocket\"><a href=\"#升级为websocket\" class=\"headerlink\" title=\"升级为websocket\"></a>升级为websocket</h2><p>浏览器的WebSocket类已经做好的很多封装，如：握手功能，加密功能（根据 websocket protocol来制定的一套规则），等其他功能。下面具体讲一讲这两个功能。<br>因此new一个WebSocket类的时候就完成了握手功能。</p>\n<h3 id=\"模拟握手功能。\"><a href=\"#模拟握手功能。\" class=\"headerlink\" title=\"模拟握手功能。\"></a>模拟握手功能。</h3><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function startHandShake(cb) &#123;</span><br><span class=\"line\">  let str, i, key, headers</span><br><span class=\"line\">  // 创建一个16字节长度的空缓冲区</span><br><span class=\"line\">  key = Buffer.alloc(16)</span><br><span class=\"line\">  // 用一个随机数进行填满</span><br><span class=\"line\">  for (i = 0; i &lt; 16; i++) &#123;</span><br><span class=\"line\">    key[i] = Math.floor(Math.random() * 256)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 用base64加密</span><br><span class=\"line\">  key = key.toString(&apos;base64&apos;)</span><br><span class=\"line\">  // 设置请求头</span><br><span class=\"line\">  headers = &#123;</span><br><span class=\"line\">    Host: &apos;127.0.0.1&apos;,</span><br><span class=\"line\">    Upgrade: &apos;websocket&apos;,</span><br><span class=\"line\">    Connection: &apos;Upgrade&apos;,</span><br><span class=\"line\">    &apos;Sec-WebSocket-Key&apos;: key,</span><br><span class=\"line\">    &apos;Sec-WebSocket-Version&apos;: &apos;13&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  headers[&apos;Sec-WebSocket-Protocol&apos;] = &apos;chat&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">  str = buildRequest(&apos;GET &apos; + &apos;/&apos; + &apos; HTTP/1.1&apos;, headers)</span><br><span class=\"line\">  console.log(str)</span><br><span class=\"line\">  // 开始握手</span><br><span class=\"line\">  client.write(str, cb)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建request请求参数，把一个对象变成一行一个条件</span><br><span class=\"line\">function buildRequest(requestLine, headers) &#123;</span><br><span class=\"line\">  let headerString = requestLine + &apos;\\r\\n&apos;,</span><br><span class=\"line\">    headerName</span><br><span class=\"line\"></span><br><span class=\"line\">  for (headerName in headers) &#123;</span><br><span class=\"line\">    headerString += headerName + &apos;: &apos; + headers[headerName] + &apos;\\r\\n&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return headerString + &apos;\\r\\n&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述代码根据websocket协议制定了一套握手规则，主要是生成<code>Sec-Websocket-Key</code>,而这个Key是由一套规定的协议制成，<br>将16个随机字节的缓冲区转为base64生成的字符串作为这个参数的值。并设置<code>Upgrade`</code>为websocket<code>, Connection为Upgrade\n来告知服务器需要升级。而服务器根据Sec-Websocket-Key再结合一段规定的</code>GUID:’258EAFA5-E914-47DA-95CA-C5AB0DC85B11’<code>进行</code>sha1`加密，返回给客户端，并告知客户端连接成功。且只需要一次握手，之后就可以通过on监听事件来做各种处理，通过send对<br>进行事件发送。</p>\n<p>服务代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const GUID = &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;</span><br><span class=\"line\">const key = headers[&apos;sec-websocket-key&apos;]</span><br><span class=\"line\">const hash = crypto.createHash(&apos;sha1&apos;)</span><br><span class=\"line\">hash.update(`$&#123;key&#125;$&#123;GUID&#125;`)</span><br><span class=\"line\">const result = hash.digest(&apos;base64&apos;)</span><br><span class=\"line\">const header = `HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-Websocket-Accept: $&#123;result&#125;\\r\\n\\r\\n` // 生成供前端校验用的请求头</span><br><span class=\"line\">socket.write(header)</span><br></pre></td></tr></table></figure></p>\n<p>这个时候就可以进行对话了，但有一个问题，数据都是被加密的，需要做一些处理。</p>\n<h4 id=\"数据的解密：\"><a href=\"#数据的解密：\" class=\"headerlink\" title=\"数据的解密：\"></a>数据的解密：</h4><p>在解密之前先说一下websocket协议的基础帧，这也在<a href=\"https://juejin.im/post/5c32f906f265da6136229fac#heading-3\" target=\"_blank\" rel=\"noopener\">基础帧</a>有说。<br>说的挺详细。<br>而我们这只做了当Masking-key 被设置为1 的情况。想要看详细的解密，可以去看nodejs-websocket源码<br>传送门: <a href=\"https://github.com/sitegui/nodejs-websocket/blob/master/Connection.js\" target=\"_blank\" rel=\"noopener\">https://github.com/sitegui/nodejs-websocket/blob/master/Connection.js</a>, 第496行</p>\n<p>借用了官方的模型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 0                   1                   2                   3</span><br><span class=\"line\"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class=\"line\">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class=\"line\">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class=\"line\">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class=\"line\">| |1|2|3|       |K|             |                               |</span><br><span class=\"line\">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class=\"line\">|     Extended payload length continued, if payload len == 127  |</span><br><span class=\"line\">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class=\"line\">|                               |Masking-key, if MASK set to 1  |</span><br><span class=\"line\">+-------------------------------+-------------------------------+</span><br><span class=\"line\">| Masking-key (continued)       |          Payload Data         |</span><br><span class=\"line\">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class=\"line\">:                     Payload Data continued ...                :</span><br><span class=\"line\">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class=\"line\">|                     Payload Data continued ...                |</span><br><span class=\"line\">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure></p>\n<p>因此解密的时候需要根据这个模型来进行操作。</p>\n<p>按照之前的代码，服务器会接受一串buffer。<br>例如我浏览器send了一个字符：1<br>服务器接收后打印为</p>\n<figure class=\"highlight plain\"><figcaption><span>81 81 95 78 24 f1 a4>```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">光拿出这个实在很难看懂，当然官方文档在后面的描述中也有详细介绍，看完后再回头来看图表才能看明白。这里就说我自己的理解。  </span><br><span class=\"line\">现在再看左上角上面的图标，左上角的四个小列，也就是4位，第一位是FIN，后面三位是RSV1到3。官方文档上说RSV是预留的空间，正常为0，</span><br><span class=\"line\">这就意味着，正常情况下他们可以当做0填充，那么前4位只有第一位的FIN需要设置，FIN表示帧结束，由于这篇中它不重要就不特别介绍了。</span><br><span class=\"line\">接着后面的四位是储存opcode的值，这个opcode是标识数据类型的。这样数据的第一个字节我们就能理解它的含义了，看上面16进制的数据的第一个字节81换成二进制是1000001，</span><br><span class=\"line\">第一个1是FIN的值，最后一个1是opcode的值, 表示一个文本帧（具体帧类型可以看文档）。  </span><br><span class=\"line\">接着是第二个字节的数据，它由1位的MASK和7位的PayloadLen组成，MASK标识这个数据帧的数据是否使用掩码，PayloadLen表示数据部分的长度。但是PayloadLen只有7位，</span><br><span class=\"line\">换成无符号整型的话只有0到127的取值，这么小的数值当然无法描述较大的数据，因此规定当数据长度小于或等于125时候它才作为数据长度的描述，如果这个值为126，</span><br><span class=\"line\">则时候后面的两个字节来储存储存数据长度，如果为127则用后面四个字节来储存数据长度。所以上面的图片第一行的最右侧那块和第二行看起来有些颓然。从我们的示例数据来看，</span><br><span class=\"line\">第二个字节中81(十六进制)变为二进制`10000001`, 最前面的是1，这意味着MASK为1，后面的1表示这个数据部分有1个字节</span><br><span class=\"line\">再接着是上面图表中的MaskingKey，它占四个字节，储存掩码的实体部分。但是只有在前面的MASK被设置为1时候才存在这个数据，否则不使用掩码也就没有这个数据了。</span><br><span class=\"line\">看我们的示例数据，由于前面的MASK为1，所以3到6字节的“95 78 24 f1”是数据的掩码实体。  </span><br><span class=\"line\">最后是数据部分，如果掩码存在，那么所有数据都需要与掩码做一次异或运算，四个字节的掩码与所有数据字节轮流进行位运算或者逻辑运算。如果不存在掩码，那么后面的数据就可以直接使用。</span><br><span class=\"line\"></span><br><span class=\"line\">* FIN：1 bit</span><br><span class=\"line\">表示这是不是消息的最后一帧。第一帧也有可能是最后一帧。 %x0： 还有后续帧 %x1：最后一帧</span><br><span class=\"line\"></span><br><span class=\"line\">* RSV1、RSV2、RSV3：1 bit</span><br><span class=\"line\">扩展字段，除非一个扩展经过协商赋予了非零值的某种含义，否则必须为0</span><br><span class=\"line\"></span><br><span class=\"line\">* opcode：4 bit</span><br><span class=\"line\">解释 payload data 的类型，如果收到识别不了的opcode，直接断开。分类值如下： %x0：连续的帧 %x1：text帧 %x2：binary帧 %x3 - 7：为非控制帧而预留的 %x8：关闭握手帧 %x9：ping帧 %xA：pong帧 %xB - F：为非控制帧而预留的</span><br><span class=\"line\"></span><br><span class=\"line\">* MASK：1 bit</span><br><span class=\"line\">标识 Payload data 是否经过掩码处理，如果是 1，Masking-key域的数据即为掩码密钥，用于解码Payload data。协议规定客户端数据需要进行掩码处理，所以此位为1</span><br><span class=\"line\"></span><br><span class=\"line\">* Payload len：7 bit | 7+16 bit | 7+64 bit</span><br><span class=\"line\">表示了 “有效负荷数据 Payload data”，以字节为单位： - 如果是 0~125，那么就直接表示了 payload 长度 - 如果是 126，那么 先存储 0x7E（=126）接下来的两个字节表示的 16位无符号整型数的值就是 payload 长度 - 如果是 127，那么 先存储 0x7E（=126）接下来的八个字节表示的 64位无符号整型数的值就是 payload 长度</span><br><span class=\"line\"></span><br><span class=\"line\">* Masking-key：0 | 4 bytes 掩码密钥，所有从客户端发送到服务端的帧都包含一个 32bits 的掩码（如果mask被设置成1），否则为0。一旦掩码被设置，所有接收到的 payload data 都必须与该值以一种算法做异或运算来获取真实值。</span><br><span class=\"line\">ws协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法，那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）</span><br><span class=\"line\">答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题</span><br><span class=\"line\"></span><br><span class=\"line\">* Payload data：(x+y) bytes</span><br><span class=\"line\">它是 Extension data 和 Application data 数据的总和，但是一般扩展数据为空。</span><br><span class=\"line\"></span><br><span class=\"line\">* Extension data：x bytes</span><br><span class=\"line\">除非扩展被定义，否则就是0</span><br><span class=\"line\"></span><br><span class=\"line\">* Application data：y bytes</span><br><span class=\"line\">占据 Extension data 后面的所有空间</span><br><span class=\"line\"></span><br><span class=\"line\">一个简易的解密方法</span><br><span class=\"line\">```vue</span><br><span class=\"line\">function decodeDataFrame2(buffer) &#123;</span><br><span class=\"line\">  const frame = &#123;&#125;;</span><br><span class=\"line\">  let start = 0;</span><br><span class=\"line\">  frame.FIN = buffer[ start ] &gt;&gt; 7;</span><br><span class=\"line\">  frame.Qpcode = buffer[ start++ ] &amp; 0b1111; // opcode占四个二进制，进行与运算来获取opcode的值</span><br><span class=\"line\">  frame.Mask = buffer[ start ] &gt;&gt; 7;</span><br><span class=\"line\">  frame.PayloadLength = buffer[ start++ ] &amp; 0b1111111; // 获取payload len，由于payload len的存储占7个二进制</span><br><span class=\"line\"></span><br><span class=\"line\">  if (!frame.FIN) &#123;</span><br><span class=\"line\">    // 表示为终结</span><br><span class=\"line\">    return false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  let s = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (frame.PayloadLength == 126) &#123;</span><br><span class=\"line\">    // 表示后面的两个字节来储存储存数据长度</span><br><span class=\"line\">    // frame.PayloadLength = buffer.readUInt16BE(2);</span><br><span class=\"line\">    frame.PayloadLength = (buffer[ start++ ] &lt;&lt; 8) + buffer[ start++ ];</span><br><span class=\"line\">  &#125; else if (frame.PayloadLength == 127) &#123;</span><br><span class=\"line\">    // 则用后面四个字节来储存数据长度</span><br><span class=\"line\">    // frame.PayloadLength = buffer.readUInt16BE(4);</span><br><span class=\"line\">    frame.PayloadLength = (buffer[ start++ ] &lt;&lt; (8 * 3)) + (buffer[ start++ ] &lt;&lt; (8 * 2)) + (buffer[ start++ ] &lt;&lt; 8) + buffer[ start++ ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (frame.Mask) &#123;</span><br><span class=\"line\">    frame.MaskingKey = [buffer[ start++ ], buffer[ start++ ], buffer[ start++ ], buffer[ start++ ]];</span><br><span class=\"line\">    s = []</span><br><span class=\"line\">    for (let i = 0; i &lt; frame.PayloadLength; i++) &#123;</span><br><span class=\"line\">      s.push( buffer[start + i] ^= frame.MaskingKey[i % 4]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    s = buffer.slice(start, frame.PayloadLength)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  s = Buffer.from(s)</span><br><span class=\"line\">  frame.PayloadData = s</span><br><span class=\"line\">  return frame</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"报文发送的加密方法（使用的nodejs-websocket）\"><a href=\"#报文发送的加密方法（使用的nodejs-websocket）\" class=\"headerlink\" title=\"报文发送的加密方法（使用的nodejs-websocket）\"></a>报文发送的加密方法（使用的nodejs-websocket）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createTextFrame (data, masked) &#123;</span><br><span class=\"line\">\tvar payload, meta</span><br><span class=\"line\"></span><br><span class=\"line\">\tpayload = Buffer.from(data)</span><br><span class=\"line\">\tmeta = generateMetaData(true, 1, masked === undefined ? false : masked, payload)</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn Buffer.concat([meta, payload], meta.length + payload.length)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function generateMetaData(fin, opcode, masked, payload) &#123;</span><br><span class=\"line\">\tvar len, meta, start, mask, i</span><br><span class=\"line\"></span><br><span class=\"line\">\tlen = payload.length</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Creates the buffer for meta-data</span><br><span class=\"line\">\tmeta = Buffer.alloc(2 + (len &lt; 126 ? 0 : (len &lt; 65536 ? 2 : 8)) + (masked ? 4 : 0))</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Sets fin and opcode</span><br><span class=\"line\">\tmeta[0] = (fin ? 128 : 0) + opcode</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Sets the mask and length</span><br><span class=\"line\">\tmeta[1] = masked ? 128 : 0</span><br><span class=\"line\">\tstart = 2</span><br><span class=\"line\">\tif (len &lt; 126) &#123;</span><br><span class=\"line\">\t\tmeta[1] += len</span><br><span class=\"line\">\t&#125; else if (len &lt; 65536) &#123;</span><br><span class=\"line\">\t\tmeta[1] += 126</span><br><span class=\"line\">\t\tmeta.writeUInt16BE(len, 2)</span><br><span class=\"line\">\t\tstart += 2</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\t// Warning: JS doesn&apos;t support integers greater than 2^53</span><br><span class=\"line\">\t\tmeta[1] += 127</span><br><span class=\"line\">\t\tmeta.writeUInt32BE(Math.floor(len / Math.pow(2, 32)), 2)</span><br><span class=\"line\">\t\tmeta.writeUInt32BE(len % Math.pow(2, 32), 6)</span><br><span class=\"line\">\t\tstart += 8</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Set the mask-key</span><br><span class=\"line\">\tif (masked) &#123;</span><br><span class=\"line\">\t\tmask = Buffer.alloc(4)</span><br><span class=\"line\">\t\tfor (i = 0; i &lt; 4; i++) &#123;</span><br><span class=\"line\">\t\t\tmeta[start + i] = mask[i] = Math.floor(Math.random() * 256)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor (i = 0; i &lt; payload.length; i++) &#123;</span><br><span class=\"line\">\t\t\tpayload[i] ^= mask[i % 4]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstart += 4</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn meta</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}