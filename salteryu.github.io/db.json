{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/simple-compiler.md","hash":"3eb673beba6f3c27680675def796af19bcce0edf","modified":1553135977031},{"_id":"source/_posts/publish-subscribe.md","hash":"8b1fa23bc96f14e2cadbe0505dc32500d95acbf6","modified":1552891984917},{"_id":"source/.DS_Store","hash":"283f8362195946f6fad7e1a75f425e32f9407509","modified":1543561873917},{"_id":"source/_posts/simpe-webpack-project.md","hash":"a5f7cbddc342a0f7c0b2ca9075ecdad763641178","modified":1543220964040},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1543197908975},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1543197908975},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1543197908975},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1543197908975},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1543197908975},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1543197908975},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1543197908984},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1543197908976},{"_id":"themes/yilia/_config.yml","hash":"b7e9579a5c3bf47827c98df1a99626302e51dafb","modified":1543199905953},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1543197909000},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"1efc9d034adf6456e816fcbb20023807ca64bbd0","modified":1543197950913},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1543197908969},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1543197950928},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1543197908971},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1543197895662},{"_id":"themes/yilia/.git/packed-refs","hash":"76b1aa9479dd3de329935b6d94a6624c5f716d23","modified":1543197908967},{"_id":"themes/yilia/.git/index","hash":"756bcf7a7ba057a903cd8adc8e40b68e0f758c05","modified":1548323096031},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1543197908998},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1543197909000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1543197908976},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1543197908984},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1543197908976},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1543197908995},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1543197908976},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1543197908976},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1543197908977},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1543197908977},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1543197908977},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1543197908983},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1543197908983},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1543197908983},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1543197908983},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1543197908983},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1543197908984},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1543197908983},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1543197908999},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1543197908999},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543197908982},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1543197895662},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1543197895663},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1543197895663},{"_id":"themes/yilia/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1543197895663},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1543197895663},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1543197895662},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1543197895664},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1543197895662},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1543197895663},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1543197895663},{"_id":"themes/yilia/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1543197895662},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1543197895664},{"_id":"themes/yilia/.git/logs/HEAD","hash":"0b830739ac86a8d49677baaef9ae75ddee73b0a9","modified":1543197908970},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1543197908995},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1543197908995},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1543197908996},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1543197908996},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1543197908996},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1543197908997},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1543197908997},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1543197908997},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1543197908997},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1543197908993},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1543197908993},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1543197908993},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1543197908993},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1543197908994},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1543197908994},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1543197908994},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1543197908994},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1543197908994},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1543197908995},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1543197908994},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1543197908984},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1543197908984},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1543197908985},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1543197908985},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1543197908985},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1543197908986},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1543197908985},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1543197908986},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1543197908986},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1543197908988},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1543197908989},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1543197908989},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1543197908990},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1543197908991},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1543197908990},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1543197908990},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1543197908991},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1543197908991},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1543197908991},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1543197908992},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1543197908991},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1543197908991},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1543197908992},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1543197908992},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1543197908991},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1543197908992},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1543197908992},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1543197908977},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1543197908977},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1543197908977},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1543197908977},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1543197908979},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1543197908979},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1543197908979},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1543197908982},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1543197908982},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1543197908981},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1543197908970},{"_id":"themes/yilia/.git/objects/pack/pack-e80aef7d429734463d7865be31d8565b074a70db.idx","hash":"5f656732dcf155a47e724683b6040f93ae7ac424","modified":1543197908957},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1543197908993},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1543197908986},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1543197908986},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1543197908987},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1543197908987},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1543197908987},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1543197908988},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1543197908989},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1543197908989},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1543197908988},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1543197908990},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1543197908990},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1543197908990},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1543197908979},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1543197908979},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1543197908980},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1543197908979},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1543197908980},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1543197908980},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1543197908980},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1543197908980},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1543197908980},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1543197908980},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"0b830739ac86a8d49677baaef9ae75ddee73b0a9","modified":1543197908970},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1543197908969},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"0b830739ac86a8d49677baaef9ae75ddee73b0a9","modified":1543197908968},{"_id":"themes/yilia/.git/objects/pack/pack-e80aef7d429734463d7865be31d8565b074a70db.pack","hash":"67a497b02625ce73eb3ffc1005f28427dce53688","modified":1543197908956},{"_id":"public/2019/03/21/simple-compiler/index.html","hash":"4743244ad3dd39dcc3ea91f372a5cbbed791c889","modified":1553136009684},{"_id":"public/2019/03/18/publish-subscribe/index.html","hash":"c8633cc4ae80c87ad40f4731dbc9e55ab2517496","modified":1553136009684},{"_id":"public/2018/11/26/simpe-webpack-project/index.html","hash":"4874ae77d0fcd370ebb784e0cd743fa0fb17dbe5","modified":1553136009703},{"_id":"public/archives/index.html","hash":"f6d42861779e72770f44839d3a7f5df6c36bd079","modified":1553136009703},{"_id":"public/archives/2018/index.html","hash":"8e60b95bbce434ea9bdff6da19c399692c9819f6","modified":1553136009705},{"_id":"public/archives/2018/11/index.html","hash":"974252def091f42f1a431549a821f5cd2393227b","modified":1553136009705},{"_id":"public/archives/2019/index.html","hash":"f178b748bc128d092d2d911471a7c727a3b7cc24","modified":1553136009705},{"_id":"public/archives/2019/03/index.html","hash":"3bbf7ea913636f577c449b4487b019fa10a98e14","modified":1553136009705},{"_id":"public/index.html","hash":"e0082c8a5fb14b54c2a67de953fa412f213dd4eb","modified":1553136009708},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1553136009708},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1553136009708},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1553136009708},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1553136009708},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1553136009708},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1553136009708},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1553136009709},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1553136009709},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1553136009709},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1553136009722},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1553136009722},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1553136009723},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1553136009726}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"AST入门","date":"2019-03-21T02:39:37.031Z","_content":"\n\n前言\n===\n\n<a href=\"https://astexplorer.net/\">AST Explore，可视化工具</a>\n\n现如今，许多各式各样的框架诞生，特别是多端生成的解决方案，例如：taro，Chameleon（卡梅隆），小程序框架: mpvue，wepy。\n又或者在其他场景，如：\n1. eslint对代码错误或风格的检查，发现一些潜在的错误\n2. IDE的错误提示、格式化、高亮、自动补全等.\n3. UglifyJS压缩代码.\n4. 代码打包工具webpack。\n\n万变不离其宗，都是站在AST这个巨人的肩膀上。\n且对于体力型的，或者重复性的工作，能用工具化，流程化解决就用他们解决。\n\n在了解编译器之前，了解一下babel的编译过程。<a href=\"https://yq.aliyun.com/articles/62671\">(来源)</a>\n\n![来源](https://user-gold-cdn.xitu.io/2018/12/24/167dfa8949b0401a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n<!--more-->\n\n\n## 什么是编译器\n\n编译器：能够把一种语言等价得转换为另一种目标语言。从现代高级编译器的角度讲，源语言是高级程序设计语言，\n容易阅读与编写，而目标语言是机器语言，即二进制代码，能够被计算机直接识别。\n语言系统的处理角度来看，由源程序生成可执行程序的整体工作流程如下所示。\n\n源程序 -> 预处理器 -> 编译器 -> 目标程序 -> .... -> 可执行程序\n\n编译器又分为前端和后端。前端包括词法分析、语法分析、语义分析、中间代码生成，具有机器无关性，比较有代表性的工具是 Flex、Bison。\n后端包括中间代码优化、目标代码生成，具有机器相关性，比较有代表性的工具是 LLVM。\n\n具体编译原理，查看这篇文章 <a href=\"https://zhuanlan.zhihu.com/p/31096468\">前端为什么要学习编译原理</a>\n\n## 编译器的编译过程\n\n### 1.词法分析\n\n获取原始代码，称为文法，scan，进行分析，转换为词法单元。token是一个不可再分割的最小单元，每个不可分割的最小单元\n都有能被唯一识别的类型和其他附加属性，并通过一个标记器将其拆分为这些命名标记的东西。最终生成一个tokens。\n对于token的验证，可以用正则表达式，一个一个进行扫描匹配，指针不断往后移直至不满足匹配规则或达到末尾。\n这个过程会过滤换行符和空格等等\n例如：\n```vue\n   const input = '(add 2 (subtract 4 \"abc\"))'\n// 转换为\n   const tokens = [ { type: 'paren', value: '(' },\n     { type: 'name', value: 'add' },\n     { type: 'number', value: '2' },\n     { type: 'paren', value: '(' },\n     { type: 'name', value: 'subtract' },\n     { type: 'number', value: '4' },\n     { type: 'number', value: '2' },\n     { type: 'paren', value: ')' },\n     { type: 'paren', value: ')' } ]\n```\n\n### 2.语法分析\n根据token的标记，逐个读入token，使用深度优先遍历并将其重新格式化为描述语法各个部分及其相互关系的表示形式，称为AST。\n遇到起始符号，如\"<\", \"(\", \"{\" 等，嵌套递归，直到遇到终结符号，退出遍历。\n这是一个深度嵌套的对象，以一种即方便使用又能提供大量信息的方式来表示的代码。\n例如:\n```vue\nconst ast = {\n  type: 'Program',\n  body: [{\n    type: 'CallExpression',\n    name: 'add',\n    params: [{\n      type: 'NumberLiteral',\n      value: '2'\n    }, {\n      type: 'CallExpression',\n      name: 'subtract',\n      params: [{\n        type: 'NumberLiteral',\n        value: '4'\n      }, {\n        type: 'NumberLiteral',\n        value: '2'\n      }]\n    }]\n  }]\n}\n```\n\n### 3.语义分析（转换）\n这个阶段是编译器对上一个AST进行转换，它可以用一种语言操作AST, 也可以翻译成全新的语言。在这个过程中，\n我们可以通过 添加/删除/替换属性来操作节点。并基于它创造一个新的AST。例如可以把wx全转为swan等等，或者\n在原先的代码基础上添加目标结果的一些特性。\n完成上述功能，必须通过递归进行遍历每一层。由于仅仅只需要访问每一个节点就足够了，因此利用visitor就可以解决这个问题。\n当遇到匹配类型的节点时，我们只需要调用对应visitor中的方法就可以解决问题。\nvisitor的方法可能如下：\n```vue\nvar visitor = {\n  NumberLiteral(node, parent) {},\n  CallExpression(node, parent) {},\n  ...\n};\n```\n但如果需要在离开当前节点的时候做一些操作呢？\n我们可以更新下visitor方法，如下所示:\n```vue\nconst visitor = {\n    NumberLiteral: {\n      enter(node, parent) {\n        parent._context.push({\n          type: 'NumberLiteral',\n          value: node.value\n        })\n      },\n      exit(node, parent) {\n         // do something\n      }\n    },\n    StringLiteral: {\n      enter(node, parent) {\n        parent._context.push({\n          type: 'StringLiteral',\n          value: node.value\n        })\n      }\n    },\n    ...\n  }\n```\n\n有了visitor对象，就可以在traverseNode（转换节点）的过程中, 对特定的节点进行转换操作，并做一些其他事情。\n具体流程如下：\n\n- → Program (enter)\n  - → CallExpression (enter)\n     - → NumberLiteral (enter)\n     - ← NumberLiteral (exit)\n     - → CallExpression (enter)\n       - → NumberLiteral (enter)\n       - ← NumberLiteral (exit)\n       - → NumberLiteral (enter)\n       - ← NumberLiteral (exit)\n     - ← CallExpression (exit)\n  - ← CallExpression (exit)\n- ← Program (exit)\n\n### 4. 代码生成\n\n代码生成器应当知道如何打印AST的所有不同类型的节点，并且递归调用来打印嵌套节点，直到生成最终代码。\n\n## 制作一个babel插件\n\n由于小程序开发比较多，有接触百度小程序和微信小程序等等，肯定会面临一个转换的问题，如 wx => swan 等。\n这里就尝试做一个类似的插件。\n\n### 1. 创建基础结构（插件的基础）\n```vue\nconst babel = require('babel-core');\n\n// 输入的文法\nconst input = `\nfunction test() {\n  wx.showModal({\n    title: \"modal\",\n    content: 'content'\n  })\n}\n`\n\n// 需要做的插件功能\nconst plugin = ({types: t}) => {\n  return {\n    visitor: {\n    }\n  }\n}\n\n// 利用插件\nconst res = babel.transform(input, {\n  plugins: [plugin]\n})\n\nconsole.log(res.code)\n```\n\n### 2. 使用https://astexplorer.net/ 进行AST分析。\n如图所示：\n![](https://img4.tuhu.org/PeccancyCheXingYi/Fi-8bDBlO2XddekCkb9NTbL1eXv3_w649_h800.jpeg@100Q.jpg)\n\n由于需要做的是 wx => swan, 因此要找到wx这个文法对应的表达式，这里找到的是 \"callee： MemberExpression\"， 然后修改plugin代码\n```vue\nconst plugin = ({types: t}) => {\n  return {\n    visitor: {\n      MemberExpression: {\n        enter(path, state) {\n          const node = path.node\n          const object = node.object\n          if (t.isMemberExpression(node) && t.isIdentifier(object, {name: 'wx'})) {\n            path.traverse({\n              Identifier(path) {\n                if (path.node.name === 'wx') {\n                  path.node.name = 'swan'\n                }\n              }\n            })\n          }\n        }\n      }\n    }\n  }\n}\n```\n其中 types 其实就是 babel.types这个库，在这里作为plugin会在回调的时候会把babel作为参数传入, 然后进行解构。\n可使用 types 来生成一个AST节点，或者来做浅层判断\n使用types.numericLiteral() 来生成一个数字类型的节点。\n使用types.isNumericLiteral() 来判断当前节点的name值是否为数字。\n\n在visitor中，path就是指当前访问者访问的节点。该对象下有许多属性和方法，例如\n```vue\n── 属性      \n  - node   当前节点\n  - parent  父节点\n  - parentPath 父path\n  - scope   作用域\n  - context  上下文\n  - ...\n── 方法\n  - get   当前节点\n  - findParent  向父节点搜寻节点\n  - getSibling 获取兄弟节点\n  - replaceWith  用AST节点替换该节点\n  - replaceWithSourceString  用资源字符串来代替这个节点，会在内部自动生成一个节点\n  - replaceWithMultiple 用多个AST节点替换该节点\n  - insertBefore  在节点前插入节点\n  - insertAfter 在节点后插入节点\n  - remove   删除节点\n  - ...\n```\n具体的可以查看babel-traverse\n\n### 3.执行插件\n\n结果为: \n```vue\nfunction test() {\n  swan.showModal({\n    title: \"modal\",\n    content: 'content'\n  });\n}\n```\n\n具体代码：\n<a href=\"https://github.com/SalterYu/MyBlog/blob/master/simple-bundler/babel-use/wx2swan.js\">wx2swan.js</a>\n<a href=\"https://github.com/SalterYu/MyBlog/tree/master/simple-compiler\">简易编译器</a>\n\n### 结尾\n分享几篇文章：\n- <a href=\"https://juejin.im/post/5c21b584e51d4548ac6f6c99\">Babel的深入了解</a> \n- <a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-writing-your-first-babel-plugin\">Babel插件手册</a> \n","source":"_posts/simple-compiler.md","raw":"---\ntitle: AST入门\ndate: 2019年03月18日\n---\n\n\n前言\n===\n\n<a href=\"https://astexplorer.net/\">AST Explore，可视化工具</a>\n\n现如今，许多各式各样的框架诞生，特别是多端生成的解决方案，例如：taro，Chameleon（卡梅隆），小程序框架: mpvue，wepy。\n又或者在其他场景，如：\n1. eslint对代码错误或风格的检查，发现一些潜在的错误\n2. IDE的错误提示、格式化、高亮、自动补全等.\n3. UglifyJS压缩代码.\n4. 代码打包工具webpack。\n\n万变不离其宗，都是站在AST这个巨人的肩膀上。\n且对于体力型的，或者重复性的工作，能用工具化，流程化解决就用他们解决。\n\n在了解编译器之前，了解一下babel的编译过程。<a href=\"https://yq.aliyun.com/articles/62671\">(来源)</a>\n\n![来源](https://user-gold-cdn.xitu.io/2018/12/24/167dfa8949b0401a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n<!--more-->\n\n\n## 什么是编译器\n\n编译器：能够把一种语言等价得转换为另一种目标语言。从现代高级编译器的角度讲，源语言是高级程序设计语言，\n容易阅读与编写，而目标语言是机器语言，即二进制代码，能够被计算机直接识别。\n语言系统的处理角度来看，由源程序生成可执行程序的整体工作流程如下所示。\n\n源程序 -> 预处理器 -> 编译器 -> 目标程序 -> .... -> 可执行程序\n\n编译器又分为前端和后端。前端包括词法分析、语法分析、语义分析、中间代码生成，具有机器无关性，比较有代表性的工具是 Flex、Bison。\n后端包括中间代码优化、目标代码生成，具有机器相关性，比较有代表性的工具是 LLVM。\n\n具体编译原理，查看这篇文章 <a href=\"https://zhuanlan.zhihu.com/p/31096468\">前端为什么要学习编译原理</a>\n\n## 编译器的编译过程\n\n### 1.词法分析\n\n获取原始代码，称为文法，scan，进行分析，转换为词法单元。token是一个不可再分割的最小单元，每个不可分割的最小单元\n都有能被唯一识别的类型和其他附加属性，并通过一个标记器将其拆分为这些命名标记的东西。最终生成一个tokens。\n对于token的验证，可以用正则表达式，一个一个进行扫描匹配，指针不断往后移直至不满足匹配规则或达到末尾。\n这个过程会过滤换行符和空格等等\n例如：\n```vue\n   const input = '(add 2 (subtract 4 \"abc\"))'\n// 转换为\n   const tokens = [ { type: 'paren', value: '(' },\n     { type: 'name', value: 'add' },\n     { type: 'number', value: '2' },\n     { type: 'paren', value: '(' },\n     { type: 'name', value: 'subtract' },\n     { type: 'number', value: '4' },\n     { type: 'number', value: '2' },\n     { type: 'paren', value: ')' },\n     { type: 'paren', value: ')' } ]\n```\n\n### 2.语法分析\n根据token的标记，逐个读入token，使用深度优先遍历并将其重新格式化为描述语法各个部分及其相互关系的表示形式，称为AST。\n遇到起始符号，如\"<\", \"(\", \"{\" 等，嵌套递归，直到遇到终结符号，退出遍历。\n这是一个深度嵌套的对象，以一种即方便使用又能提供大量信息的方式来表示的代码。\n例如:\n```vue\nconst ast = {\n  type: 'Program',\n  body: [{\n    type: 'CallExpression',\n    name: 'add',\n    params: [{\n      type: 'NumberLiteral',\n      value: '2'\n    }, {\n      type: 'CallExpression',\n      name: 'subtract',\n      params: [{\n        type: 'NumberLiteral',\n        value: '4'\n      }, {\n        type: 'NumberLiteral',\n        value: '2'\n      }]\n    }]\n  }]\n}\n```\n\n### 3.语义分析（转换）\n这个阶段是编译器对上一个AST进行转换，它可以用一种语言操作AST, 也可以翻译成全新的语言。在这个过程中，\n我们可以通过 添加/删除/替换属性来操作节点。并基于它创造一个新的AST。例如可以把wx全转为swan等等，或者\n在原先的代码基础上添加目标结果的一些特性。\n完成上述功能，必须通过递归进行遍历每一层。由于仅仅只需要访问每一个节点就足够了，因此利用visitor就可以解决这个问题。\n当遇到匹配类型的节点时，我们只需要调用对应visitor中的方法就可以解决问题。\nvisitor的方法可能如下：\n```vue\nvar visitor = {\n  NumberLiteral(node, parent) {},\n  CallExpression(node, parent) {},\n  ...\n};\n```\n但如果需要在离开当前节点的时候做一些操作呢？\n我们可以更新下visitor方法，如下所示:\n```vue\nconst visitor = {\n    NumberLiteral: {\n      enter(node, parent) {\n        parent._context.push({\n          type: 'NumberLiteral',\n          value: node.value\n        })\n      },\n      exit(node, parent) {\n         // do something\n      }\n    },\n    StringLiteral: {\n      enter(node, parent) {\n        parent._context.push({\n          type: 'StringLiteral',\n          value: node.value\n        })\n      }\n    },\n    ...\n  }\n```\n\n有了visitor对象，就可以在traverseNode（转换节点）的过程中, 对特定的节点进行转换操作，并做一些其他事情。\n具体流程如下：\n\n- → Program (enter)\n  - → CallExpression (enter)\n     - → NumberLiteral (enter)\n     - ← NumberLiteral (exit)\n     - → CallExpression (enter)\n       - → NumberLiteral (enter)\n       - ← NumberLiteral (exit)\n       - → NumberLiteral (enter)\n       - ← NumberLiteral (exit)\n     - ← CallExpression (exit)\n  - ← CallExpression (exit)\n- ← Program (exit)\n\n### 4. 代码生成\n\n代码生成器应当知道如何打印AST的所有不同类型的节点，并且递归调用来打印嵌套节点，直到生成最终代码。\n\n## 制作一个babel插件\n\n由于小程序开发比较多，有接触百度小程序和微信小程序等等，肯定会面临一个转换的问题，如 wx => swan 等。\n这里就尝试做一个类似的插件。\n\n### 1. 创建基础结构（插件的基础）\n```vue\nconst babel = require('babel-core');\n\n// 输入的文法\nconst input = `\nfunction test() {\n  wx.showModal({\n    title: \"modal\",\n    content: 'content'\n  })\n}\n`\n\n// 需要做的插件功能\nconst plugin = ({types: t}) => {\n  return {\n    visitor: {\n    }\n  }\n}\n\n// 利用插件\nconst res = babel.transform(input, {\n  plugins: [plugin]\n})\n\nconsole.log(res.code)\n```\n\n### 2. 使用https://astexplorer.net/ 进行AST分析。\n如图所示：\n![](https://img4.tuhu.org/PeccancyCheXingYi/Fi-8bDBlO2XddekCkb9NTbL1eXv3_w649_h800.jpeg@100Q.jpg)\n\n由于需要做的是 wx => swan, 因此要找到wx这个文法对应的表达式，这里找到的是 \"callee： MemberExpression\"， 然后修改plugin代码\n```vue\nconst plugin = ({types: t}) => {\n  return {\n    visitor: {\n      MemberExpression: {\n        enter(path, state) {\n          const node = path.node\n          const object = node.object\n          if (t.isMemberExpression(node) && t.isIdentifier(object, {name: 'wx'})) {\n            path.traverse({\n              Identifier(path) {\n                if (path.node.name === 'wx') {\n                  path.node.name = 'swan'\n                }\n              }\n            })\n          }\n        }\n      }\n    }\n  }\n}\n```\n其中 types 其实就是 babel.types这个库，在这里作为plugin会在回调的时候会把babel作为参数传入, 然后进行解构。\n可使用 types 来生成一个AST节点，或者来做浅层判断\n使用types.numericLiteral() 来生成一个数字类型的节点。\n使用types.isNumericLiteral() 来判断当前节点的name值是否为数字。\n\n在visitor中，path就是指当前访问者访问的节点。该对象下有许多属性和方法，例如\n```vue\n── 属性      \n  - node   当前节点\n  - parent  父节点\n  - parentPath 父path\n  - scope   作用域\n  - context  上下文\n  - ...\n── 方法\n  - get   当前节点\n  - findParent  向父节点搜寻节点\n  - getSibling 获取兄弟节点\n  - replaceWith  用AST节点替换该节点\n  - replaceWithSourceString  用资源字符串来代替这个节点，会在内部自动生成一个节点\n  - replaceWithMultiple 用多个AST节点替换该节点\n  - insertBefore  在节点前插入节点\n  - insertAfter 在节点后插入节点\n  - remove   删除节点\n  - ...\n```\n具体的可以查看babel-traverse\n\n### 3.执行插件\n\n结果为: \n```vue\nfunction test() {\n  swan.showModal({\n    title: \"modal\",\n    content: 'content'\n  });\n}\n```\n\n具体代码：\n<a href=\"https://github.com/SalterYu/MyBlog/blob/master/simple-bundler/babel-use/wx2swan.js\">wx2swan.js</a>\n<a href=\"https://github.com/SalterYu/MyBlog/tree/master/simple-compiler\">简易编译器</a>\n\n### 结尾\n分享几篇文章：\n- <a href=\"https://juejin.im/post/5c21b584e51d4548ac6f6c99\">Babel的深入了解</a> \n- <a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-writing-your-first-babel-plugin\">Babel插件手册</a> \n","slug":"simple-compiler","published":1,"updated":"2019-03-21T02:39:37.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjti12udi00008nwkgna2snff","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p><a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener\">AST Explore，可视化工具</a></p>\n<p>现如今，许多各式各样的框架诞生，特别是多端生成的解决方案，例如：taro，Chameleon（卡梅隆），小程序框架: mpvue，wepy。<br>又或者在其他场景，如：</p>\n<ol>\n<li>eslint对代码错误或风格的检查，发现一些潜在的错误</li>\n<li>IDE的错误提示、格式化、高亮、自动补全等.</li>\n<li>UglifyJS压缩代码.</li>\n<li>代码打包工具webpack。</li>\n</ol>\n<p>万变不离其宗，都是站在AST这个巨人的肩膀上。<br>且对于体力型的，或者重复性的工作，能用工具化，流程化解决就用他们解决。</p>\n<p>在了解编译器之前，了解一下babel的编译过程。<a href=\"https://yq.aliyun.com/articles/62671\" target=\"_blank\" rel=\"noopener\">(来源)</a></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/24/167dfa8949b0401a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"来源\"><br><a id=\"more\"></a></p>\n<h2 id=\"什么是编译器\"><a href=\"#什么是编译器\" class=\"headerlink\" title=\"什么是编译器\"></a>什么是编译器</h2><p>编译器：能够把一种语言等价得转换为另一种目标语言。从现代高级编译器的角度讲，源语言是高级程序设计语言，<br>容易阅读与编写，而目标语言是机器语言，即二进制代码，能够被计算机直接识别。<br>语言系统的处理角度来看，由源程序生成可执行程序的整体工作流程如下所示。</p>\n<p>源程序 -&gt; 预处理器 -&gt; 编译器 -&gt; 目标程序 -&gt; …. -&gt; 可执行程序</p>\n<p>编译器又分为前端和后端。前端包括词法分析、语法分析、语义分析、中间代码生成，具有机器无关性，比较有代表性的工具是 Flex、Bison。<br>后端包括中间代码优化、目标代码生成，具有机器相关性，比较有代表性的工具是 LLVM。</p>\n<p>具体编译原理，查看这篇文章 <a href=\"https://zhuanlan.zhihu.com/p/31096468\" target=\"_blank\" rel=\"noopener\">前端为什么要学习编译原理</a></p>\n<h2 id=\"编译器的编译过程\"><a href=\"#编译器的编译过程\" class=\"headerlink\" title=\"编译器的编译过程\"></a>编译器的编译过程</h2><h3 id=\"1-词法分析\"><a href=\"#1-词法分析\" class=\"headerlink\" title=\"1.词法分析\"></a>1.词法分析</h3><p>获取原始代码，称为文法，scan，进行分析，转换为词法单元。token是一个不可再分割的最小单元，每个不可分割的最小单元<br>都有能被唯一识别的类型和其他附加属性，并通过一个标记器将其拆分为这些命名标记的东西。最终生成一个tokens。<br>对于token的验证，可以用正则表达式，一个一个进行扫描匹配，指针不断往后移直至不满足匹配规则或达到末尾。<br>这个过程会过滤换行符和空格等等<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const input = &apos;(add 2 (subtract 4 &quot;abc&quot;))&apos;</span><br><span class=\"line\">// 转换为</span><br><span class=\"line\">   const tokens = [ &#123; type: &apos;paren&apos;, value: &apos;(&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;name&apos;, value: &apos;add&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;number&apos;, value: &apos;2&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;paren&apos;, value: &apos;(&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;name&apos;, value: &apos;subtract&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;number&apos;, value: &apos;4&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;number&apos;, value: &apos;2&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;paren&apos;, value: &apos;)&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;paren&apos;, value: &apos;)&apos; &#125; ]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-语法分析\"><a href=\"#2-语法分析\" class=\"headerlink\" title=\"2.语法分析\"></a>2.语法分析</h3><p>根据token的标记，逐个读入token，使用深度优先遍历并将其重新格式化为描述语法各个部分及其相互关系的表示形式，称为AST。<br>遇到起始符号，如”&lt;”, “(“, “{“ 等，嵌套递归，直到遇到终结符号，退出遍历。<br>这是一个深度嵌套的对象，以一种即方便使用又能提供大量信息的方式来表示的代码。<br>例如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ast = &#123;</span><br><span class=\"line\">  type: &apos;Program&apos;,</span><br><span class=\"line\">  body: [&#123;</span><br><span class=\"line\">    type: &apos;CallExpression&apos;,</span><br><span class=\"line\">    name: &apos;add&apos;,</span><br><span class=\"line\">    params: [&#123;</span><br><span class=\"line\">      type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">      value: &apos;2&apos;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      type: &apos;CallExpression&apos;,</span><br><span class=\"line\">      name: &apos;subtract&apos;,</span><br><span class=\"line\">      params: [&#123;</span><br><span class=\"line\">        type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">        value: &apos;4&apos;</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">        value: &apos;2&apos;</span><br><span class=\"line\">      &#125;]</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-语义分析（转换）\"><a href=\"#3-语义分析（转换）\" class=\"headerlink\" title=\"3.语义分析（转换）\"></a>3.语义分析（转换）</h3><p>这个阶段是编译器对上一个AST进行转换，它可以用一种语言操作AST, 也可以翻译成全新的语言。在这个过程中，<br>我们可以通过 添加/删除/替换属性来操作节点。并基于它创造一个新的AST。例如可以把wx全转为swan等等，或者<br>在原先的代码基础上添加目标结果的一些特性。<br>完成上述功能，必须通过递归进行遍历每一层。由于仅仅只需要访问每一个节点就足够了，因此利用visitor就可以解决这个问题。<br>当遇到匹配类型的节点时，我们只需要调用对应visitor中的方法就可以解决问题。<br>visitor的方法可能如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var visitor = &#123;</span><br><span class=\"line\">  NumberLiteral(node, parent) &#123;&#125;,</span><br><span class=\"line\">  CallExpression(node, parent) &#123;&#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>但如果需要在离开当前节点的时候做一些操作呢？<br>我们可以更新下visitor方法，如下所示:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const visitor = &#123;</span><br><span class=\"line\">    NumberLiteral: &#123;</span><br><span class=\"line\">      enter(node, parent) &#123;</span><br><span class=\"line\">        parent._context.push(&#123;</span><br><span class=\"line\">          type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">          value: node.value</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      exit(node, parent) &#123;</span><br><span class=\"line\">         // do something</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    StringLiteral: &#123;</span><br><span class=\"line\">      enter(node, parent) &#123;</span><br><span class=\"line\">        parent._context.push(&#123;</span><br><span class=\"line\">          type: &apos;StringLiteral&apos;,</span><br><span class=\"line\">          value: node.value</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>有了visitor对象，就可以在traverseNode（转换节点）的过程中, 对特定的节点进行转换操作，并做一些其他事情。<br>具体流程如下：</p>\n<ul>\n<li>→ Program (enter)<ul>\n<li>→ CallExpression (enter)<ul>\n<li>→ NumberLiteral (enter)</li>\n<li>← NumberLiteral (exit)</li>\n<li>→ CallExpression (enter)<ul>\n<li>→ NumberLiteral (enter)</li>\n<li>← NumberLiteral (exit)</li>\n<li>→ NumberLiteral (enter)</li>\n<li>← NumberLiteral (exit)</li>\n</ul>\n</li>\n<li>← CallExpression (exit)</li>\n</ul>\n</li>\n<li>← CallExpression (exit)</li>\n</ul>\n</li>\n<li>← Program (exit)</li>\n</ul>\n<h3 id=\"4-代码生成\"><a href=\"#4-代码生成\" class=\"headerlink\" title=\"4. 代码生成\"></a>4. 代码生成</h3><p>代码生成器应当知道如何打印AST的所有不同类型的节点，并且递归调用来打印嵌套节点，直到生成最终代码。</p>\n<h2 id=\"制作一个babel插件\"><a href=\"#制作一个babel插件\" class=\"headerlink\" title=\"制作一个babel插件\"></a>制作一个babel插件</h2><p>由于小程序开发比较多，有接触百度小程序和微信小程序等等，肯定会面临一个转换的问题，如 wx =&gt; swan 等。<br>这里就尝试做一个类似的插件。</p>\n<h3 id=\"1-创建基础结构（插件的基础）\"><a href=\"#1-创建基础结构（插件的基础）\" class=\"headerlink\" title=\"1. 创建基础结构（插件的基础）\"></a>1. 创建基础结构（插件的基础）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const babel = require(&apos;babel-core&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输入的文法</span><br><span class=\"line\">const input = `</span><br><span class=\"line\">function test() &#123;</span><br><span class=\"line\">  wx.showModal(&#123;</span><br><span class=\"line\">    title: &quot;modal&quot;,</span><br><span class=\"line\">    content: &apos;content&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">`</span><br><span class=\"line\"></span><br><span class=\"line\">// 需要做的插件功能</span><br><span class=\"line\">const plugin = (&#123;types: t&#125;) =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    visitor: &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 利用插件</span><br><span class=\"line\">const res = babel.transform(input, &#123;</span><br><span class=\"line\">  plugins: [plugin]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(res.code)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用https-astexplorer-net-进行AST分析。\"><a href=\"#2-使用https-astexplorer-net-进行AST分析。\" class=\"headerlink\" title=\"2. 使用https://astexplorer.net/ 进行AST分析。\"></a>2. 使用<a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener\">https://astexplorer.net/</a> 进行AST分析。</h3><p>如图所示：<br><img src=\"https://img4.tuhu.org/PeccancyCheXingYi/Fi-8bDBlO2XddekCkb9NTbL1eXv3_w649_h800.jpeg@100Q.jpg\" alt=\"\"></p>\n<p>由于需要做的是 wx =&gt; swan, 因此要找到wx这个文法对应的表达式，这里找到的是 “callee： MemberExpression”， 然后修改plugin代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const plugin = (&#123;types: t&#125;) =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    visitor: &#123;</span><br><span class=\"line\">      MemberExpression: &#123;</span><br><span class=\"line\">        enter(path, state) &#123;</span><br><span class=\"line\">          const node = path.node</span><br><span class=\"line\">          const object = node.object</span><br><span class=\"line\">          if (t.isMemberExpression(node) &amp;&amp; t.isIdentifier(object, &#123;name: &apos;wx&apos;&#125;)) &#123;</span><br><span class=\"line\">            path.traverse(&#123;</span><br><span class=\"line\">              Identifier(path) &#123;</span><br><span class=\"line\">                if (path.node.name === &apos;wx&apos;) &#123;</span><br><span class=\"line\">                  path.node.name = &apos;swan&apos;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中 types 其实就是 babel.types这个库，在这里作为plugin会在回调的时候会把babel作为参数传入, 然后进行解构。<br>可使用 types 来生成一个AST节点，或者来做浅层判断<br>使用types.numericLiteral() 来生成一个数字类型的节点。<br>使用types.isNumericLiteral() 来判断当前节点的name值是否为数字。</p>\n<p>在visitor中，path就是指当前访问者访问的节点。该对象下有许多属性和方法，例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">── 属性      </span><br><span class=\"line\">  - node   当前节点</span><br><span class=\"line\">  - parent  父节点</span><br><span class=\"line\">  - parentPath 父path</span><br><span class=\"line\">  - scope   作用域</span><br><span class=\"line\">  - context  上下文</span><br><span class=\"line\">  - ...</span><br><span class=\"line\">── 方法</span><br><span class=\"line\">  - get   当前节点</span><br><span class=\"line\">  - findParent  向父节点搜寻节点</span><br><span class=\"line\">  - getSibling 获取兄弟节点</span><br><span class=\"line\">  - replaceWith  用AST节点替换该节点</span><br><span class=\"line\">  - replaceWithSourceString  用资源字符串来代替这个节点，会在内部自动生成一个节点</span><br><span class=\"line\">  - replaceWithMultiple 用多个AST节点替换该节点</span><br><span class=\"line\">  - insertBefore  在节点前插入节点</span><br><span class=\"line\">  - insertAfter 在节点后插入节点</span><br><span class=\"line\">  - remove   删除节点</span><br><span class=\"line\">  - ...</span><br></pre></td></tr></table></figure></p>\n<p>具体的可以查看babel-traverse</p>\n<h3 id=\"3-执行插件\"><a href=\"#3-执行插件\" class=\"headerlink\" title=\"3.执行插件\"></a>3.执行插件</h3><p>结果为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test() &#123;</span><br><span class=\"line\">  swan.showModal(&#123;</span><br><span class=\"line\">    title: &quot;modal&quot;,</span><br><span class=\"line\">    content: &apos;content&apos;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>具体代码：<br><a href=\"https://github.com/SalterYu/MyBlog/blob/master/simple-bundler/babel-use/wx2swan.js\" target=\"_blank\" rel=\"noopener\">wx2swan.js</a><br><a href=\"https://github.com/SalterYu/MyBlog/tree/master/simple-compiler\" target=\"_blank\" rel=\"noopener\">简易编译器</a></p>\n<h3 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h3><p>分享几篇文章：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5c21b584e51d4548ac6f6c99\" target=\"_blank\" rel=\"noopener\">Babel的深入了解</a> </li>\n<li><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-writing-your-first-babel-plugin\" target=\"_blank\" rel=\"noopener\">Babel插件手册</a> </li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p><a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener\">AST Explore，可视化工具</a></p>\n<p>现如今，许多各式各样的框架诞生，特别是多端生成的解决方案，例如：taro，Chameleon（卡梅隆），小程序框架: mpvue，wepy。<br>又或者在其他场景，如：</p>\n<ol>\n<li>eslint对代码错误或风格的检查，发现一些潜在的错误</li>\n<li>IDE的错误提示、格式化、高亮、自动补全等.</li>\n<li>UglifyJS压缩代码.</li>\n<li>代码打包工具webpack。</li>\n</ol>\n<p>万变不离其宗，都是站在AST这个巨人的肩膀上。<br>且对于体力型的，或者重复性的工作，能用工具化，流程化解决就用他们解决。</p>\n<p>在了解编译器之前，了解一下babel的编译过程。<a href=\"https://yq.aliyun.com/articles/62671\" target=\"_blank\" rel=\"noopener\">(来源)</a></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/24/167dfa8949b0401a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"来源\"><br>","more":"</p>\n<h2 id=\"什么是编译器\"><a href=\"#什么是编译器\" class=\"headerlink\" title=\"什么是编译器\"></a>什么是编译器</h2><p>编译器：能够把一种语言等价得转换为另一种目标语言。从现代高级编译器的角度讲，源语言是高级程序设计语言，<br>容易阅读与编写，而目标语言是机器语言，即二进制代码，能够被计算机直接识别。<br>语言系统的处理角度来看，由源程序生成可执行程序的整体工作流程如下所示。</p>\n<p>源程序 -&gt; 预处理器 -&gt; 编译器 -&gt; 目标程序 -&gt; …. -&gt; 可执行程序</p>\n<p>编译器又分为前端和后端。前端包括词法分析、语法分析、语义分析、中间代码生成，具有机器无关性，比较有代表性的工具是 Flex、Bison。<br>后端包括中间代码优化、目标代码生成，具有机器相关性，比较有代表性的工具是 LLVM。</p>\n<p>具体编译原理，查看这篇文章 <a href=\"https://zhuanlan.zhihu.com/p/31096468\" target=\"_blank\" rel=\"noopener\">前端为什么要学习编译原理</a></p>\n<h2 id=\"编译器的编译过程\"><a href=\"#编译器的编译过程\" class=\"headerlink\" title=\"编译器的编译过程\"></a>编译器的编译过程</h2><h3 id=\"1-词法分析\"><a href=\"#1-词法分析\" class=\"headerlink\" title=\"1.词法分析\"></a>1.词法分析</h3><p>获取原始代码，称为文法，scan，进行分析，转换为词法单元。token是一个不可再分割的最小单元，每个不可分割的最小单元<br>都有能被唯一识别的类型和其他附加属性，并通过一个标记器将其拆分为这些命名标记的东西。最终生成一个tokens。<br>对于token的验证，可以用正则表达式，一个一个进行扫描匹配，指针不断往后移直至不满足匹配规则或达到末尾。<br>这个过程会过滤换行符和空格等等<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const input = &apos;(add 2 (subtract 4 &quot;abc&quot;))&apos;</span><br><span class=\"line\">// 转换为</span><br><span class=\"line\">   const tokens = [ &#123; type: &apos;paren&apos;, value: &apos;(&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;name&apos;, value: &apos;add&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;number&apos;, value: &apos;2&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;paren&apos;, value: &apos;(&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;name&apos;, value: &apos;subtract&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;number&apos;, value: &apos;4&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;number&apos;, value: &apos;2&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;paren&apos;, value: &apos;)&apos; &#125;,</span><br><span class=\"line\">     &#123; type: &apos;paren&apos;, value: &apos;)&apos; &#125; ]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-语法分析\"><a href=\"#2-语法分析\" class=\"headerlink\" title=\"2.语法分析\"></a>2.语法分析</h3><p>根据token的标记，逐个读入token，使用深度优先遍历并将其重新格式化为描述语法各个部分及其相互关系的表示形式，称为AST。<br>遇到起始符号，如”&lt;”, “(“, “{“ 等，嵌套递归，直到遇到终结符号，退出遍历。<br>这是一个深度嵌套的对象，以一种即方便使用又能提供大量信息的方式来表示的代码。<br>例如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ast = &#123;</span><br><span class=\"line\">  type: &apos;Program&apos;,</span><br><span class=\"line\">  body: [&#123;</span><br><span class=\"line\">    type: &apos;CallExpression&apos;,</span><br><span class=\"line\">    name: &apos;add&apos;,</span><br><span class=\"line\">    params: [&#123;</span><br><span class=\"line\">      type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">      value: &apos;2&apos;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      type: &apos;CallExpression&apos;,</span><br><span class=\"line\">      name: &apos;subtract&apos;,</span><br><span class=\"line\">      params: [&#123;</span><br><span class=\"line\">        type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">        value: &apos;4&apos;</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">        value: &apos;2&apos;</span><br><span class=\"line\">      &#125;]</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-语义分析（转换）\"><a href=\"#3-语义分析（转换）\" class=\"headerlink\" title=\"3.语义分析（转换）\"></a>3.语义分析（转换）</h3><p>这个阶段是编译器对上一个AST进行转换，它可以用一种语言操作AST, 也可以翻译成全新的语言。在这个过程中，<br>我们可以通过 添加/删除/替换属性来操作节点。并基于它创造一个新的AST。例如可以把wx全转为swan等等，或者<br>在原先的代码基础上添加目标结果的一些特性。<br>完成上述功能，必须通过递归进行遍历每一层。由于仅仅只需要访问每一个节点就足够了，因此利用visitor就可以解决这个问题。<br>当遇到匹配类型的节点时，我们只需要调用对应visitor中的方法就可以解决问题。<br>visitor的方法可能如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var visitor = &#123;</span><br><span class=\"line\">  NumberLiteral(node, parent) &#123;&#125;,</span><br><span class=\"line\">  CallExpression(node, parent) &#123;&#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>但如果需要在离开当前节点的时候做一些操作呢？<br>我们可以更新下visitor方法，如下所示:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const visitor = &#123;</span><br><span class=\"line\">    NumberLiteral: &#123;</span><br><span class=\"line\">      enter(node, parent) &#123;</span><br><span class=\"line\">        parent._context.push(&#123;</span><br><span class=\"line\">          type: &apos;NumberLiteral&apos;,</span><br><span class=\"line\">          value: node.value</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      exit(node, parent) &#123;</span><br><span class=\"line\">         // do something</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    StringLiteral: &#123;</span><br><span class=\"line\">      enter(node, parent) &#123;</span><br><span class=\"line\">        parent._context.push(&#123;</span><br><span class=\"line\">          type: &apos;StringLiteral&apos;,</span><br><span class=\"line\">          value: node.value</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>有了visitor对象，就可以在traverseNode（转换节点）的过程中, 对特定的节点进行转换操作，并做一些其他事情。<br>具体流程如下：</p>\n<ul>\n<li>→ Program (enter)<ul>\n<li>→ CallExpression (enter)<ul>\n<li>→ NumberLiteral (enter)</li>\n<li>← NumberLiteral (exit)</li>\n<li>→ CallExpression (enter)<ul>\n<li>→ NumberLiteral (enter)</li>\n<li>← NumberLiteral (exit)</li>\n<li>→ NumberLiteral (enter)</li>\n<li>← NumberLiteral (exit)</li>\n</ul>\n</li>\n<li>← CallExpression (exit)</li>\n</ul>\n</li>\n<li>← CallExpression (exit)</li>\n</ul>\n</li>\n<li>← Program (exit)</li>\n</ul>\n<h3 id=\"4-代码生成\"><a href=\"#4-代码生成\" class=\"headerlink\" title=\"4. 代码生成\"></a>4. 代码生成</h3><p>代码生成器应当知道如何打印AST的所有不同类型的节点，并且递归调用来打印嵌套节点，直到生成最终代码。</p>\n<h2 id=\"制作一个babel插件\"><a href=\"#制作一个babel插件\" class=\"headerlink\" title=\"制作一个babel插件\"></a>制作一个babel插件</h2><p>由于小程序开发比较多，有接触百度小程序和微信小程序等等，肯定会面临一个转换的问题，如 wx =&gt; swan 等。<br>这里就尝试做一个类似的插件。</p>\n<h3 id=\"1-创建基础结构（插件的基础）\"><a href=\"#1-创建基础结构（插件的基础）\" class=\"headerlink\" title=\"1. 创建基础结构（插件的基础）\"></a>1. 创建基础结构（插件的基础）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const babel = require(&apos;babel-core&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输入的文法</span><br><span class=\"line\">const input = `</span><br><span class=\"line\">function test() &#123;</span><br><span class=\"line\">  wx.showModal(&#123;</span><br><span class=\"line\">    title: &quot;modal&quot;,</span><br><span class=\"line\">    content: &apos;content&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">`</span><br><span class=\"line\"></span><br><span class=\"line\">// 需要做的插件功能</span><br><span class=\"line\">const plugin = (&#123;types: t&#125;) =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    visitor: &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 利用插件</span><br><span class=\"line\">const res = babel.transform(input, &#123;</span><br><span class=\"line\">  plugins: [plugin]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(res.code)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用https-astexplorer-net-进行AST分析。\"><a href=\"#2-使用https-astexplorer-net-进行AST分析。\" class=\"headerlink\" title=\"2. 使用https://astexplorer.net/ 进行AST分析。\"></a>2. 使用<a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener\">https://astexplorer.net/</a> 进行AST分析。</h3><p>如图所示：<br><img src=\"https://img4.tuhu.org/PeccancyCheXingYi/Fi-8bDBlO2XddekCkb9NTbL1eXv3_w649_h800.jpeg@100Q.jpg\" alt=\"\"></p>\n<p>由于需要做的是 wx =&gt; swan, 因此要找到wx这个文法对应的表达式，这里找到的是 “callee： MemberExpression”， 然后修改plugin代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const plugin = (&#123;types: t&#125;) =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    visitor: &#123;</span><br><span class=\"line\">      MemberExpression: &#123;</span><br><span class=\"line\">        enter(path, state) &#123;</span><br><span class=\"line\">          const node = path.node</span><br><span class=\"line\">          const object = node.object</span><br><span class=\"line\">          if (t.isMemberExpression(node) &amp;&amp; t.isIdentifier(object, &#123;name: &apos;wx&apos;&#125;)) &#123;</span><br><span class=\"line\">            path.traverse(&#123;</span><br><span class=\"line\">              Identifier(path) &#123;</span><br><span class=\"line\">                if (path.node.name === &apos;wx&apos;) &#123;</span><br><span class=\"line\">                  path.node.name = &apos;swan&apos;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中 types 其实就是 babel.types这个库，在这里作为plugin会在回调的时候会把babel作为参数传入, 然后进行解构。<br>可使用 types 来生成一个AST节点，或者来做浅层判断<br>使用types.numericLiteral() 来生成一个数字类型的节点。<br>使用types.isNumericLiteral() 来判断当前节点的name值是否为数字。</p>\n<p>在visitor中，path就是指当前访问者访问的节点。该对象下有许多属性和方法，例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">── 属性      </span><br><span class=\"line\">  - node   当前节点</span><br><span class=\"line\">  - parent  父节点</span><br><span class=\"line\">  - parentPath 父path</span><br><span class=\"line\">  - scope   作用域</span><br><span class=\"line\">  - context  上下文</span><br><span class=\"line\">  - ...</span><br><span class=\"line\">── 方法</span><br><span class=\"line\">  - get   当前节点</span><br><span class=\"line\">  - findParent  向父节点搜寻节点</span><br><span class=\"line\">  - getSibling 获取兄弟节点</span><br><span class=\"line\">  - replaceWith  用AST节点替换该节点</span><br><span class=\"line\">  - replaceWithSourceString  用资源字符串来代替这个节点，会在内部自动生成一个节点</span><br><span class=\"line\">  - replaceWithMultiple 用多个AST节点替换该节点</span><br><span class=\"line\">  - insertBefore  在节点前插入节点</span><br><span class=\"line\">  - insertAfter 在节点后插入节点</span><br><span class=\"line\">  - remove   删除节点</span><br><span class=\"line\">  - ...</span><br></pre></td></tr></table></figure></p>\n<p>具体的可以查看babel-traverse</p>\n<h3 id=\"3-执行插件\"><a href=\"#3-执行插件\" class=\"headerlink\" title=\"3.执行插件\"></a>3.执行插件</h3><p>结果为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test() &#123;</span><br><span class=\"line\">  swan.showModal(&#123;</span><br><span class=\"line\">    title: &quot;modal&quot;,</span><br><span class=\"line\">    content: &apos;content&apos;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>具体代码：<br><a href=\"https://github.com/SalterYu/MyBlog/blob/master/simple-bundler/babel-use/wx2swan.js\" target=\"_blank\" rel=\"noopener\">wx2swan.js</a><br><a href=\"https://github.com/SalterYu/MyBlog/tree/master/simple-compiler\" target=\"_blank\" rel=\"noopener\">简易编译器</a></p>\n<h3 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h3><p>分享几篇文章：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5c21b584e51d4548ac6f6c99\" target=\"_blank\" rel=\"noopener\">Babel的深入了解</a> </li>\n<li><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-writing-your-first-babel-plugin\" target=\"_blank\" rel=\"noopener\">Babel插件手册</a> </li>\n</ul>"},{"title":"Vue原理(一)","date":"2019-03-18T06:53:04.917Z","_content":"<br/>\n\n观察者模式设计\n====\n在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。(来自wiki百科)\n\n例：小明去买房（观察者Observer），去找房产中心（目标主体Subject），发布者说等有合适的就通知小明。这样就形成了一个环\n\n发布订阅模式设计\n====\n\n在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。(来自wiki百科)\n\n例：小明去买房（订阅者Subscriber），委托第三方中介去买房（调度中心Event Channel），等待第三方中介回馈消息，过了一会房产中心（发布者Publisher）发布消息给第三方中介，第三方中介发现正好符合小明的要求（key）就去通知小明。\n\n两者区别\n====\n\n<img src=\"https://user-gold-cdn.xitu.io/2017/11/22/15fe1b1f174cd376?imageslim\" />\n\n图片来源: <a href=\"http://developers-club.com/posts/270339/\" >developers-club</a>\n\n>1. 在观察者模式中，观察者是知道主体Subject的，而Subject一直保持对观察者的记录。相反在发布订阅中，两者并不互相了解，只能通过代理进行沟通。\n>2. 观察者模式大多数是同步，如：事件触发，而发布订阅模式大多数是异步，如：消息队列。\n>3. 观察者模式是一种紧耦合状态，而发布订阅模式是一种松耦合的状态。\n>4. 观察者模式是通过主体本身去遍历观察者（维护的是观察者），然后调用订阅者的通知方法去实现。而发布订阅则是通过事件管道去通知（维护的是事件）。\n\nMVVM和MVC的区别\n====\nMVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。\n\n在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。\n\nViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\n\nVue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 \n\n<!--more-->\n\n回到Vue\n==== \n\nVue的双向绑定则是利用了观察者模式实现的。\n参考链接：https://segmentfault.com/a/1190000013338801\n\n<pre>\n<code>\nclass Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 为了标明该对象已经被observer过\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n</code>\n</pre>\n\n <pre><code>\n // 拦截数据\n export function defineReactive (\n   obj: Object,\n   key: string,\n   val: any,\n   customSetter?: ?Function,\n   shallow?: boolean\n ) {\n   const dep = new Dep()\n \n   const property = Object.getOwnPropertyDescriptor(obj, key)\n   if (property && property.configurable === false) {\n     return\n   }\n \n   // cater for pre-defined getter/setters\n   const getter = property && property.get\n   const setter = property && property.set\n   if ((!getter || setter) && arguments.length === 2) {\n     val = obj[key]\n   }\n \n   let childOb = !shallow && observe(val)\n   Object.defineProperty(obj, key, {\n     enumerable: true,\n     configurable: true,\n     get: function reactiveGetter () {\n       const value = getter ? getter.call(obj) : val\n       if (Dep.target) {\n         dep.depend()\n         if (childOb) {\n           childOb.dep.depend()\n           if (Array.isArray(value)) {\n             dependArray(value)\n           }\n         }\n       }\n       return value\n     },\n     set: function reactiveSetter (newVal) {\n       const value = getter ? getter.call(obj) : val\n       /* eslint-disable no-self-compare */\n       if (newVal === value || (newVal !== newVal && value !== value)) {\n         return\n       }\n       /* eslint-enable no-self-compare */\n       if (process.env.NODE_ENV !== 'production' && customSetter) {\n         customSetter()\n       }\n       // #7981: for accessor properties without setter\n       if (getter && !setter) return\n       if (setter) {\n         setter.call(obj, newVal)\n       } else {\n         val = newVal\n       }\n       childOb = !shallow && observe(newVal)\n       // 使当前的调度中心通知所有Watcher\n       dep.notify()\n     }\n   })\n }\n </code></pre>\n \n Vue模版渲染\n \n 在执行npm run dev或者npm run build的时候，Vue使用rollup进行编译，入口文件为entry-runtime-with-compiler.js，\n 该文件有以下代码，在runtime的时候执行\n ```vue\n // entry-runtime-with-compiler.js，\n import Vue from './runtime/index'\n ```\n ```vue\n // runtime/index.js\n import Vue from 'core/index'\n ```\n ```vue\n // core/index.js\n // 导入Vue的实例，初始化全局Api\nimport Vue from './instance/index'\nimport { initGlobalAPI } from './global-api/index'\nimport { isServerRendering } from 'core/util/env'\nimport { FunctionalRenderContext } from 'core/vdom/create-functional-component'\ninitGlobalAPI(Vue)\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n})\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n})\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n})\n\nVue.version = '__VERSION__'\n\nexport default Vue\n```\n```vue\n// instance/index.js\n// 做Vue的各种模块混\n// 每当new Vue的时候执行初始化\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n// 初始化混入 *\ninitMixin(Vue)\n\nstateMixin(Vue)\n// 事件混入\neventsMixin(Vue)\n// 生命周期的混入 *\nlifecycleMixin(Vue)\n// render函数混入 *\nrenderMixin(Vue)\n```\n```vue\n// 走进this._init(options)方法\n// 最主要的是\n// 触发Vue原型上的$mount方法，进行compile。compiler/index.js会返回render函数和sataicRenderFns函数。等待renderMixin函数的使用。\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n\n```\n在render.js的renderMixi方法中使用了以下方法\n```vue\n// core/instance/render.js文件中 line:83\n// 这里就是将template进行转换\ntry {\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n  }\n\n// render方法 ，由compiler方法返回，功能是使用with语句的作用是将代码的作用域设置到一个特定的作用域中。之后的msg的都是访问的this中的属性，而this就是\n// vm._renderProxy（vm的一个代理实例），由于Vue自己的proxy方法会将this.data.msg的值的获取改为this.msg，因此msg就变成了\n// options中的data的一个值传入。经过_c (createElement)方法完成template模版的替换。\n(function anonymous(\n) {\nwith(this){return _c('div',{attrs:{\"id\":\"el\"}},[_v(\"\\n  \"+_s(msg)+_s(msg)+\"\\n\")])}\n})\n```\n###梳理下Vue初始化流程：\n>1. 在<font color=pink size=4>new</font>实例Vue的时候，调用<font color=\"pink\" size=\"4\">this._init(options)</font>方法将传入的对象作为$options属性存在Vue实例中。并将各种组件的props，父子组件的inject属性和指令进行合并，开始走created流程。\n>2. 执行了<font color=\"pink\" size=\"4\">initState()</font>方法，对所有数据包括(props和methods)进行拦截，给数据进行observer，并且给被observer过的属性增加ob属性标识，来表示已经被observer。【数据拦截原理见上方观察者模式】\n>> <font color=\"grey\" size=2>补充:由于遍历对象的属性，则每个对象都会有一个Dep，且一个Dep可能会有许多Watcher，因为可能这个属性的值被多处使用，所以当数据改变，则遍历触发自身的所有的Watcher。即dep.notify() => Array.forEach.update</font>\n>3. 之后调用<font color=pink size=4>vm.$mount(el)</font>方法, 进行Vue的mounted。\n>4. 在这之前用一个字段mount存储目标的自定义mounted方法后调用公用的mounted方法，在mounted过程中调用<font color=pink size=4>compilerToFunctions()</font>方法返回一个render函数(一个with关键字函数，切设计虚拟DOM树)，并设置<font color=pink size=4>options.render = render</font>。\n>5. 在公用的mounted方法后有一个<font color=\"pink\" size=\"4\">return mount.call(this, el, hydrating)</font>方法，开始调用自定义的mounted方法。\n>6. 在自定义mounted方法中，调用<font color=\"pink\" size=\"4\">mountComponent()</font>完成观察者模式：实例Watcher类。\n>7. 每个Watcher类在constructor中会调用<font color=\"pink\" size=\"4\">this.value = this.lazy ? undefined : this.get()</font>, 而this.get()方法将自身依赖push给全局的targetStack数组中，并把Dep.target的指向指为当前Watcher。 当要获取属性的值的时候，相应属性自身的get方法之前，将会被之前observer数据拦截，此时Dep.target就存在值，就调用了内部的<font color=\"pink\" size=\"4\">dep.depend()</font>方法实现依赖关系，将当前Watcher放入当前Dep中，等待后期的数据更新。这样就行成了一个依赖环。\n\n最后贴一下官网的生命周期图<a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\">Vue生命周期</a>\n\nVue的详细模板编译原理<a href=\"https://github.com/berwin/Blog/issues/18\">传送门</a>\n\n\n","source":"_posts/publish-subscribe.md","raw":"---\ntitle: Vue原理(一)\ndate: 2018年11月24日\n---\n<br/>\n\n观察者模式设计\n====\n在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。(来自wiki百科)\n\n例：小明去买房（观察者Observer），去找房产中心（目标主体Subject），发布者说等有合适的就通知小明。这样就形成了一个环\n\n发布订阅模式设计\n====\n\n在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。(来自wiki百科)\n\n例：小明去买房（订阅者Subscriber），委托第三方中介去买房（调度中心Event Channel），等待第三方中介回馈消息，过了一会房产中心（发布者Publisher）发布消息给第三方中介，第三方中介发现正好符合小明的要求（key）就去通知小明。\n\n两者区别\n====\n\n<img src=\"https://user-gold-cdn.xitu.io/2017/11/22/15fe1b1f174cd376?imageslim\" />\n\n图片来源: <a href=\"http://developers-club.com/posts/270339/\" >developers-club</a>\n\n>1. 在观察者模式中，观察者是知道主体Subject的，而Subject一直保持对观察者的记录。相反在发布订阅中，两者并不互相了解，只能通过代理进行沟通。\n>2. 观察者模式大多数是同步，如：事件触发，而发布订阅模式大多数是异步，如：消息队列。\n>3. 观察者模式是一种紧耦合状态，而发布订阅模式是一种松耦合的状态。\n>4. 观察者模式是通过主体本身去遍历观察者（维护的是观察者），然后调用订阅者的通知方法去实现。而发布订阅则是通过事件管道去通知（维护的是事件）。\n\nMVVM和MVC的区别\n====\nMVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。\n\n在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。\n\nViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\n\nVue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 \n\n<!--more-->\n\n回到Vue\n==== \n\nVue的双向绑定则是利用了观察者模式实现的。\n参考链接：https://segmentfault.com/a/1190000013338801\n\n<pre>\n<code>\nclass Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 为了标明该对象已经被observer过\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n</code>\n</pre>\n\n <pre><code>\n // 拦截数据\n export function defineReactive (\n   obj: Object,\n   key: string,\n   val: any,\n   customSetter?: ?Function,\n   shallow?: boolean\n ) {\n   const dep = new Dep()\n \n   const property = Object.getOwnPropertyDescriptor(obj, key)\n   if (property && property.configurable === false) {\n     return\n   }\n \n   // cater for pre-defined getter/setters\n   const getter = property && property.get\n   const setter = property && property.set\n   if ((!getter || setter) && arguments.length === 2) {\n     val = obj[key]\n   }\n \n   let childOb = !shallow && observe(val)\n   Object.defineProperty(obj, key, {\n     enumerable: true,\n     configurable: true,\n     get: function reactiveGetter () {\n       const value = getter ? getter.call(obj) : val\n       if (Dep.target) {\n         dep.depend()\n         if (childOb) {\n           childOb.dep.depend()\n           if (Array.isArray(value)) {\n             dependArray(value)\n           }\n         }\n       }\n       return value\n     },\n     set: function reactiveSetter (newVal) {\n       const value = getter ? getter.call(obj) : val\n       /* eslint-disable no-self-compare */\n       if (newVal === value || (newVal !== newVal && value !== value)) {\n         return\n       }\n       /* eslint-enable no-self-compare */\n       if (process.env.NODE_ENV !== 'production' && customSetter) {\n         customSetter()\n       }\n       // #7981: for accessor properties without setter\n       if (getter && !setter) return\n       if (setter) {\n         setter.call(obj, newVal)\n       } else {\n         val = newVal\n       }\n       childOb = !shallow && observe(newVal)\n       // 使当前的调度中心通知所有Watcher\n       dep.notify()\n     }\n   })\n }\n </code></pre>\n \n Vue模版渲染\n \n 在执行npm run dev或者npm run build的时候，Vue使用rollup进行编译，入口文件为entry-runtime-with-compiler.js，\n 该文件有以下代码，在runtime的时候执行\n ```vue\n // entry-runtime-with-compiler.js，\n import Vue from './runtime/index'\n ```\n ```vue\n // runtime/index.js\n import Vue from 'core/index'\n ```\n ```vue\n // core/index.js\n // 导入Vue的实例，初始化全局Api\nimport Vue from './instance/index'\nimport { initGlobalAPI } from './global-api/index'\nimport { isServerRendering } from 'core/util/env'\nimport { FunctionalRenderContext } from 'core/vdom/create-functional-component'\ninitGlobalAPI(Vue)\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n})\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n})\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n})\n\nVue.version = '__VERSION__'\n\nexport default Vue\n```\n```vue\n// instance/index.js\n// 做Vue的各种模块混\n// 每当new Vue的时候执行初始化\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n// 初始化混入 *\ninitMixin(Vue)\n\nstateMixin(Vue)\n// 事件混入\neventsMixin(Vue)\n// 生命周期的混入 *\nlifecycleMixin(Vue)\n// render函数混入 *\nrenderMixin(Vue)\n```\n```vue\n// 走进this._init(options)方法\n// 最主要的是\n// 触发Vue原型上的$mount方法，进行compile。compiler/index.js会返回render函数和sataicRenderFns函数。等待renderMixin函数的使用。\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n\n```\n在render.js的renderMixi方法中使用了以下方法\n```vue\n// core/instance/render.js文件中 line:83\n// 这里就是将template进行转换\ntry {\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n  }\n\n// render方法 ，由compiler方法返回，功能是使用with语句的作用是将代码的作用域设置到一个特定的作用域中。之后的msg的都是访问的this中的属性，而this就是\n// vm._renderProxy（vm的一个代理实例），由于Vue自己的proxy方法会将this.data.msg的值的获取改为this.msg，因此msg就变成了\n// options中的data的一个值传入。经过_c (createElement)方法完成template模版的替换。\n(function anonymous(\n) {\nwith(this){return _c('div',{attrs:{\"id\":\"el\"}},[_v(\"\\n  \"+_s(msg)+_s(msg)+\"\\n\")])}\n})\n```\n###梳理下Vue初始化流程：\n>1. 在<font color=pink size=4>new</font>实例Vue的时候，调用<font color=\"pink\" size=\"4\">this._init(options)</font>方法将传入的对象作为$options属性存在Vue实例中。并将各种组件的props，父子组件的inject属性和指令进行合并，开始走created流程。\n>2. 执行了<font color=\"pink\" size=\"4\">initState()</font>方法，对所有数据包括(props和methods)进行拦截，给数据进行observer，并且给被observer过的属性增加ob属性标识，来表示已经被observer。【数据拦截原理见上方观察者模式】\n>> <font color=\"grey\" size=2>补充:由于遍历对象的属性，则每个对象都会有一个Dep，且一个Dep可能会有许多Watcher，因为可能这个属性的值被多处使用，所以当数据改变，则遍历触发自身的所有的Watcher。即dep.notify() => Array.forEach.update</font>\n>3. 之后调用<font color=pink size=4>vm.$mount(el)</font>方法, 进行Vue的mounted。\n>4. 在这之前用一个字段mount存储目标的自定义mounted方法后调用公用的mounted方法，在mounted过程中调用<font color=pink size=4>compilerToFunctions()</font>方法返回一个render函数(一个with关键字函数，切设计虚拟DOM树)，并设置<font color=pink size=4>options.render = render</font>。\n>5. 在公用的mounted方法后有一个<font color=\"pink\" size=\"4\">return mount.call(this, el, hydrating)</font>方法，开始调用自定义的mounted方法。\n>6. 在自定义mounted方法中，调用<font color=\"pink\" size=\"4\">mountComponent()</font>完成观察者模式：实例Watcher类。\n>7. 每个Watcher类在constructor中会调用<font color=\"pink\" size=\"4\">this.value = this.lazy ? undefined : this.get()</font>, 而this.get()方法将自身依赖push给全局的targetStack数组中，并把Dep.target的指向指为当前Watcher。 当要获取属性的值的时候，相应属性自身的get方法之前，将会被之前observer数据拦截，此时Dep.target就存在值，就调用了内部的<font color=\"pink\" size=\"4\">dep.depend()</font>方法实现依赖关系，将当前Watcher放入当前Dep中，等待后期的数据更新。这样就行成了一个依赖环。\n\n最后贴一下官网的生命周期图<a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\">Vue生命周期</a>\n\nVue的详细模板编译原理<a href=\"https://github.com/berwin/Blog/issues/18\">传送门</a>\n\n\n","slug":"publish-subscribe","published":1,"updated":"2019-03-18T06:53:04.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjti12udm00018nwktih6ukiq","content":"<p><br></p>\n<h1 id=\"观察者模式设计\"><a href=\"#观察者模式设计\" class=\"headerlink\" title=\"观察者模式设计\"></a>观察者模式设计</h1><p>在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。(来自wiki百科)</p>\n<p>例：小明去买房（观察者Observer），去找房产中心（目标主体Subject），发布者说等有合适的就通知小明。这样就形成了一个环</p>\n<h1 id=\"发布订阅模式设计\"><a href=\"#发布订阅模式设计\" class=\"headerlink\" title=\"发布订阅模式设计\"></a>发布订阅模式设计</h1><p>在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。(来自wiki百科)</p>\n<p>例：小明去买房（订阅者Subscriber），委托第三方中介去买房（调度中心Event Channel），等待第三方中介回馈消息，过了一会房产中心（发布者Publisher）发布消息给第三方中介，第三方中介发现正好符合小明的要求（key）就去通知小明。</p>\n<h1 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h1><p><img src=\"https://user-gold-cdn.xitu.io/2017/11/22/15fe1b1f174cd376?imageslim\"></p>\n<p>图片来源: <a href=\"http://developers-club.com/posts/270339/\" target=\"_blank\" rel=\"noopener\">developers-club</a></p>\n<blockquote>\n<ol>\n<li>在观察者模式中，观察者是知道主体Subject的，而Subject一直保持对观察者的记录。相反在发布订阅中，两者并不互相了解，只能通过代理进行沟通。</li>\n<li>观察者模式大多数是同步，如：事件触发，而发布订阅模式大多数是异步，如：消息队列。</li>\n<li>观察者模式是一种紧耦合状态，而发布订阅模式是一种松耦合的状态。</li>\n<li>观察者模式是通过主体本身去遍历观察者（维护的是观察者），然后调用订阅者的通知方法去实现。而发布订阅则是通过事件管道去通知（维护的是事件）。</li>\n</ol>\n</blockquote>\n<h1 id=\"MVVM和MVC的区别\"><a href=\"#MVVM和MVC的区别\" class=\"headerlink\" title=\"MVVM和MVC的区别\"></a>MVVM和MVC的区别</h1><p>MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>\n<p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>\n<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>\n<p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 </p>\n<a id=\"more\"></a>\n<h1 id=\"回到Vue\"><a href=\"#回到Vue\" class=\"headerlink\" title=\"回到Vue\"></a>回到Vue</h1><p>Vue的双向绑定则是利用了观察者模式实现的。<br>参考链接：<a href=\"https://segmentfault.com/a/1190000013338801\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000013338801</a></p>\n<pre>\n<code>\nclass Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 为了标明该对象已经被observer过\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n</any></code>\n</pre>\n\n <pre><code>\n // 拦截数据\n export function defineReactive (\n   obj: Object,\n   key: string,\n   val: any,\n   customSetter?: ?Function,\n   shallow?: boolean\n ) {\n   const dep = new Dep()\n\n   const property = Object.getOwnPropertyDescriptor(obj, key)\n   if (property && property.configurable === false) {\n     return\n   }\n\n   // cater for pre-defined getter/setters\n   const getter = property && property.get\n   const setter = property && property.set\n   if ((!getter || setter) && arguments.length === 2) {\n     val = obj[key]\n   }\n\n   let childOb = !shallow && observe(val)\n   Object.defineProperty(obj, key, {\n     enumerable: true,\n     configurable: true,\n     get: function reactiveGetter () {\n       const value = getter ? getter.call(obj) : val\n       if (Dep.target) {\n         dep.depend()\n         if (childOb) {\n           childOb.dep.depend()\n           if (Array.isArray(value)) {\n             dependArray(value)\n           }\n         }\n       }\n       return value\n     },\n     set: function reactiveSetter (newVal) {\n       const value = getter ? getter.call(obj) : val\n       /* eslint-disable no-self-compare */\n       if (newVal === value || (newVal !== newVal && value !== value)) {\n         return\n       }\n       /* eslint-enable no-self-compare */\n       if (process.env.NODE_ENV !== 'production' && customSetter) {\n         customSetter()\n       }\n       // #7981: for accessor properties without setter\n       if (getter && !setter) return\n       if (setter) {\n         setter.call(obj, newVal)\n       } else {\n         val = newVal\n       }\n       childOb = !shallow && observe(newVal)\n       // 使当前的调度中心通知所有Watcher\n       dep.notify()\n     }\n   })\n }\n </code></pre>\n\n<p> Vue模版渲染</p>\n<p> 在执行npm run dev或者npm run build的时候，Vue使用rollup进行编译，入口文件为entry-runtime-with-compiler.js，<br> 该文件有以下代码，在runtime的时候执行<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry-runtime-with-compiler.js，</span><br><span class=\"line\">import Vue from &apos;./runtime/index&apos;</span><br></pre></td></tr></table></figure></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// runtime/index.js</span><br><span class=\"line\">import Vue from &apos;core/index&apos;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // core/index.js</span><br><span class=\"line\"> // 导入Vue的实例，初始化全局Api</span><br><span class=\"line\">import Vue from &apos;./instance/index&apos;</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;</span><br><span class=\"line\">import &#123; isServerRendering &#125; from &apos;core/util/env&apos;</span><br><span class=\"line\">import &#123; FunctionalRenderContext &#125; from &apos;core/vdom/create-functional-component&apos;</span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123;</span><br><span class=\"line\">  get: isServerRendering</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$ssrContext&apos;, &#123;</span><br><span class=\"line\">  get () &#123;</span><br><span class=\"line\">    /* istanbul ignore next */</span><br><span class=\"line\">    return this.$vnode &amp;&amp; this.$vnode.ssrContext</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// expose FunctionalRenderContext for ssr runtime helper installation</span><br><span class=\"line\">Object.defineProperty(Vue, &apos;FunctionalRenderContext&apos;, &#123;</span><br><span class=\"line\">  value: FunctionalRenderContext</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.version = &apos;__VERSION__&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// instance/index.js</span><br><span class=\"line\">// 做Vue的各种模块混</span><br><span class=\"line\">// 每当new Vue的时候执行初始化</span><br><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 初始化混入 *</span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\">// 事件混入</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\">// 生命周期的混入 *</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\">// render函数混入 *</span><br><span class=\"line\">renderMixin(Vue)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 走进this._init(options)方法</span><br><span class=\"line\">// 最主要的是</span><br><span class=\"line\">// 触发Vue原型上的$mount方法，进行compile。compiler/index.js会返回render函数和sataicRenderFns函数。等待renderMixin函数的使用。</span><br><span class=\"line\">    if (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在render.js的renderMixi方法中使用了以下方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// core/instance/render.js文件中 line:83</span><br><span class=\"line\">// 这里就是将template进行转换</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// render方法 ，由compiler方法返回，功能是使用with语句的作用是将代码的作用域设置到一个特定的作用域中。之后的msg的都是访问的this中的属性，而this就是</span><br><span class=\"line\">// vm._renderProxy（vm的一个代理实例），由于Vue自己的proxy方法会将this.data.msg的值的获取改为this.msg，因此msg就变成了</span><br><span class=\"line\">// options中的data的一个值传入。经过_c (createElement)方法完成template模版的替换。</span><br><span class=\"line\">(function anonymous(</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">with(this)&#123;return _c(&apos;div&apos;,&#123;attrs:&#123;&quot;id&quot;:&quot;el&quot;&#125;&#125;,[_v(&quot;\\n  &quot;+_s(msg)+_s(msg)+&quot;\\n&quot;)])&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>###梳理下Vue初始化流程：</p>\n<blockquote>\n<ol>\n<li>在<font color=\"pink\" size=\"4\">new</font>实例Vue的时候，调用<font color=\"pink\" size=\"4\">this._init(options)</font>方法将传入的对象作为$options属性存在Vue实例中。并将各种组件的props，父子组件的inject属性和指令进行合并，开始走created流程。</li>\n<li>执行了<font color=\"pink\" size=\"4\">initState()</font>方法，对所有数据包括(props和methods)进行拦截，给数据进行observer，并且给被observer过的属性增加ob属性标识，来表示已经被observer。【数据拦截原理见上方观察者模式】<blockquote>\n<font color=\"grey\" size=\"2\">补充:由于遍历对象的属性，则每个对象都会有一个Dep，且一个Dep可能会有许多Watcher，因为可能这个属性的值被多处使用，所以当数据改变，则遍历触发自身的所有的Watcher。即dep.notify() =&gt; Array.forEach.update</font></blockquote>\n</li>\n<li>之后调用<font color=\"pink\" size=\"4\">vm.$mount(el)</font>方法, 进行Vue的mounted。</li>\n<li>在这之前用一个字段mount存储目标的自定义mounted方法后调用公用的mounted方法，在mounted过程中调用<font color=\"pink\" size=\"4\">compilerToFunctions()</font>方法返回一个render函数(一个with关键字函数，切设计虚拟DOM树)，并设置<font color=\"pink\" size=\"4\">options.render = render</font>。</li>\n<li>在公用的mounted方法后有一个<font color=\"pink\" size=\"4\">return mount.call(this, el, hydrating)</font>方法，开始调用自定义的mounted方法。</li>\n<li>在自定义mounted方法中，调用<font color=\"pink\" size=\"4\">mountComponent()</font>完成观察者模式：实例Watcher类。</li>\n<li>每个Watcher类在constructor中会调用<font color=\"pink\" size=\"4\">this.value = this.lazy ? undefined : this.get()</font>, 而this.get()方法将自身依赖push给全局的targetStack数组中，并把Dep.target的指向指为当前Watcher。 当要获取属性的值的时候，相应属性自身的get方法之前，将会被之前observer数据拦截，此时Dep.target就存在值，就调用了内部的<font color=\"pink\" size=\"4\">dep.depend()</font>方法实现依赖关系，将当前Watcher放入当前Dep中，等待后期的数据更新。这样就行成了一个依赖环。</li>\n</ol>\n</blockquote>\n<p>最后贴一下官网的生命周期图<a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\" target=\"_blank\" rel=\"noopener\">Vue生命周期</a></p>\n<p>Vue的详细模板编译原理<a href=\"https://github.com/berwin/Blog/issues/18\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n","site":{"data":{}},"excerpt":"<p><br></p>\n<h1 id=\"观察者模式设计\"><a href=\"#观察者模式设计\" class=\"headerlink\" title=\"观察者模式设计\"></a>观察者模式设计</h1><p>在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。(来自wiki百科)</p>\n<p>例：小明去买房（观察者Observer），去找房产中心（目标主体Subject），发布者说等有合适的就通知小明。这样就形成了一个环</p>\n<h1 id=\"发布订阅模式设计\"><a href=\"#发布订阅模式设计\" class=\"headerlink\" title=\"发布订阅模式设计\"></a>发布订阅模式设计</h1><p>在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。(来自wiki百科)</p>\n<p>例：小明去买房（订阅者Subscriber），委托第三方中介去买房（调度中心Event Channel），等待第三方中介回馈消息，过了一会房产中心（发布者Publisher）发布消息给第三方中介，第三方中介发现正好符合小明的要求（key）就去通知小明。</p>\n<h1 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h1><p><img src=\"https://user-gold-cdn.xitu.io/2017/11/22/15fe1b1f174cd376?imageslim\"></p>\n<p>图片来源: <a href=\"http://developers-club.com/posts/270339/\" target=\"_blank\" rel=\"noopener\">developers-club</a></p>\n<blockquote>\n<ol>\n<li>在观察者模式中，观察者是知道主体Subject的，而Subject一直保持对观察者的记录。相反在发布订阅中，两者并不互相了解，只能通过代理进行沟通。</li>\n<li>观察者模式大多数是同步，如：事件触发，而发布订阅模式大多数是异步，如：消息队列。</li>\n<li>观察者模式是一种紧耦合状态，而发布订阅模式是一种松耦合的状态。</li>\n<li>观察者模式是通过主体本身去遍历观察者（维护的是观察者），然后调用订阅者的通知方法去实现。而发布订阅则是通过事件管道去通知（维护的是事件）。</li>\n</ol>\n</blockquote>\n<h1 id=\"MVVM和MVC的区别\"><a href=\"#MVVM和MVC的区别\" class=\"headerlink\" title=\"MVVM和MVC的区别\"></a>MVVM和MVC的区别</h1><p>MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>\n<p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>\n<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>\n<p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 </p>","more":"<h1 id=\"回到Vue\"><a href=\"#回到Vue\" class=\"headerlink\" title=\"回到Vue\"></a>回到Vue</h1><p>Vue的双向绑定则是利用了观察者模式实现的。<br>参考链接：<a href=\"https://segmentfault.com/a/1190000013338801\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000013338801</a></p>\n<pre>\n<code>\nclass Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 为了标明该对象已经被observer过\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n</any></code>\n</pre>\n\n <pre><code>\n // 拦截数据\n export function defineReactive (\n   obj: Object,\n   key: string,\n   val: any,\n   customSetter?: ?Function,\n   shallow?: boolean\n ) {\n   const dep = new Dep()\n\n   const property = Object.getOwnPropertyDescriptor(obj, key)\n   if (property && property.configurable === false) {\n     return\n   }\n\n   // cater for pre-defined getter/setters\n   const getter = property && property.get\n   const setter = property && property.set\n   if ((!getter || setter) && arguments.length === 2) {\n     val = obj[key]\n   }\n\n   let childOb = !shallow && observe(val)\n   Object.defineProperty(obj, key, {\n     enumerable: true,\n     configurable: true,\n     get: function reactiveGetter () {\n       const value = getter ? getter.call(obj) : val\n       if (Dep.target) {\n         dep.depend()\n         if (childOb) {\n           childOb.dep.depend()\n           if (Array.isArray(value)) {\n             dependArray(value)\n           }\n         }\n       }\n       return value\n     },\n     set: function reactiveSetter (newVal) {\n       const value = getter ? getter.call(obj) : val\n       /* eslint-disable no-self-compare */\n       if (newVal === value || (newVal !== newVal && value !== value)) {\n         return\n       }\n       /* eslint-enable no-self-compare */\n       if (process.env.NODE_ENV !== 'production' && customSetter) {\n         customSetter()\n       }\n       // #7981: for accessor properties without setter\n       if (getter && !setter) return\n       if (setter) {\n         setter.call(obj, newVal)\n       } else {\n         val = newVal\n       }\n       childOb = !shallow && observe(newVal)\n       // 使当前的调度中心通知所有Watcher\n       dep.notify()\n     }\n   })\n }\n </code></pre>\n\n<p> Vue模版渲染</p>\n<p> 在执行npm run dev或者npm run build的时候，Vue使用rollup进行编译，入口文件为entry-runtime-with-compiler.js，<br> 该文件有以下代码，在runtime的时候执行<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry-runtime-with-compiler.js，</span><br><span class=\"line\">import Vue from &apos;./runtime/index&apos;</span><br></pre></td></tr></table></figure></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// runtime/index.js</span><br><span class=\"line\">import Vue from &apos;core/index&apos;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // core/index.js</span><br><span class=\"line\"> // 导入Vue的实例，初始化全局Api</span><br><span class=\"line\">import Vue from &apos;./instance/index&apos;</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;</span><br><span class=\"line\">import &#123; isServerRendering &#125; from &apos;core/util/env&apos;</span><br><span class=\"line\">import &#123; FunctionalRenderContext &#125; from &apos;core/vdom/create-functional-component&apos;</span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123;</span><br><span class=\"line\">  get: isServerRendering</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$ssrContext&apos;, &#123;</span><br><span class=\"line\">  get () &#123;</span><br><span class=\"line\">    /* istanbul ignore next */</span><br><span class=\"line\">    return this.$vnode &amp;&amp; this.$vnode.ssrContext</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// expose FunctionalRenderContext for ssr runtime helper installation</span><br><span class=\"line\">Object.defineProperty(Vue, &apos;FunctionalRenderContext&apos;, &#123;</span><br><span class=\"line\">  value: FunctionalRenderContext</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.version = &apos;__VERSION__&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// instance/index.js</span><br><span class=\"line\">// 做Vue的各种模块混</span><br><span class=\"line\">// 每当new Vue的时候执行初始化</span><br><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 初始化混入 *</span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\">// 事件混入</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\">// 生命周期的混入 *</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\">// render函数混入 *</span><br><span class=\"line\">renderMixin(Vue)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 走进this._init(options)方法</span><br><span class=\"line\">// 最主要的是</span><br><span class=\"line\">// 触发Vue原型上的$mount方法，进行compile。compiler/index.js会返回render函数和sataicRenderFns函数。等待renderMixin函数的使用。</span><br><span class=\"line\">    if (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在render.js的renderMixi方法中使用了以下方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// core/instance/render.js文件中 line:83</span><br><span class=\"line\">// 这里就是将template进行转换</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// render方法 ，由compiler方法返回，功能是使用with语句的作用是将代码的作用域设置到一个特定的作用域中。之后的msg的都是访问的this中的属性，而this就是</span><br><span class=\"line\">// vm._renderProxy（vm的一个代理实例），由于Vue自己的proxy方法会将this.data.msg的值的获取改为this.msg，因此msg就变成了</span><br><span class=\"line\">// options中的data的一个值传入。经过_c (createElement)方法完成template模版的替换。</span><br><span class=\"line\">(function anonymous(</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">with(this)&#123;return _c(&apos;div&apos;,&#123;attrs:&#123;&quot;id&quot;:&quot;el&quot;&#125;&#125;,[_v(&quot;\\n  &quot;+_s(msg)+_s(msg)+&quot;\\n&quot;)])&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>###梳理下Vue初始化流程：</p>\n<blockquote>\n<ol>\n<li>在<font color=\"pink\" size=\"4\">new</font>实例Vue的时候，调用<font color=\"pink\" size=\"4\">this._init(options)</font>方法将传入的对象作为$options属性存在Vue实例中。并将各种组件的props，父子组件的inject属性和指令进行合并，开始走created流程。</li>\n<li>执行了<font color=\"pink\" size=\"4\">initState()</font>方法，对所有数据包括(props和methods)进行拦截，给数据进行observer，并且给被observer过的属性增加ob属性标识，来表示已经被observer。【数据拦截原理见上方观察者模式】<blockquote>\n<font color=\"grey\" size=\"2\">补充:由于遍历对象的属性，则每个对象都会有一个Dep，且一个Dep可能会有许多Watcher，因为可能这个属性的值被多处使用，所以当数据改变，则遍历触发自身的所有的Watcher。即dep.notify() =&gt; Array.forEach.update</font></blockquote>\n</li>\n<li>之后调用<font color=\"pink\" size=\"4\">vm.$mount(el)</font>方法, 进行Vue的mounted。</li>\n<li>在这之前用一个字段mount存储目标的自定义mounted方法后调用公用的mounted方法，在mounted过程中调用<font color=\"pink\" size=\"4\">compilerToFunctions()</font>方法返回一个render函数(一个with关键字函数，切设计虚拟DOM树)，并设置<font color=\"pink\" size=\"4\">options.render = render</font>。</li>\n<li>在公用的mounted方法后有一个<font color=\"pink\" size=\"4\">return mount.call(this, el, hydrating)</font>方法，开始调用自定义的mounted方法。</li>\n<li>在自定义mounted方法中，调用<font color=\"pink\" size=\"4\">mountComponent()</font>完成观察者模式：实例Watcher类。</li>\n<li>每个Watcher类在constructor中会调用<font color=\"pink\" size=\"4\">this.value = this.lazy ? undefined : this.get()</font>, 而this.get()方法将自身依赖push给全局的targetStack数组中，并把Dep.target的指向指为当前Watcher。 当要获取属性的值的时候，相应属性自身的get方法之前，将会被之前observer数据拦截，此时Dep.target就存在值，就调用了内部的<font color=\"pink\" size=\"4\">dep.depend()</font>方法实现依赖关系，将当前Watcher放入当前Dep中，等待后期的数据更新。这样就行成了一个依赖环。</li>\n</ol>\n</blockquote>\n<p>最后贴一下官网的生命周期图<a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\" target=\"_blank\" rel=\"noopener\">Vue生命周期</a></p>\n<p>Vue的详细模板编译原理<a href=\"https://github.com/berwin/Blog/issues/18\" target=\"_blank\" rel=\"noopener\">传送门</a></p>"},{"title":"Webpack详解","date":"2018-11-26T08:29:24.040Z","_content":"<br/>\n\nWebpack\n===\n\n为什么要使用WebPack\n---\n现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法\n\n模块化，让我们可以把复杂的程序细化为小的文件;\n类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；\nScss，less等CSS预处理器\n...\n这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。\n\n什么是Webpack\n\n<!--more-->\n\n---\nwebpack可以看做是模块打包机：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用\n\nWebpack的工作方式\n---\nWebpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。\n\n开始使用Webpack\n===\n\n\n```\n// 全局安装\nnpm install -g webpack\nnpm install -g webpack-cli\nnpm install -g webpack-dev-server\n```\n\n正式使用webpack\n===\n\n####通过命令行使用\n```\n// entry file 表示入口文件\n// output file 表示出口文件的路径和文件名\nwebpack {entry file} {output file} \n在最新版本的使用方法\n// -o 参数表示指定之后的内容为输入文件\nwebpack {entry file} -o {output file}\n```\n\n####通过配置文件使用\n\n生成一个webpack.config.js文件，输入以下简单配置\n```\nmodule.exports = {\n  devtool: \"source-map\", // 打包方式，后续会提及\n  entry: __dirname + \"/app/main.js\", // 入口文件\n  output: {  // 出口文件\n    path: __dirname + \"/public/\",  // 出口文件路径\n    filename: 'bundle.js' // 出口文件名\n  }\n}\n```\n\n>__dirname 表示当前执行脚本的所在路径，为node环境的全局变量\n\nWebPack强大功能\n===\n####使用Source Maps（使调试更容易）\n\n| devtool选项 | 配置结果 |\n| :---------: | ----- |\n| source-map | 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；|\n| cheap-module-source-map | 在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便； |\n| eval-source-map | 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；|\n| cheap-module-eval-source-map | 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； |\n\n####使用Webpack构建本地服务器\n\n```vue\nmodule.exports = {\n  devtool: \"eval-source-map\", //\n  entry: __dirname + \"/app/main.js\",\n  output: {\n    path: __dirname + \"/public/\",\n    filename: 'bundle.js'\n  },\n  devServer: {\n    contentBase: './public', // 本地服务器所加载的页面所载目录\n    historyApiFallback: true, // 是否跳转\n    inline: true // 实时刷新\n  }\n```\n\n| devserver的配置 | 功能描述 |\n| :------------: | ----- |\n| contentBase | 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public\"目录）|\n| port | 设置默认监听端口，如果省略，默认为”8080“ |\n| inline | 设置为true，当源文件改变时会自动刷新页面 |\n| historyApiFallback | 在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html |\n####Loaders\n通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。\n对于Vue而言，使用Vue-loader进行解析各种Vue文件翻译成浏览器可编译的代码。\n\nwebpack官方推荐提供了两个utils\n```\nloader-utils // 提供很多有用的工具，其中最普遍使用的是获取options。\nschema-utils // 能够校验传来的options是否合法\n```\n\n#####Loader特性\n1. loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。\n2. loader 可以是同步的，也可以是异步的。\n3. loader 运行在 Node.js 中，并且能够执行任何可能的操作。\n4. loader 接收查询参数。用于对 loader 传递配置。\n5. loader 也能够使用 options 对象进行配置。\n6. 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。\n7. 插件(plugin)可以为 loader 带来更多特性。\n8. loader 能够产生额外的任意文件。\n\n\n####Babel\nBabel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：\n\n让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持；\n让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；\n\n#####Babel的安装和配置\nBabel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，对于每一个单独需要的功能的扩展，需要安装单独的包（常用的有解析Es6的babel-env-preset包）\n\n安装：\n>webpack 4.x | babel-loader 8.x | babel 7.x\n```vue\nnpm install -D babel-loader @babel/core @babel/preset-env webpack\n```\n>.babelrc文件配置\n```vue\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n>webpack 4.x | babel-loader 7.x | babel 6.x\n```vue\nnpm install -D babel-loader@7 babel-core babel-preset-env webpack\n```\n>.babelrc文件配置\n```vue\n{\n  \"presets\": [\n    [\n      \"env\",\n      {\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n\n####Plugins\n常用的插件\n\n| 插件名 | 说明 | 链接 |\n| :---: | ---- | ---- |\n| HtmlWebpackPlugin | 依据一个html模板，生成一个新的html文件，可做模板的替换，插入js | https://www.npmjs.com/package/html-webpack-plugin |\n| CleanWebpackPlugin | 在打包之前指定删除文件或文件夹 | https://www.npmjs.com/package/clean-webpack-plugin |\n| mini-css-extract-plugin | 将指定的内容从打包的文件分离，webpack4废除了extract-text-webpack-plugin这个插件 | https://www.npmjs.com/package/mini-css-extract-plugin |\n\n#####Webpack内置插件\n不做叙述https://www.webpackjs.com/plugins/\n\n#####编写一个Webpack插件\nWebpack插件由以下组成：\n>1. 一个JavaScript命名函数\n>2. 在插件函数的prototype上顶一个一个apply方法\n>3. 制定一个绑定webpack自身的事件钩子。\n>4. 处理webpack内部实例的特定数据。\n>5. 功能完成后调用webpack回调\n\n例：\n```vue\n// 一个 JavaScript 命名函数。\nconst pluginName = 'MyWebPackPlugin'\n\nclass FileListPlugin {\n  apply (compiler) {\n    compiler.hooks.run.tap(pluginName, (compilation) => {\n      console.log('Webpack开始构建中')\n    })\n  }\n}\n```\n\n其中有两个重要的回调：\n- compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。\n   - 使用方法\n   ```vue\n     compiler.hooks.someHook.tap(/* ... */);\n   ```\n   - someHook列表：https://webpack.js.org/api/compiler-hooks/\n  \n- compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。\n   - 使用方法\n   ```vue\n     compilation.hooks.someHook.tap(/* ... */);\n   ```\n   - someHook列表：https://webpack.js.org/api/compilation-hooks/\n\ntap方法表：\n\n| 方法名 | 功能描述 |\n| :---: | ----- |\n| tap | 同步方法，自动执行webpack的流程 |\n| tapAsync | 异步方法，必须在执行结束后调用webpack自己的callback()方法 |\n| tapPromise | 返回一个Promise方法，当异步任务完成后需要在添加resolve(）方法 |\n\n\n参考文档：\n- Webpack内部运行机制：https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，\n- Webpack4.0逐个击破：https://www.cnblogs.com/dashnowords/category/1284284.html\n- Webpack官网：https://webpack.js.org/ 【建议】\n\n\n### Webpack核心：tapable类\n\n```tapable```是```webpack```的核心框架（4.0以上版本的API已经发生了变化），是一个基于事件流的框架，或者叫做发布订阅模式，或观察者模式，```webpack```的整个生命周期及其开放的自定义插件系统都离不开```tapable```的支持，研究其运行原理是阅读```webpack```源代码的第一步。官方仓库master分支的代码是经过ES6重构的，模块化拆分非常细，且加入了很多非核心逻辑，阅读难度较大。建议先从官方仓库中0.2版本的分支开始学习，整个源码只有400行，相对容易理解。\n- 0.2版本链接：https://github.com/webpack/tapable/tree/tapable-0.2\n\n\n### 代码地址\nhttps://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project\n","source":"_posts/simpe-webpack-project.md","raw":"---\ntitle: Webpack详解\ndate: 2018年10月28日\n---\n<br/>\n\nWebpack\n===\n\n为什么要使用WebPack\n---\n现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法\n\n模块化，让我们可以把复杂的程序细化为小的文件;\n类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；\nScss，less等CSS预处理器\n...\n这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。\n\n什么是Webpack\n\n<!--more-->\n\n---\nwebpack可以看做是模块打包机：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用\n\nWebpack的工作方式\n---\nWebpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。\n\n开始使用Webpack\n===\n\n\n```\n// 全局安装\nnpm install -g webpack\nnpm install -g webpack-cli\nnpm install -g webpack-dev-server\n```\n\n正式使用webpack\n===\n\n####通过命令行使用\n```\n// entry file 表示入口文件\n// output file 表示出口文件的路径和文件名\nwebpack {entry file} {output file} \n在最新版本的使用方法\n// -o 参数表示指定之后的内容为输入文件\nwebpack {entry file} -o {output file}\n```\n\n####通过配置文件使用\n\n生成一个webpack.config.js文件，输入以下简单配置\n```\nmodule.exports = {\n  devtool: \"source-map\", // 打包方式，后续会提及\n  entry: __dirname + \"/app/main.js\", // 入口文件\n  output: {  // 出口文件\n    path: __dirname + \"/public/\",  // 出口文件路径\n    filename: 'bundle.js' // 出口文件名\n  }\n}\n```\n\n>__dirname 表示当前执行脚本的所在路径，为node环境的全局变量\n\nWebPack强大功能\n===\n####使用Source Maps（使调试更容易）\n\n| devtool选项 | 配置结果 |\n| :---------: | ----- |\n| source-map | 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；|\n| cheap-module-source-map | 在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便； |\n| eval-source-map | 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；|\n| cheap-module-eval-source-map | 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； |\n\n####使用Webpack构建本地服务器\n\n```vue\nmodule.exports = {\n  devtool: \"eval-source-map\", //\n  entry: __dirname + \"/app/main.js\",\n  output: {\n    path: __dirname + \"/public/\",\n    filename: 'bundle.js'\n  },\n  devServer: {\n    contentBase: './public', // 本地服务器所加载的页面所载目录\n    historyApiFallback: true, // 是否跳转\n    inline: true // 实时刷新\n  }\n```\n\n| devserver的配置 | 功能描述 |\n| :------------: | ----- |\n| contentBase | 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public\"目录）|\n| port | 设置默认监听端口，如果省略，默认为”8080“ |\n| inline | 设置为true，当源文件改变时会自动刷新页面 |\n| historyApiFallback | 在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html |\n####Loaders\n通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。\n对于Vue而言，使用Vue-loader进行解析各种Vue文件翻译成浏览器可编译的代码。\n\nwebpack官方推荐提供了两个utils\n```\nloader-utils // 提供很多有用的工具，其中最普遍使用的是获取options。\nschema-utils // 能够校验传来的options是否合法\n```\n\n#####Loader特性\n1. loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。\n2. loader 可以是同步的，也可以是异步的。\n3. loader 运行在 Node.js 中，并且能够执行任何可能的操作。\n4. loader 接收查询参数。用于对 loader 传递配置。\n5. loader 也能够使用 options 对象进行配置。\n6. 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。\n7. 插件(plugin)可以为 loader 带来更多特性。\n8. loader 能够产生额外的任意文件。\n\n\n####Babel\nBabel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：\n\n让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持；\n让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；\n\n#####Babel的安装和配置\nBabel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，对于每一个单独需要的功能的扩展，需要安装单独的包（常用的有解析Es6的babel-env-preset包）\n\n安装：\n>webpack 4.x | babel-loader 8.x | babel 7.x\n```vue\nnpm install -D babel-loader @babel/core @babel/preset-env webpack\n```\n>.babelrc文件配置\n```vue\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n>webpack 4.x | babel-loader 7.x | babel 6.x\n```vue\nnpm install -D babel-loader@7 babel-core babel-preset-env webpack\n```\n>.babelrc文件配置\n```vue\n{\n  \"presets\": [\n    [\n      \"env\",\n      {\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n\n####Plugins\n常用的插件\n\n| 插件名 | 说明 | 链接 |\n| :---: | ---- | ---- |\n| HtmlWebpackPlugin | 依据一个html模板，生成一个新的html文件，可做模板的替换，插入js | https://www.npmjs.com/package/html-webpack-plugin |\n| CleanWebpackPlugin | 在打包之前指定删除文件或文件夹 | https://www.npmjs.com/package/clean-webpack-plugin |\n| mini-css-extract-plugin | 将指定的内容从打包的文件分离，webpack4废除了extract-text-webpack-plugin这个插件 | https://www.npmjs.com/package/mini-css-extract-plugin |\n\n#####Webpack内置插件\n不做叙述https://www.webpackjs.com/plugins/\n\n#####编写一个Webpack插件\nWebpack插件由以下组成：\n>1. 一个JavaScript命名函数\n>2. 在插件函数的prototype上顶一个一个apply方法\n>3. 制定一个绑定webpack自身的事件钩子。\n>4. 处理webpack内部实例的特定数据。\n>5. 功能完成后调用webpack回调\n\n例：\n```vue\n// 一个 JavaScript 命名函数。\nconst pluginName = 'MyWebPackPlugin'\n\nclass FileListPlugin {\n  apply (compiler) {\n    compiler.hooks.run.tap(pluginName, (compilation) => {\n      console.log('Webpack开始构建中')\n    })\n  }\n}\n```\n\n其中有两个重要的回调：\n- compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。\n   - 使用方法\n   ```vue\n     compiler.hooks.someHook.tap(/* ... */);\n   ```\n   - someHook列表：https://webpack.js.org/api/compiler-hooks/\n  \n- compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。\n   - 使用方法\n   ```vue\n     compilation.hooks.someHook.tap(/* ... */);\n   ```\n   - someHook列表：https://webpack.js.org/api/compilation-hooks/\n\ntap方法表：\n\n| 方法名 | 功能描述 |\n| :---: | ----- |\n| tap | 同步方法，自动执行webpack的流程 |\n| tapAsync | 异步方法，必须在执行结束后调用webpack自己的callback()方法 |\n| tapPromise | 返回一个Promise方法，当异步任务完成后需要在添加resolve(）方法 |\n\n\n参考文档：\n- Webpack内部运行机制：https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，\n- Webpack4.0逐个击破：https://www.cnblogs.com/dashnowords/category/1284284.html\n- Webpack官网：https://webpack.js.org/ 【建议】\n\n\n### Webpack核心：tapable类\n\n```tapable```是```webpack```的核心框架（4.0以上版本的API已经发生了变化），是一个基于事件流的框架，或者叫做发布订阅模式，或观察者模式，```webpack```的整个生命周期及其开放的自定义插件系统都离不开```tapable```的支持，研究其运行原理是阅读```webpack```源代码的第一步。官方仓库master分支的代码是经过ES6重构的，模块化拆分非常细，且加入了很多非核心逻辑，阅读难度较大。建议先从官方仓库中0.2版本的分支开始学习，整个源码只有400行，相对容易理解。\n- 0.2版本链接：https://github.com/webpack/tapable/tree/tapable-0.2\n\n\n### 代码地址\nhttps://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project\n","slug":"simpe-webpack-project","published":1,"updated":"2018-11-26T08:29:24.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjti12ue100028nwkz93ca569","content":"<p><br></p>\n<h1 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h1><h2 id=\"为什么要使用WebPack\"><a href=\"#为什么要使用WebPack\" class=\"headerlink\" title=\"为什么要使用WebPack\"></a>为什么要使用WebPack</h2><p>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p>\n<p>模块化，让我们可以把复杂的程序细化为小的文件;<br>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；<br>Scss，less等CSS预处理器<br>…<br>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。</p>\n<p>什么是Webpack</p>\n<a id=\"more\"></a>\n<hr>\n<p>webpack可以看做是模块打包机：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用</p>\n<h2 id=\"Webpack的工作方式\"><a href=\"#Webpack的工作方式\" class=\"headerlink\" title=\"Webpack的工作方式\"></a>Webpack的工作方式</h2><p>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p>\n<h1 id=\"开始使用Webpack\"><a href=\"#开始使用Webpack\" class=\"headerlink\" title=\"开始使用Webpack\"></a>开始使用Webpack</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 全局安装</span><br><span class=\"line\">npm install -g webpack</span><br><span class=\"line\">npm install -g webpack-cli</span><br><span class=\"line\">npm install -g webpack-dev-server</span><br></pre></td></tr></table></figure>\n<h1 id=\"正式使用webpack\"><a href=\"#正式使用webpack\" class=\"headerlink\" title=\"正式使用webpack\"></a>正式使用webpack</h1><p>####通过命令行使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry file 表示入口文件</span><br><span class=\"line\">// output file 表示出口文件的路径和文件名</span><br><span class=\"line\">webpack &#123;entry file&#125; &#123;output file&#125; </span><br><span class=\"line\">在最新版本的使用方法</span><br><span class=\"line\">// -o 参数表示指定之后的内容为输入文件</span><br><span class=\"line\">webpack &#123;entry file&#125; -o &#123;output file&#125;</span><br></pre></td></tr></table></figure></p>\n<p>####通过配置文件使用</p>\n<p>生成一个webpack.config.js文件，输入以下简单配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &quot;source-map&quot;, // 打包方式，后续会提及</span><br><span class=\"line\">  entry: __dirname + &quot;/app/main.js&quot;, // 入口文件</span><br><span class=\"line\">  output: &#123;  // 出口文件</span><br><span class=\"line\">    path: __dirname + &quot;/public/&quot;,  // 出口文件路径</span><br><span class=\"line\">    filename: &apos;bundle.js&apos; // 出口文件名</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>__dirname 表示当前执行脚本的所在路径，为node环境的全局变量</p>\n</blockquote>\n<h1 id=\"WebPack强大功能\"><a href=\"#WebPack强大功能\" class=\"headerlink\" title=\"WebPack强大功能\"></a>WebPack强大功能</h1><p>####使用Source Maps（使调试更容易）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">devtool选项</th>\n<th>配置结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">source-map</td>\n<td>在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cheap-module-source-map</td>\n<td>在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">eval-source-map</td>\n<td>使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cheap-module-eval-source-map</td>\n<td>这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；</td>\n</tr>\n</tbody>\n</table>\n<p>####使用Webpack构建本地服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &quot;eval-source-map&quot;, //</span><br><span class=\"line\">  entry: __dirname + &quot;/app/main.js&quot;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/public/&quot;,</span><br><span class=\"line\">    filename: &apos;bundle.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    contentBase: &apos;./public&apos;, // 本地服务器所加载的页面所载目录</span><br><span class=\"line\">    historyApiFallback: true, // 是否跳转</span><br><span class=\"line\">    inline: true // 实时刷新</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">devserver的配置</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">contentBase</td>\n<td>默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">port</td>\n<td>设置默认监听端口，如果省略，默认为”8080“</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">inline</td>\n<td>设置为true，当源文件改变时会自动刷新页面</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">historyApiFallback</td>\n<td>在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</td>\n</tr>\n</tbody>\n</table>\n<p>####Loaders<br>通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。<br>对于Vue而言，使用Vue-loader进行解析各种Vue文件翻译成浏览器可编译的代码。</p>\n<p>webpack官方推荐提供了两个utils<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loader-utils // 提供很多有用的工具，其中最普遍使用的是获取options。</span><br><span class=\"line\">schema-utils // 能够校验传来的options是否合法</span><br></pre></td></tr></table></figure></p>\n<p>#####Loader特性</p>\n<ol>\n<li>loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。</li>\n<li>loader 可以是同步的，也可以是异步的。</li>\n<li>loader 运行在 Node.js 中，并且能够执行任何可能的操作。</li>\n<li>loader 接收查询参数。用于对 loader 传递配置。</li>\n<li>loader 也能够使用 options 对象进行配置。</li>\n<li>除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。</li>\n<li>插件(plugin)可以为 loader 带来更多特性。</li>\n<li>loader 能够产生额外的任意文件。</li>\n</ol>\n<p>####Babel<br>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：</p>\n<p>让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持；<br>让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；</p>\n<p>#####Babel的安装和配置<br>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，对于每一个单独需要的功能的扩展，需要安装单独的包（常用的有解析Es6的babel-env-preset包）</p>\n<p>安装：</p>\n<blockquote>\n<p>webpack 4.x | babel-loader 8.x | babel 7.x<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -D babel-loader @babel/core @babel/preset-env webpack</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>.babelrc文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;@babel/preset-env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>webpack 4.x | babel-loader 7.x | babel 6.x<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -D babel-loader@7 babel-core babel-preset-env webpack</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>.babelrc文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>####Plugins<br>常用的插件</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">插件名</th>\n<th>说明</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">HtmlWebpackPlugin</td>\n<td>依据一个html模板，生成一个新的html文件，可做模板的替换，插入js</td>\n<td><a href=\"https://www.npmjs.com/package/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/html-webpack-plugin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CleanWebpackPlugin</td>\n<td>在打包之前指定删除文件或文件夹</td>\n<td><a href=\"https://www.npmjs.com/package/clean-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/clean-webpack-plugin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mini-css-extract-plugin</td>\n<td>将指定的内容从打包的文件分离，webpack4废除了extract-text-webpack-plugin这个插件</td>\n<td><a href=\"https://www.npmjs.com/package/mini-css-extract-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/mini-css-extract-plugin</a></td>\n</tr>\n</tbody>\n</table>\n<p>#####Webpack内置插件<br>不做叙述<a href=\"https://www.webpackjs.com/plugins/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/plugins/</a></p>\n<p>#####编写一个Webpack插件<br>Webpack插件由以下组成：</p>\n<blockquote>\n<ol>\n<li>一个JavaScript命名函数</li>\n<li>在插件函数的prototype上顶一个一个apply方法</li>\n<li>制定一个绑定webpack自身的事件钩子。</li>\n<li>处理webpack内部实例的特定数据。</li>\n<li>功能完成后调用webpack回调</li>\n</ol>\n</blockquote>\n<p>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个 JavaScript 命名函数。</span><br><span class=\"line\">const pluginName = &apos;MyWebPackPlugin&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">class FileListPlugin &#123;</span><br><span class=\"line\">  apply (compiler) &#123;</span><br><span class=\"line\">    compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;Webpack开始构建中&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中有两个重要的回调：</p>\n<ul>\n<li><p>compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p>\n<ul>\n<li><p>使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compiler.hooks.someHook.tap(/* ... */);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>someHook列表：<a href=\"https://webpack.js.org/api/compiler-hooks/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/api/compiler-hooks/</a></p>\n</li>\n</ul>\n</li>\n<li><p>compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p>\n<ul>\n<li><p>使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compilation.hooks.someHook.tap(/* ... */);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>someHook列表：<a href=\"https://webpack.js.org/api/compilation-hooks/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/api/compilation-hooks/</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>tap方法表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法名</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">tap</td>\n<td>同步方法，自动执行webpack的流程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tapAsync</td>\n<td>异步方法，必须在执行结束后调用webpack自己的callback()方法</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tapPromise</td>\n<td>返回一个Promise方法，当异步任务完成后需要在添加resolve(）方法</td>\n</tr>\n</tbody>\n</table>\n<p>参考文档：</p>\n<ul>\n<li>Webpack内部运行机制：<a href=\"https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，\" target=\"_blank\" rel=\"noopener\">https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，</a></li>\n<li>Webpack4.0逐个击破：<a href=\"https://www.cnblogs.com/dashnowords/category/1284284.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dashnowords/category/1284284.html</a></li>\n<li>Webpack官网：<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/</a> 【建议】</li>\n</ul>\n<h3 id=\"Webpack核心：tapable类\"><a href=\"#Webpack核心：tapable类\" class=\"headerlink\" title=\"Webpack核心：tapable类\"></a>Webpack核心：tapable类</h3><p><code>tapable</code>是<code>webpack</code>的核心框架（4.0以上版本的API已经发生了变化），是一个基于事件流的框架，或者叫做发布订阅模式，或观察者模式，<code>webpack</code>的整个生命周期及其开放的自定义插件系统都离不开<code>tapable</code>的支持，研究其运行原理是阅读<code>webpack</code>源代码的第一步。官方仓库master分支的代码是经过ES6重构的，模块化拆分非常细，且加入了很多非核心逻辑，阅读难度较大。建议先从官方仓库中0.2版本的分支开始学习，整个源码只有400行，相对容易理解。</p>\n<ul>\n<li>0.2版本链接：<a href=\"https://github.com/webpack/tapable/tree/tapable-0.2\" target=\"_blank\" rel=\"noopener\">https://github.com/webpack/tapable/tree/tapable-0.2</a></li>\n</ul>\n<h3 id=\"代码地址\"><a href=\"#代码地址\" class=\"headerlink\" title=\"代码地址\"></a>代码地址</h3><p><a href=\"https://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project\" target=\"_blank\" rel=\"noopener\">https://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project</a></p>\n","site":{"data":{}},"excerpt":"<p><br></p>\n<h1 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h1><h2 id=\"为什么要使用WebPack\"><a href=\"#为什么要使用WebPack\" class=\"headerlink\" title=\"为什么要使用WebPack\"></a>为什么要使用WebPack</h2><p>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p>\n<p>模块化，让我们可以把复杂的程序细化为小的文件;<br>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；<br>Scss，less等CSS预处理器<br>…<br>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。</p>\n<p>什么是Webpack</p>","more":"<hr>\n<p>webpack可以看做是模块打包机：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用</p>\n<h2 id=\"Webpack的工作方式\"><a href=\"#Webpack的工作方式\" class=\"headerlink\" title=\"Webpack的工作方式\"></a>Webpack的工作方式</h2><p>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p>\n<h1 id=\"开始使用Webpack\"><a href=\"#开始使用Webpack\" class=\"headerlink\" title=\"开始使用Webpack\"></a>开始使用Webpack</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 全局安装</span><br><span class=\"line\">npm install -g webpack</span><br><span class=\"line\">npm install -g webpack-cli</span><br><span class=\"line\">npm install -g webpack-dev-server</span><br></pre></td></tr></table></figure>\n<h1 id=\"正式使用webpack\"><a href=\"#正式使用webpack\" class=\"headerlink\" title=\"正式使用webpack\"></a>正式使用webpack</h1><p>####通过命令行使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry file 表示入口文件</span><br><span class=\"line\">// output file 表示出口文件的路径和文件名</span><br><span class=\"line\">webpack &#123;entry file&#125; &#123;output file&#125; </span><br><span class=\"line\">在最新版本的使用方法</span><br><span class=\"line\">// -o 参数表示指定之后的内容为输入文件</span><br><span class=\"line\">webpack &#123;entry file&#125; -o &#123;output file&#125;</span><br></pre></td></tr></table></figure></p>\n<p>####通过配置文件使用</p>\n<p>生成一个webpack.config.js文件，输入以下简单配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &quot;source-map&quot;, // 打包方式，后续会提及</span><br><span class=\"line\">  entry: __dirname + &quot;/app/main.js&quot;, // 入口文件</span><br><span class=\"line\">  output: &#123;  // 出口文件</span><br><span class=\"line\">    path: __dirname + &quot;/public/&quot;,  // 出口文件路径</span><br><span class=\"line\">    filename: &apos;bundle.js&apos; // 出口文件名</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>__dirname 表示当前执行脚本的所在路径，为node环境的全局变量</p>\n</blockquote>\n<h1 id=\"WebPack强大功能\"><a href=\"#WebPack强大功能\" class=\"headerlink\" title=\"WebPack强大功能\"></a>WebPack强大功能</h1><p>####使用Source Maps（使调试更容易）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">devtool选项</th>\n<th>配置结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">source-map</td>\n<td>在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cheap-module-source-map</td>\n<td>在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">eval-source-map</td>\n<td>使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cheap-module-eval-source-map</td>\n<td>这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；</td>\n</tr>\n</tbody>\n</table>\n<p>####使用Webpack构建本地服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &quot;eval-source-map&quot;, //</span><br><span class=\"line\">  entry: __dirname + &quot;/app/main.js&quot;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/public/&quot;,</span><br><span class=\"line\">    filename: &apos;bundle.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    contentBase: &apos;./public&apos;, // 本地服务器所加载的页面所载目录</span><br><span class=\"line\">    historyApiFallback: true, // 是否跳转</span><br><span class=\"line\">    inline: true // 实时刷新</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">devserver的配置</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">contentBase</td>\n<td>默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">port</td>\n<td>设置默认监听端口，如果省略，默认为”8080“</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">inline</td>\n<td>设置为true，当源文件改变时会自动刷新页面</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">historyApiFallback</td>\n<td>在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</td>\n</tr>\n</tbody>\n</table>\n<p>####Loaders<br>通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。<br>对于Vue而言，使用Vue-loader进行解析各种Vue文件翻译成浏览器可编译的代码。</p>\n<p>webpack官方推荐提供了两个utils<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loader-utils // 提供很多有用的工具，其中最普遍使用的是获取options。</span><br><span class=\"line\">schema-utils // 能够校验传来的options是否合法</span><br></pre></td></tr></table></figure></p>\n<p>#####Loader特性</p>\n<ol>\n<li>loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。</li>\n<li>loader 可以是同步的，也可以是异步的。</li>\n<li>loader 运行在 Node.js 中，并且能够执行任何可能的操作。</li>\n<li>loader 接收查询参数。用于对 loader 传递配置。</li>\n<li>loader 也能够使用 options 对象进行配置。</li>\n<li>除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。</li>\n<li>插件(plugin)可以为 loader 带来更多特性。</li>\n<li>loader 能够产生额外的任意文件。</li>\n</ol>\n<p>####Babel<br>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：</p>\n<p>让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持；<br>让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；</p>\n<p>#####Babel的安装和配置<br>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，对于每一个单独需要的功能的扩展，需要安装单独的包（常用的有解析Es6的babel-env-preset包）</p>\n<p>安装：</p>\n<blockquote>\n<p>webpack 4.x | babel-loader 8.x | babel 7.x<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -D babel-loader @babel/core @babel/preset-env webpack</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>.babelrc文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;@babel/preset-env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>webpack 4.x | babel-loader 7.x | babel 6.x<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -D babel-loader@7 babel-core babel-preset-env webpack</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>.babelrc文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>####Plugins<br>常用的插件</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">插件名</th>\n<th>说明</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">HtmlWebpackPlugin</td>\n<td>依据一个html模板，生成一个新的html文件，可做模板的替换，插入js</td>\n<td><a href=\"https://www.npmjs.com/package/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/html-webpack-plugin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CleanWebpackPlugin</td>\n<td>在打包之前指定删除文件或文件夹</td>\n<td><a href=\"https://www.npmjs.com/package/clean-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/clean-webpack-plugin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mini-css-extract-plugin</td>\n<td>将指定的内容从打包的文件分离，webpack4废除了extract-text-webpack-plugin这个插件</td>\n<td><a href=\"https://www.npmjs.com/package/mini-css-extract-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/mini-css-extract-plugin</a></td>\n</tr>\n</tbody>\n</table>\n<p>#####Webpack内置插件<br>不做叙述<a href=\"https://www.webpackjs.com/plugins/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/plugins/</a></p>\n<p>#####编写一个Webpack插件<br>Webpack插件由以下组成：</p>\n<blockquote>\n<ol>\n<li>一个JavaScript命名函数</li>\n<li>在插件函数的prototype上顶一个一个apply方法</li>\n<li>制定一个绑定webpack自身的事件钩子。</li>\n<li>处理webpack内部实例的特定数据。</li>\n<li>功能完成后调用webpack回调</li>\n</ol>\n</blockquote>\n<p>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个 JavaScript 命名函数。</span><br><span class=\"line\">const pluginName = &apos;MyWebPackPlugin&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">class FileListPlugin &#123;</span><br><span class=\"line\">  apply (compiler) &#123;</span><br><span class=\"line\">    compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;Webpack开始构建中&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中有两个重要的回调：</p>\n<ul>\n<li><p>compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p>\n<ul>\n<li><p>使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compiler.hooks.someHook.tap(/* ... */);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>someHook列表：<a href=\"https://webpack.js.org/api/compiler-hooks/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/api/compiler-hooks/</a></p>\n</li>\n</ul>\n</li>\n<li><p>compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p>\n<ul>\n<li><p>使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compilation.hooks.someHook.tap(/* ... */);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>someHook列表：<a href=\"https://webpack.js.org/api/compilation-hooks/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/api/compilation-hooks/</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>tap方法表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法名</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">tap</td>\n<td>同步方法，自动执行webpack的流程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tapAsync</td>\n<td>异步方法，必须在执行结束后调用webpack自己的callback()方法</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tapPromise</td>\n<td>返回一个Promise方法，当异步任务完成后需要在添加resolve(）方法</td>\n</tr>\n</tbody>\n</table>\n<p>参考文档：</p>\n<ul>\n<li>Webpack内部运行机制：<a href=\"https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，\" target=\"_blank\" rel=\"noopener\">https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，</a></li>\n<li>Webpack4.0逐个击破：<a href=\"https://www.cnblogs.com/dashnowords/category/1284284.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dashnowords/category/1284284.html</a></li>\n<li>Webpack官网：<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/</a> 【建议】</li>\n</ul>\n<h3 id=\"Webpack核心：tapable类\"><a href=\"#Webpack核心：tapable类\" class=\"headerlink\" title=\"Webpack核心：tapable类\"></a>Webpack核心：tapable类</h3><p><code>tapable</code>是<code>webpack</code>的核心框架（4.0以上版本的API已经发生了变化），是一个基于事件流的框架，或者叫做发布订阅模式，或观察者模式，<code>webpack</code>的整个生命周期及其开放的自定义插件系统都离不开<code>tapable</code>的支持，研究其运行原理是阅读<code>webpack</code>源代码的第一步。官方仓库master分支的代码是经过ES6重构的，模块化拆分非常细，且加入了很多非核心逻辑，阅读难度较大。建议先从官方仓库中0.2版本的分支开始学习，整个源码只有400行，相对容易理解。</p>\n<ul>\n<li>0.2版本链接：<a href=\"https://github.com/webpack/tapable/tree/tapable-0.2\" target=\"_blank\" rel=\"noopener\">https://github.com/webpack/tapable/tree/tapable-0.2</a></li>\n</ul>\n<h3 id=\"代码地址\"><a href=\"#代码地址\" class=\"headerlink\" title=\"代码地址\"></a>代码地址</h3><p><a href=\"https://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project\" target=\"_blank\" rel=\"noopener\">https://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}