{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"283f8362195946f6fad7e1a75f425e32f9407509","modified":1543561873917},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1543197908975},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1543197908975},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1543197908975},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1543197908975},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1543197908975},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1543197908975},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1543197908976},{"_id":"themes/yilia/_config.yml","hash":"b7e9579a5c3bf47827c98df1a99626302e51dafb","modified":1543199905953},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1543197908984},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1543197909000},{"_id":"source/_posts/simpe-webpack-project.md","hash":"a5f7cbddc342a0f7c0b2ca9075ecdad763641178","modified":1543220964040},{"_id":"source/_posts/publish-subscribe.md","hash":"071a2d004165e3e8bc65fdf3ea46552c82df20e4","modified":1544144193637},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1543197908969},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"1efc9d034adf6456e816fcbb20023807ca64bbd0","modified":1543197950913},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1543197950928},{"_id":"themes/yilia/.git/index","hash":"fad728a3be630e7450c404b4a7c947941dd6c3f0","modified":1543201039895},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1543197908971},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1543197895662},{"_id":"themes/yilia/.git/packed-refs","hash":"76b1aa9479dd3de329935b6d94a6624c5f716d23","modified":1543197908967},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1543197908983},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1543197908983},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1543197908983},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1543197908983},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1543197908983},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1543197908984},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1543197908983},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1543197908976},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1543197908976},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1543197908976},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1543197908976},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1543197908977},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1543197908977},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1543197908984},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1543197908977},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1543197908995},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1543197908998},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1543197909000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543197908982},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1543197908999},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1543197908999},{"_id":"themes/yilia/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1543197895662},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1543197895662},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1543197895663},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1543197895663},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1543197895663},{"_id":"themes/yilia/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1543197895663},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1543197895662},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1543197895664},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1543197895663},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1543197895662},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1543197895663},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1543197908977},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1543197895664},{"_id":"themes/yilia/.git/logs/HEAD","hash":"0b830739ac86a8d49677baaef9ae75ddee73b0a9","modified":1543197908970},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1543197908977},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1543197908977},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1543197908978},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1543197908979},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1543197908979},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1543197908982},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1543197908979},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1543197908977},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1543197908982},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1543197908985},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1543197908984},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1543197908984},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1543197908985},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1543197908985},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1543197908985},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1543197908986},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1543197908986},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1543197908986},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1543197908988},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1543197908989},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1543197908990},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1543197908989},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1543197908990},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1543197908990},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1543197908991},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1543197908991},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1543197908991},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1543197908991},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1543197908991},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1543197908991},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1543197908991},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1543197908992},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1543197908992},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1543197908995},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1543197908992},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1543197908992},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1543197908992},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1543197908995},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1543197908997},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1543197908996},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1543197908996},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1543197908996},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1543197908993},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1543197908993},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1543197908993},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1543197908993},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1543197908993},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1543197908994},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1543197908994},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1543197908994},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1543197908994},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1543197908994},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1543197908994},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1543197908995},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1543197908997},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1543197908997},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1543197908997},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1543197908981},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1543197908970},{"_id":"themes/yilia/.git/objects/pack/pack-e80aef7d429734463d7865be31d8565b074a70db.idx","hash":"5f656732dcf155a47e724683b6040f93ae7ac424","modified":1543197908957},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1543197908979},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1543197908979},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1543197908980},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1543197908980},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1543197908980},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1543197908980},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1543197908980},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1543197908980},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1543197908980},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1543197908979},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1543197908988},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1543197908989},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1543197908988},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1543197908989},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1543197908986},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1543197908986},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1543197908987},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1543197908987},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1543197908987},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1543197908990},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1543197908990},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1543197908990},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"0b830739ac86a8d49677baaef9ae75ddee73b0a9","modified":1543197908970},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1543197908969},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"0b830739ac86a8d49677baaef9ae75ddee73b0a9","modified":1543197908968},{"_id":"themes/yilia/.git/objects/pack/pack-e80aef7d429734463d7865be31d8565b074a70db.pack","hash":"67a497b02625ce73eb3ffc1005f28427dce53688","modified":1543197908956},{"_id":"public/2018/12/07/publish-subscribe/index.html","hash":"8bfb391ede66fb56f9c7f2d15e56baf3f86be97e","modified":1544174953040},{"_id":"public/2018/11/26/simpe-webpack-project/index.html","hash":"a40d6fff1425e19264551701365ec8f91e425010","modified":1544174953040},{"_id":"public/archives/index.html","hash":"b850592fafd5b641fb35d83724dfaac7f154ad0c","modified":1544174953040},{"_id":"public/archives/2018/index.html","hash":"faf94311c5599c5d40f0b64aef044a5cde015283","modified":1544174953040},{"_id":"public/archives/2018/11/index.html","hash":"ae029c526d284fffa1b46f7ac749cefc328e1c16","modified":1544174953040},{"_id":"public/archives/2018/12/index.html","hash":"5faec4439497445a8818d7e8594d770305f2ea8b","modified":1544174953040},{"_id":"public/index.html","hash":"1d20d604a5cfebf41a3a6df6446b9bb58df6545d","modified":1544174953040},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1544174953042},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1544174953042},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1544174953042},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1544174953042},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1544174953042},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1544174953042},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1544174953042},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1544174953042},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1544174953042},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1544174953048},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1544174953049},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1544174953049},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1544174953051}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Webpack详解","date":"2018-11-26T08:29:24.040Z","_content":"<br/>\n\nWebpack\n===\n\n为什么要使用WebPack\n---\n现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法\n\n模块化，让我们可以把复杂的程序细化为小的文件;\n类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；\nScss，less等CSS预处理器\n...\n这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。\n\n什么是Webpack\n\n<!--more-->\n\n---\nwebpack可以看做是模块打包机：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用\n\nWebpack的工作方式\n---\nWebpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。\n\n开始使用Webpack\n===\n\n\n```\n// 全局安装\nnpm install -g webpack\nnpm install -g webpack-cli\nnpm install -g webpack-dev-server\n```\n\n正式使用webpack\n===\n\n####通过命令行使用\n```\n// entry file 表示入口文件\n// output file 表示出口文件的路径和文件名\nwebpack {entry file} {output file} \n在最新版本的使用方法\n// -o 参数表示指定之后的内容为输入文件\nwebpack {entry file} -o {output file}\n```\n\n####通过配置文件使用\n\n生成一个webpack.config.js文件，输入以下简单配置\n```\nmodule.exports = {\n  devtool: \"source-map\", // 打包方式，后续会提及\n  entry: __dirname + \"/app/main.js\", // 入口文件\n  output: {  // 出口文件\n    path: __dirname + \"/public/\",  // 出口文件路径\n    filename: 'bundle.js' // 出口文件名\n  }\n}\n```\n\n>__dirname 表示当前执行脚本的所在路径，为node环境的全局变量\n\nWebPack强大功能\n===\n####使用Source Maps（使调试更容易）\n\n| devtool选项 | 配置结果 |\n| :---------: | ----- |\n| source-map | 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；|\n| cheap-module-source-map | 在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便； |\n| eval-source-map | 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；|\n| cheap-module-eval-source-map | 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； |\n\n####使用Webpack构建本地服务器\n\n```vue\nmodule.exports = {\n  devtool: \"eval-source-map\", //\n  entry: __dirname + \"/app/main.js\",\n  output: {\n    path: __dirname + \"/public/\",\n    filename: 'bundle.js'\n  },\n  devServer: {\n    contentBase: './public', // 本地服务器所加载的页面所载目录\n    historyApiFallback: true, // 是否跳转\n    inline: true // 实时刷新\n  }\n```\n\n| devserver的配置 | 功能描述 |\n| :------------: | ----- |\n| contentBase | 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public\"目录）|\n| port | 设置默认监听端口，如果省略，默认为”8080“ |\n| inline | 设置为true，当源文件改变时会自动刷新页面 |\n| historyApiFallback | 在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html |\n####Loaders\n通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。\n对于Vue而言，使用Vue-loader进行解析各种Vue文件翻译成浏览器可编译的代码。\n\nwebpack官方推荐提供了两个utils\n```\nloader-utils // 提供很多有用的工具，其中最普遍使用的是获取options。\nschema-utils // 能够校验传来的options是否合法\n```\n\n#####Loader特性\n1. loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。\n2. loader 可以是同步的，也可以是异步的。\n3. loader 运行在 Node.js 中，并且能够执行任何可能的操作。\n4. loader 接收查询参数。用于对 loader 传递配置。\n5. loader 也能够使用 options 对象进行配置。\n6. 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。\n7. 插件(plugin)可以为 loader 带来更多特性。\n8. loader 能够产生额外的任意文件。\n\n\n####Babel\nBabel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：\n\n让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持；\n让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；\n\n#####Babel的安装和配置\nBabel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，对于每一个单独需要的功能的扩展，需要安装单独的包（常用的有解析Es6的babel-env-preset包）\n\n安装：\n>webpack 4.x | babel-loader 8.x | babel 7.x\n```vue\nnpm install -D babel-loader @babel/core @babel/preset-env webpack\n```\n>.babelrc文件配置\n```vue\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n>webpack 4.x | babel-loader 7.x | babel 6.x\n```vue\nnpm install -D babel-loader@7 babel-core babel-preset-env webpack\n```\n>.babelrc文件配置\n```vue\n{\n  \"presets\": [\n    [\n      \"env\",\n      {\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n\n####Plugins\n常用的插件\n\n| 插件名 | 说明 | 链接 |\n| :---: | ---- | ---- |\n| HtmlWebpackPlugin | 依据一个html模板，生成一个新的html文件，可做模板的替换，插入js | https://www.npmjs.com/package/html-webpack-plugin |\n| CleanWebpackPlugin | 在打包之前指定删除文件或文件夹 | https://www.npmjs.com/package/clean-webpack-plugin |\n| mini-css-extract-plugin | 将指定的内容从打包的文件分离，webpack4废除了extract-text-webpack-plugin这个插件 | https://www.npmjs.com/package/mini-css-extract-plugin |\n\n#####Webpack内置插件\n不做叙述https://www.webpackjs.com/plugins/\n\n#####编写一个Webpack插件\nWebpack插件由以下组成：\n>1. 一个JavaScript命名函数\n>2. 在插件函数的prototype上顶一个一个apply方法\n>3. 制定一个绑定webpack自身的事件钩子。\n>4. 处理webpack内部实例的特定数据。\n>5. 功能完成后调用webpack回调\n\n例：\n```vue\n// 一个 JavaScript 命名函数。\nconst pluginName = 'MyWebPackPlugin'\n\nclass FileListPlugin {\n  apply (compiler) {\n    compiler.hooks.run.tap(pluginName, (compilation) => {\n      console.log('Webpack开始构建中')\n    })\n  }\n}\n```\n\n其中有两个重要的回调：\n- compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。\n   - 使用方法\n   ```vue\n     compiler.hooks.someHook.tap(/* ... */);\n   ```\n   - someHook列表：https://webpack.js.org/api/compiler-hooks/\n  \n- compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。\n   - 使用方法\n   ```vue\n     compilation.hooks.someHook.tap(/* ... */);\n   ```\n   - someHook列表：https://webpack.js.org/api/compilation-hooks/\n\ntap方法表：\n\n| 方法名 | 功能描述 |\n| :---: | ----- |\n| tap | 同步方法，自动执行webpack的流程 |\n| tapAsync | 异步方法，必须在执行结束后调用webpack自己的callback()方法 |\n| tapPromise | 返回一个Promise方法，当异步任务完成后需要在添加resolve(）方法 |\n\n\n参考文档：\n- Webpack内部运行机制：https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，\n- Webpack4.0逐个击破：https://www.cnblogs.com/dashnowords/category/1284284.html\n- Webpack官网：https://webpack.js.org/ 【建议】\n\n\n### Webpack核心：tapable类\n\n```tapable```是```webpack```的核心框架（4.0以上版本的API已经发生了变化），是一个基于事件流的框架，或者叫做发布订阅模式，或观察者模式，```webpack```的整个生命周期及其开放的自定义插件系统都离不开```tapable```的支持，研究其运行原理是阅读```webpack```源代码的第一步。官方仓库master分支的代码是经过ES6重构的，模块化拆分非常细，且加入了很多非核心逻辑，阅读难度较大。建议先从官方仓库中0.2版本的分支开始学习，整个源码只有400行，相对容易理解。\n- 0.2版本链接：https://github.com/webpack/tapable/tree/tapable-0.2\n\n\n### 代码地址\nhttps://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project\n","source":"_posts/simpe-webpack-project.md","raw":"---\ntitle: Webpack详解\ndate: 2018年10月28日\n---\n<br/>\n\nWebpack\n===\n\n为什么要使用WebPack\n---\n现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法\n\n模块化，让我们可以把复杂的程序细化为小的文件;\n类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；\nScss，less等CSS预处理器\n...\n这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。\n\n什么是Webpack\n\n<!--more-->\n\n---\nwebpack可以看做是模块打包机：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用\n\nWebpack的工作方式\n---\nWebpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。\n\n开始使用Webpack\n===\n\n\n```\n// 全局安装\nnpm install -g webpack\nnpm install -g webpack-cli\nnpm install -g webpack-dev-server\n```\n\n正式使用webpack\n===\n\n####通过命令行使用\n```\n// entry file 表示入口文件\n// output file 表示出口文件的路径和文件名\nwebpack {entry file} {output file} \n在最新版本的使用方法\n// -o 参数表示指定之后的内容为输入文件\nwebpack {entry file} -o {output file}\n```\n\n####通过配置文件使用\n\n生成一个webpack.config.js文件，输入以下简单配置\n```\nmodule.exports = {\n  devtool: \"source-map\", // 打包方式，后续会提及\n  entry: __dirname + \"/app/main.js\", // 入口文件\n  output: {  // 出口文件\n    path: __dirname + \"/public/\",  // 出口文件路径\n    filename: 'bundle.js' // 出口文件名\n  }\n}\n```\n\n>__dirname 表示当前执行脚本的所在路径，为node环境的全局变量\n\nWebPack强大功能\n===\n####使用Source Maps（使调试更容易）\n\n| devtool选项 | 配置结果 |\n| :---------: | ----- |\n| source-map | 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；|\n| cheap-module-source-map | 在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便； |\n| eval-source-map | 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；|\n| cheap-module-eval-source-map | 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； |\n\n####使用Webpack构建本地服务器\n\n```vue\nmodule.exports = {\n  devtool: \"eval-source-map\", //\n  entry: __dirname + \"/app/main.js\",\n  output: {\n    path: __dirname + \"/public/\",\n    filename: 'bundle.js'\n  },\n  devServer: {\n    contentBase: './public', // 本地服务器所加载的页面所载目录\n    historyApiFallback: true, // 是否跳转\n    inline: true // 实时刷新\n  }\n```\n\n| devserver的配置 | 功能描述 |\n| :------------: | ----- |\n| contentBase | 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public\"目录）|\n| port | 设置默认监听端口，如果省略，默认为”8080“ |\n| inline | 设置为true，当源文件改变时会自动刷新页面 |\n| historyApiFallback | 在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html |\n####Loaders\n通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。\n对于Vue而言，使用Vue-loader进行解析各种Vue文件翻译成浏览器可编译的代码。\n\nwebpack官方推荐提供了两个utils\n```\nloader-utils // 提供很多有用的工具，其中最普遍使用的是获取options。\nschema-utils // 能够校验传来的options是否合法\n```\n\n#####Loader特性\n1. loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。\n2. loader 可以是同步的，也可以是异步的。\n3. loader 运行在 Node.js 中，并且能够执行任何可能的操作。\n4. loader 接收查询参数。用于对 loader 传递配置。\n5. loader 也能够使用 options 对象进行配置。\n6. 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。\n7. 插件(plugin)可以为 loader 带来更多特性。\n8. loader 能够产生额外的任意文件。\n\n\n####Babel\nBabel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：\n\n让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持；\n让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；\n\n#####Babel的安装和配置\nBabel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，对于每一个单独需要的功能的扩展，需要安装单独的包（常用的有解析Es6的babel-env-preset包）\n\n安装：\n>webpack 4.x | babel-loader 8.x | babel 7.x\n```vue\nnpm install -D babel-loader @babel/core @babel/preset-env webpack\n```\n>.babelrc文件配置\n```vue\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n>webpack 4.x | babel-loader 7.x | babel 6.x\n```vue\nnpm install -D babel-loader@7 babel-core babel-preset-env webpack\n```\n>.babelrc文件配置\n```vue\n{\n  \"presets\": [\n    [\n      \"env\",\n      {\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n\n####Plugins\n常用的插件\n\n| 插件名 | 说明 | 链接 |\n| :---: | ---- | ---- |\n| HtmlWebpackPlugin | 依据一个html模板，生成一个新的html文件，可做模板的替换，插入js | https://www.npmjs.com/package/html-webpack-plugin |\n| CleanWebpackPlugin | 在打包之前指定删除文件或文件夹 | https://www.npmjs.com/package/clean-webpack-plugin |\n| mini-css-extract-plugin | 将指定的内容从打包的文件分离，webpack4废除了extract-text-webpack-plugin这个插件 | https://www.npmjs.com/package/mini-css-extract-plugin |\n\n#####Webpack内置插件\n不做叙述https://www.webpackjs.com/plugins/\n\n#####编写一个Webpack插件\nWebpack插件由以下组成：\n>1. 一个JavaScript命名函数\n>2. 在插件函数的prototype上顶一个一个apply方法\n>3. 制定一个绑定webpack自身的事件钩子。\n>4. 处理webpack内部实例的特定数据。\n>5. 功能完成后调用webpack回调\n\n例：\n```vue\n// 一个 JavaScript 命名函数。\nconst pluginName = 'MyWebPackPlugin'\n\nclass FileListPlugin {\n  apply (compiler) {\n    compiler.hooks.run.tap(pluginName, (compilation) => {\n      console.log('Webpack开始构建中')\n    })\n  }\n}\n```\n\n其中有两个重要的回调：\n- compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。\n   - 使用方法\n   ```vue\n     compiler.hooks.someHook.tap(/* ... */);\n   ```\n   - someHook列表：https://webpack.js.org/api/compiler-hooks/\n  \n- compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。\n   - 使用方法\n   ```vue\n     compilation.hooks.someHook.tap(/* ... */);\n   ```\n   - someHook列表：https://webpack.js.org/api/compilation-hooks/\n\ntap方法表：\n\n| 方法名 | 功能描述 |\n| :---: | ----- |\n| tap | 同步方法，自动执行webpack的流程 |\n| tapAsync | 异步方法，必须在执行结束后调用webpack自己的callback()方法 |\n| tapPromise | 返回一个Promise方法，当异步任务完成后需要在添加resolve(）方法 |\n\n\n参考文档：\n- Webpack内部运行机制：https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，\n- Webpack4.0逐个击破：https://www.cnblogs.com/dashnowords/category/1284284.html\n- Webpack官网：https://webpack.js.org/ 【建议】\n\n\n### Webpack核心：tapable类\n\n```tapable```是```webpack```的核心框架（4.0以上版本的API已经发生了变化），是一个基于事件流的框架，或者叫做发布订阅模式，或观察者模式，```webpack```的整个生命周期及其开放的自定义插件系统都离不开```tapable```的支持，研究其运行原理是阅读```webpack```源代码的第一步。官方仓库master分支的代码是经过ES6重构的，模块化拆分非常细，且加入了很多非核心逻辑，阅读难度较大。建议先从官方仓库中0.2版本的分支开始学习，整个源码只有400行，相对容易理解。\n- 0.2版本链接：https://github.com/webpack/tapable/tree/tapable-0.2\n\n\n### 代码地址\nhttps://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project\n","slug":"simpe-webpack-project","published":1,"updated":"2018-11-26T08:29:24.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdtway80000vewksnsg0o68","content":"<p><br></p>\n<h1 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h1><h2 id=\"为什么要使用WebPack\"><a href=\"#为什么要使用WebPack\" class=\"headerlink\" title=\"为什么要使用WebPack\"></a>为什么要使用WebPack</h2><p>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p>\n<p>模块化，让我们可以把复杂的程序细化为小的文件;<br>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；<br>Scss，less等CSS预处理器<br>…<br>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。</p>\n<p>什么是Webpack</p>\n<a id=\"more\"></a>\n<hr>\n<p>webpack可以看做是模块打包机：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用</p>\n<h2 id=\"Webpack的工作方式\"><a href=\"#Webpack的工作方式\" class=\"headerlink\" title=\"Webpack的工作方式\"></a>Webpack的工作方式</h2><p>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p>\n<h1 id=\"开始使用Webpack\"><a href=\"#开始使用Webpack\" class=\"headerlink\" title=\"开始使用Webpack\"></a>开始使用Webpack</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 全局安装</span><br><span class=\"line\">npm install -g webpack</span><br><span class=\"line\">npm install -g webpack-cli</span><br><span class=\"line\">npm install -g webpack-dev-server</span><br></pre></td></tr></table></figure>\n<h1 id=\"正式使用webpack\"><a href=\"#正式使用webpack\" class=\"headerlink\" title=\"正式使用webpack\"></a>正式使用webpack</h1><p>####通过命令行使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry file 表示入口文件</span><br><span class=\"line\">// output file 表示出口文件的路径和文件名</span><br><span class=\"line\">webpack &#123;entry file&#125; &#123;output file&#125; </span><br><span class=\"line\">在最新版本的使用方法</span><br><span class=\"line\">// -o 参数表示指定之后的内容为输入文件</span><br><span class=\"line\">webpack &#123;entry file&#125; -o &#123;output file&#125;</span><br></pre></td></tr></table></figure></p>\n<p>####通过配置文件使用</p>\n<p>生成一个webpack.config.js文件，输入以下简单配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &quot;source-map&quot;, // 打包方式，后续会提及</span><br><span class=\"line\">  entry: __dirname + &quot;/app/main.js&quot;, // 入口文件</span><br><span class=\"line\">  output: &#123;  // 出口文件</span><br><span class=\"line\">    path: __dirname + &quot;/public/&quot;,  // 出口文件路径</span><br><span class=\"line\">    filename: &apos;bundle.js&apos; // 出口文件名</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>__dirname 表示当前执行脚本的所在路径，为node环境的全局变量</p>\n</blockquote>\n<h1 id=\"WebPack强大功能\"><a href=\"#WebPack强大功能\" class=\"headerlink\" title=\"WebPack强大功能\"></a>WebPack强大功能</h1><p>####使用Source Maps（使调试更容易）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">devtool选项</th>\n<th>配置结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">source-map</td>\n<td>在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cheap-module-source-map</td>\n<td>在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">eval-source-map</td>\n<td>使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cheap-module-eval-source-map</td>\n<td>这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；</td>\n</tr>\n</tbody>\n</table>\n<p>####使用Webpack构建本地服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &quot;eval-source-map&quot;, //</span><br><span class=\"line\">  entry: __dirname + &quot;/app/main.js&quot;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/public/&quot;,</span><br><span class=\"line\">    filename: &apos;bundle.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    contentBase: &apos;./public&apos;, // 本地服务器所加载的页面所载目录</span><br><span class=\"line\">    historyApiFallback: true, // 是否跳转</span><br><span class=\"line\">    inline: true // 实时刷新</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">devserver的配置</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">contentBase</td>\n<td>默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">port</td>\n<td>设置默认监听端口，如果省略，默认为”8080“</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">inline</td>\n<td>设置为true，当源文件改变时会自动刷新页面</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">historyApiFallback</td>\n<td>在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</td>\n</tr>\n</tbody>\n</table>\n<p>####Loaders<br>通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。<br>对于Vue而言，使用Vue-loader进行解析各种Vue文件翻译成浏览器可编译的代码。</p>\n<p>webpack官方推荐提供了两个utils<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loader-utils // 提供很多有用的工具，其中最普遍使用的是获取options。</span><br><span class=\"line\">schema-utils // 能够校验传来的options是否合法</span><br></pre></td></tr></table></figure></p>\n<p>#####Loader特性</p>\n<ol>\n<li>loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。</li>\n<li>loader 可以是同步的，也可以是异步的。</li>\n<li>loader 运行在 Node.js 中，并且能够执行任何可能的操作。</li>\n<li>loader 接收查询参数。用于对 loader 传递配置。</li>\n<li>loader 也能够使用 options 对象进行配置。</li>\n<li>除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。</li>\n<li>插件(plugin)可以为 loader 带来更多特性。</li>\n<li>loader 能够产生额外的任意文件。</li>\n</ol>\n<p>####Babel<br>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：</p>\n<p>让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持；<br>让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；</p>\n<p>#####Babel的安装和配置<br>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，对于每一个单独需要的功能的扩展，需要安装单独的包（常用的有解析Es6的babel-env-preset包）</p>\n<p>安装：</p>\n<blockquote>\n<p>webpack 4.x | babel-loader 8.x | babel 7.x<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -D babel-loader @babel/core @babel/preset-env webpack</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>.babelrc文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;@babel/preset-env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>webpack 4.x | babel-loader 7.x | babel 6.x<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -D babel-loader@7 babel-core babel-preset-env webpack</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>.babelrc文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>####Plugins<br>常用的插件</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">插件名</th>\n<th>说明</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">HtmlWebpackPlugin</td>\n<td>依据一个html模板，生成一个新的html文件，可做模板的替换，插入js</td>\n<td><a href=\"https://www.npmjs.com/package/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/html-webpack-plugin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CleanWebpackPlugin</td>\n<td>在打包之前指定删除文件或文件夹</td>\n<td><a href=\"https://www.npmjs.com/package/clean-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/clean-webpack-plugin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mini-css-extract-plugin</td>\n<td>将指定的内容从打包的文件分离，webpack4废除了extract-text-webpack-plugin这个插件</td>\n<td><a href=\"https://www.npmjs.com/package/mini-css-extract-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/mini-css-extract-plugin</a></td>\n</tr>\n</tbody>\n</table>\n<p>#####Webpack内置插件<br>不做叙述<a href=\"https://www.webpackjs.com/plugins/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/plugins/</a></p>\n<p>#####编写一个Webpack插件<br>Webpack插件由以下组成：</p>\n<blockquote>\n<ol>\n<li>一个JavaScript命名函数</li>\n<li>在插件函数的prototype上顶一个一个apply方法</li>\n<li>制定一个绑定webpack自身的事件钩子。</li>\n<li>处理webpack内部实例的特定数据。</li>\n<li>功能完成后调用webpack回调</li>\n</ol>\n</blockquote>\n<p>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个 JavaScript 命名函数。</span><br><span class=\"line\">const pluginName = &apos;MyWebPackPlugin&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">class FileListPlugin &#123;</span><br><span class=\"line\">  apply (compiler) &#123;</span><br><span class=\"line\">    compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;Webpack开始构建中&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中有两个重要的回调：</p>\n<ul>\n<li><p>compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p>\n<ul>\n<li><p>使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compiler.hooks.someHook.tap(/* ... */);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>someHook列表：<a href=\"https://webpack.js.org/api/compiler-hooks/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/api/compiler-hooks/</a></p>\n</li>\n</ul>\n</li>\n<li><p>compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p>\n<ul>\n<li><p>使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compilation.hooks.someHook.tap(/* ... */);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>someHook列表：<a href=\"https://webpack.js.org/api/compilation-hooks/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/api/compilation-hooks/</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>tap方法表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法名</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">tap</td>\n<td>同步方法，自动执行webpack的流程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tapAsync</td>\n<td>异步方法，必须在执行结束后调用webpack自己的callback()方法</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tapPromise</td>\n<td>返回一个Promise方法，当异步任务完成后需要在添加resolve(）方法</td>\n</tr>\n</tbody>\n</table>\n<p>参考文档：</p>\n<ul>\n<li>Webpack内部运行机制：<a href=\"https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，\" target=\"_blank\" rel=\"noopener\">https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，</a></li>\n<li>Webpack4.0逐个击破：<a href=\"https://www.cnblogs.com/dashnowords/category/1284284.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dashnowords/category/1284284.html</a></li>\n<li>Webpack官网：<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/</a> 【建议】</li>\n</ul>\n<h3 id=\"Webpack核心：tapable类\"><a href=\"#Webpack核心：tapable类\" class=\"headerlink\" title=\"Webpack核心：tapable类\"></a>Webpack核心：tapable类</h3><p><code>tapable</code>是<code>webpack</code>的核心框架（4.0以上版本的API已经发生了变化），是一个基于事件流的框架，或者叫做发布订阅模式，或观察者模式，<code>webpack</code>的整个生命周期及其开放的自定义插件系统都离不开<code>tapable</code>的支持，研究其运行原理是阅读<code>webpack</code>源代码的第一步。官方仓库master分支的代码是经过ES6重构的，模块化拆分非常细，且加入了很多非核心逻辑，阅读难度较大。建议先从官方仓库中0.2版本的分支开始学习，整个源码只有400行，相对容易理解。</p>\n<ul>\n<li>0.2版本链接：<a href=\"https://github.com/webpack/tapable/tree/tapable-0.2\" target=\"_blank\" rel=\"noopener\">https://github.com/webpack/tapable/tree/tapable-0.2</a></li>\n</ul>\n<h3 id=\"代码地址\"><a href=\"#代码地址\" class=\"headerlink\" title=\"代码地址\"></a>代码地址</h3><p><a href=\"https://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project\" target=\"_blank\" rel=\"noopener\">https://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project</a></p>\n","site":{"data":{}},"excerpt":"<p><br></p>\n<h1 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h1><h2 id=\"为什么要使用WebPack\"><a href=\"#为什么要使用WebPack\" class=\"headerlink\" title=\"为什么要使用WebPack\"></a>为什么要使用WebPack</h2><p>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p>\n<p>模块化，让我们可以把复杂的程序细化为小的文件;<br>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；<br>Scss，less等CSS预处理器<br>…<br>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。</p>\n<p>什么是Webpack</p>","more":"<hr>\n<p>webpack可以看做是模块打包机：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用</p>\n<h2 id=\"Webpack的工作方式\"><a href=\"#Webpack的工作方式\" class=\"headerlink\" title=\"Webpack的工作方式\"></a>Webpack的工作方式</h2><p>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p>\n<h1 id=\"开始使用Webpack\"><a href=\"#开始使用Webpack\" class=\"headerlink\" title=\"开始使用Webpack\"></a>开始使用Webpack</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 全局安装</span><br><span class=\"line\">npm install -g webpack</span><br><span class=\"line\">npm install -g webpack-cli</span><br><span class=\"line\">npm install -g webpack-dev-server</span><br></pre></td></tr></table></figure>\n<h1 id=\"正式使用webpack\"><a href=\"#正式使用webpack\" class=\"headerlink\" title=\"正式使用webpack\"></a>正式使用webpack</h1><p>####通过命令行使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry file 表示入口文件</span><br><span class=\"line\">// output file 表示出口文件的路径和文件名</span><br><span class=\"line\">webpack &#123;entry file&#125; &#123;output file&#125; </span><br><span class=\"line\">在最新版本的使用方法</span><br><span class=\"line\">// -o 参数表示指定之后的内容为输入文件</span><br><span class=\"line\">webpack &#123;entry file&#125; -o &#123;output file&#125;</span><br></pre></td></tr></table></figure></p>\n<p>####通过配置文件使用</p>\n<p>生成一个webpack.config.js文件，输入以下简单配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &quot;source-map&quot;, // 打包方式，后续会提及</span><br><span class=\"line\">  entry: __dirname + &quot;/app/main.js&quot;, // 入口文件</span><br><span class=\"line\">  output: &#123;  // 出口文件</span><br><span class=\"line\">    path: __dirname + &quot;/public/&quot;,  // 出口文件路径</span><br><span class=\"line\">    filename: &apos;bundle.js&apos; // 出口文件名</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>__dirname 表示当前执行脚本的所在路径，为node环境的全局变量</p>\n</blockquote>\n<h1 id=\"WebPack强大功能\"><a href=\"#WebPack强大功能\" class=\"headerlink\" title=\"WebPack强大功能\"></a>WebPack强大功能</h1><p>####使用Source Maps（使调试更容易）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">devtool选项</th>\n<th>配置结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">source-map</td>\n<td>在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cheap-module-source-map</td>\n<td>在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">eval-source-map</td>\n<td>使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cheap-module-eval-source-map</td>\n<td>这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；</td>\n</tr>\n</tbody>\n</table>\n<p>####使用Webpack构建本地服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &quot;eval-source-map&quot;, //</span><br><span class=\"line\">  entry: __dirname + &quot;/app/main.js&quot;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/public/&quot;,</span><br><span class=\"line\">    filename: &apos;bundle.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    contentBase: &apos;./public&apos;, // 本地服务器所加载的页面所载目录</span><br><span class=\"line\">    historyApiFallback: true, // 是否跳转</span><br><span class=\"line\">    inline: true // 实时刷新</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">devserver的配置</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">contentBase</td>\n<td>默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">port</td>\n<td>设置默认监听端口，如果省略，默认为”8080“</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">inline</td>\n<td>设置为true，当源文件改变时会自动刷新页面</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">historyApiFallback</td>\n<td>在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</td>\n</tr>\n</tbody>\n</table>\n<p>####Loaders<br>通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。<br>对于Vue而言，使用Vue-loader进行解析各种Vue文件翻译成浏览器可编译的代码。</p>\n<p>webpack官方推荐提供了两个utils<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loader-utils // 提供很多有用的工具，其中最普遍使用的是获取options。</span><br><span class=\"line\">schema-utils // 能够校验传来的options是否合法</span><br></pre></td></tr></table></figure></p>\n<p>#####Loader特性</p>\n<ol>\n<li>loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。</li>\n<li>loader 可以是同步的，也可以是异步的。</li>\n<li>loader 运行在 Node.js 中，并且能够执行任何可能的操作。</li>\n<li>loader 接收查询参数。用于对 loader 传递配置。</li>\n<li>loader 也能够使用 options 对象进行配置。</li>\n<li>除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。</li>\n<li>插件(plugin)可以为 loader 带来更多特性。</li>\n<li>loader 能够产生额外的任意文件。</li>\n</ol>\n<p>####Babel<br>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：</p>\n<p>让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持；<br>让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；</p>\n<p>#####Babel的安装和配置<br>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，对于每一个单独需要的功能的扩展，需要安装单独的包（常用的有解析Es6的babel-env-preset包）</p>\n<p>安装：</p>\n<blockquote>\n<p>webpack 4.x | babel-loader 8.x | babel 7.x<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -D babel-loader @babel/core @babel/preset-env webpack</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>.babelrc文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;@babel/preset-env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>webpack 4.x | babel-loader 7.x | babel 6.x<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -D babel-loader@7 babel-core babel-preset-env webpack</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>.babelrc文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>####Plugins<br>常用的插件</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">插件名</th>\n<th>说明</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">HtmlWebpackPlugin</td>\n<td>依据一个html模板，生成一个新的html文件，可做模板的替换，插入js</td>\n<td><a href=\"https://www.npmjs.com/package/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/html-webpack-plugin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CleanWebpackPlugin</td>\n<td>在打包之前指定删除文件或文件夹</td>\n<td><a href=\"https://www.npmjs.com/package/clean-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/clean-webpack-plugin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mini-css-extract-plugin</td>\n<td>将指定的内容从打包的文件分离，webpack4废除了extract-text-webpack-plugin这个插件</td>\n<td><a href=\"https://www.npmjs.com/package/mini-css-extract-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/mini-css-extract-plugin</a></td>\n</tr>\n</tbody>\n</table>\n<p>#####Webpack内置插件<br>不做叙述<a href=\"https://www.webpackjs.com/plugins/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/plugins/</a></p>\n<p>#####编写一个Webpack插件<br>Webpack插件由以下组成：</p>\n<blockquote>\n<ol>\n<li>一个JavaScript命名函数</li>\n<li>在插件函数的prototype上顶一个一个apply方法</li>\n<li>制定一个绑定webpack自身的事件钩子。</li>\n<li>处理webpack内部实例的特定数据。</li>\n<li>功能完成后调用webpack回调</li>\n</ol>\n</blockquote>\n<p>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个 JavaScript 命名函数。</span><br><span class=\"line\">const pluginName = &apos;MyWebPackPlugin&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">class FileListPlugin &#123;</span><br><span class=\"line\">  apply (compiler) &#123;</span><br><span class=\"line\">    compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;Webpack开始构建中&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中有两个重要的回调：</p>\n<ul>\n<li><p>compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p>\n<ul>\n<li><p>使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compiler.hooks.someHook.tap(/* ... */);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>someHook列表：<a href=\"https://webpack.js.org/api/compiler-hooks/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/api/compiler-hooks/</a></p>\n</li>\n</ul>\n</li>\n<li><p>compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p>\n<ul>\n<li><p>使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compilation.hooks.someHook.tap(/* ... */);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>someHook列表：<a href=\"https://webpack.js.org/api/compilation-hooks/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/api/compilation-hooks/</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>tap方法表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法名</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">tap</td>\n<td>同步方法，自动执行webpack的流程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tapAsync</td>\n<td>异步方法，必须在执行结束后调用webpack自己的callback()方法</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tapPromise</td>\n<td>返回一个Promise方法，当异步任务完成后需要在添加resolve(）方法</td>\n</tr>\n</tbody>\n</table>\n<p>参考文档：</p>\n<ul>\n<li>Webpack内部运行机制：<a href=\"https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，\" target=\"_blank\" rel=\"noopener\">https://fengmiaosen.github.io/2017/03/21/webpack-core-code/，</a></li>\n<li>Webpack4.0逐个击破：<a href=\"https://www.cnblogs.com/dashnowords/category/1284284.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dashnowords/category/1284284.html</a></li>\n<li>Webpack官网：<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/</a> 【建议】</li>\n</ul>\n<h3 id=\"Webpack核心：tapable类\"><a href=\"#Webpack核心：tapable类\" class=\"headerlink\" title=\"Webpack核心：tapable类\"></a>Webpack核心：tapable类</h3><p><code>tapable</code>是<code>webpack</code>的核心框架（4.0以上版本的API已经发生了变化），是一个基于事件流的框架，或者叫做发布订阅模式，或观察者模式，<code>webpack</code>的整个生命周期及其开放的自定义插件系统都离不开<code>tapable</code>的支持，研究其运行原理是阅读<code>webpack</code>源代码的第一步。官方仓库master分支的代码是经过ES6重构的，模块化拆分非常细，且加入了很多非核心逻辑，阅读难度较大。建议先从官方仓库中0.2版本的分支开始学习，整个源码只有400行，相对容易理解。</p>\n<ul>\n<li>0.2版本链接：<a href=\"https://github.com/webpack/tapable/tree/tapable-0.2\" target=\"_blank\" rel=\"noopener\">https://github.com/webpack/tapable/tree/tapable-0.2</a></li>\n</ul>\n<h3 id=\"代码地址\"><a href=\"#代码地址\" class=\"headerlink\" title=\"代码地址\"></a>代码地址</h3><p><a href=\"https://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project\" target=\"_blank\" rel=\"noopener\">https://github.com/SalterYu/MyBlog/tree/master/webpack-sample-project</a></p>"},{"title":"Vue原理(一)","date":"2018-12-07T00:56:33.637Z","_content":"<br/>\n\n观察者模式设计\n====\n在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。(来自wiki百科)\n\n例：小明去买房（观察者Observer），去找房产中心（目标主体Subject），发布者说等有合适的就通知小明。这样就形成了一个环\n\n发布订阅模式设计\n====\n\n在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。(来自wiki百科)\n\n例：小明去买房（订阅者Subscriber），委托第三方中介去买房（调度中心Event Channel），等待第三方中介回馈消息，过了一会房产中心（发布者Publisher）发布消息给第三方中介，第三方中介发现正好符合小明的要求（key）就去通知小明。\n\n两者区别\n====\n\n<img src=\"https://user-gold-cdn.xitu.io/2017/11/22/15fe1b1f174cd376?imageslim\" />\n\n图片来源: <a href=\"http://developers-club.com/posts/270339/\" >developers-club</a>\n\n>1. 在观察者模式中，观察者是知道主体Subject的，而Subject一直保持对观察者的记录。相反在发布订阅中，两者并不互相了解，只能通过代理进行沟通。\n>2. 观察者模式大多数是同步，如：事件触发，而发布订阅模式大多数是异步，如：消息队列。\n>3. 观察者模式是一种紧耦合状态，而发布订阅模式是一种松耦合的状态。\n>4. 观察者模式是通过主体本身去遍历观察者（维护的是观察者），然后调用订阅者的通知方法去实现。而发布订阅则是通过事件管道去通知（维护的是事件）。\n\nMVVM和MVC的区别\n====\nMVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。\n\n在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。\n\nViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\n\nVue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 \n\n回到Vue\n==== \n\nVue的双向绑定则是利用了观察者模式实现的。\n参考链接：https://segmentfault.com/a/1190000013338801\n\n<pre>\n<code>\nclass Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 为了标明该对象已经被observer过\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n</code>\n</pre>\n\n <pre><code>\n // 拦截数据\n export function defineReactive (\n   obj: Object,\n   key: string,\n   val: any,\n   customSetter?: ?Function,\n   shallow?: boolean\n ) {\n   const dep = new Dep()\n \n   const property = Object.getOwnPropertyDescriptor(obj, key)\n   if (property && property.configurable === false) {\n     return\n   }\n \n   // cater for pre-defined getter/setters\n   const getter = property && property.get\n   const setter = property && property.set\n   if ((!getter || setter) && arguments.length === 2) {\n     val = obj[key]\n   }\n \n   let childOb = !shallow && observe(val)\n   Object.defineProperty(obj, key, {\n     enumerable: true,\n     configurable: true,\n     get: function reactiveGetter () {\n       const value = getter ? getter.call(obj) : val\n       if (Dep.target) {\n         dep.depend()\n         if (childOb) {\n           childOb.dep.depend()\n           if (Array.isArray(value)) {\n             dependArray(value)\n           }\n         }\n       }\n       return value\n     },\n     set: function reactiveSetter (newVal) {\n       const value = getter ? getter.call(obj) : val\n       /* eslint-disable no-self-compare */\n       if (newVal === value || (newVal !== newVal && value !== value)) {\n         return\n       }\n       /* eslint-enable no-self-compare */\n       if (process.env.NODE_ENV !== 'production' && customSetter) {\n         customSetter()\n       }\n       // #7981: for accessor properties without setter\n       if (getter && !setter) return\n       if (setter) {\n         setter.call(obj, newVal)\n       } else {\n         val = newVal\n       }\n       childOb = !shallow && observe(newVal)\n       // 使当前的调度中心通知所有Watcher\n       dep.notify()\n     }\n   })\n }\n </code></pre>\n \n Vue模版渲染\n \n 在执行npm run dev或者npm run build的时候，Vue使用rollup进行编译，入口文件为entry-runtime-with-compiler.js，\n 该文件有以下代码，在runtime的时候执行\n ```vue\n // entry-runtime-with-compiler.js，\n import Vue from './runtime/index'\n ```\n ```vue\n // runtime/index.js\n import Vue from 'core/index'\n ```\n ```vue\n // core/index.js\n // 导入Vue的实例，初始化全局Api\nimport Vue from './instance/index'\nimport { initGlobalAPI } from './global-api/index'\nimport { isServerRendering } from 'core/util/env'\nimport { FunctionalRenderContext } from 'core/vdom/create-functional-component'\ninitGlobalAPI(Vue)\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n})\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n})\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n})\n\nVue.version = '__VERSION__'\n\nexport default Vue\n```\n```vue\n// instance/index.js\n// 做Vue的各种模块混\n// 每当new Vue的时候执行初始化\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n// 初始化混入 *\ninitMixin(Vue)\n\nstateMixin(Vue)\n// 事件混入\neventsMixin(Vue)\n// 生命周期的混入 *\nlifecycleMixin(Vue)\n// render函数混入 *\nrenderMixin(Vue)\n```\n```vue\n// 走进this._init(options)方法\n// 最主要的是\n// 触发Vue原型上的$mount方法，进行compile。compiler/index.js会返回render函数和sataicRenderFns函数。等待renderMixin函数的使用。\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n\n```\n在render.js的renderMixi方法中使用了以下方法\n```vue\n// core/instance/render.js文件中 line:83\n// 这里就是将template进行转换\ntry {\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n  }\n\n// render方法 ，由compiler方法返回，功能是使用with语句的作用是将代码的作用域设置到一个特定的作用域中。之后的msg的都是访问的this中的属性，而this就是\n// vm._renderProxy（vm的一个代理实例），由于Vue自己的proxy方法会将this.data.msg的值的获取改为this.msg，因此msg就变成了\n// options中的data的一个值传入。经过_c (createElement)方法完成template模版的替换。\n(function anonymous(\n) {\nwith(this){return _c('div',{attrs:{\"id\":\"el\"}},[_v(\"\\n  \"+_s(msg)+_s(msg)+\"\\n\")])}\n})\n```\n###梳理下Vue初始化流程：\n>1. 在<font color=pink size=4>new</font>实例Vue的时候，调用<font color=\"pink\" size=\"4\">this._init(options)</font>方法将传入的对象作为$options属性存在Vue实例中。并将各种组件的props，父子组件的inject属性和指令进行合并，开始走created流程。\n>2. 执行了<font color=\"pink\" size=\"4\">initState()</font>方法，对所有数据包括(props和methods)进行拦截，给数据进行observer，并且给被observer过的属性增加ob属性标识，来表示已经被observer。【数据拦截原理见上方观察者模式】\n>> <font color=\"grey\" size=2>补充:由于遍历对象的属性，则每个对象都会有一个Dep，且一个Dep可能会有许多Watcher，因为可能这个属性的值被多处使用，所以当数据改变，则遍历触发自身的所有的Watcher。即dep.notify() => Array.forEach.update</font>\n>3. 之后调用<font color=pink size=4>vm.$mount(el)</font>方法, 进行Vue的mounted。\n>4. 在这之前用一个字段mount存储目标的自定义mounted方法后调用公用的mounted方法，在mounted过程中调用<font color=pink size=4>compilerToFunctions()</font>方法返回一个render函数(一个with关键字函数，切设计虚拟DOM树)，并设置<font color=pink size=4>options.render = render</font>。\n>5. 在公用的mounted方法后有一个<font color=\"pink\" size=\"4\">return mount.call(this, el, hydrating)</font>方法，开始调用自定义的mounted方法。\n>6. 在自定义mounted方法中，调用<font color=\"pink\" size=\"4\">mountComponent()</font>完成观察者模式：实例Watcher类。\n>7. 每个Watcher类在constructor中会调用<font color=\"pink\" size=\"4\">this.value = this.lazy ? undefined : this.get()</font>, 而this.get()方法将自身依赖push给全局的targetStack数组中，并把Dep.target的指向指为当前Watcher。 当要获取属性的值的时候，相应属性自身的get方法之前，将会被之前observer数据拦截，此时Dep.target就存在值，就调用了内部的<font color=\"pink\" size=\"4\">dep.depend()</font>方法实现依赖关系，将当前Watcher放入当前Dep中，等待后期的数据更新。这样就行成了一个依赖环。\n\n最后贴一下官网的生命周期图<a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\">Vue生命周期</a>\n\nVue的详细模板编译原理<a href=\"https://github.com/berwin/Blog/issues/18\">传送门</a>\n\n\n","source":"_posts/publish-subscribe.md","raw":"---\ntitle: Vue原理(一)\ndate: 2018年11月24日\n---\n<br/>\n\n观察者模式设计\n====\n在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。(来自wiki百科)\n\n例：小明去买房（观察者Observer），去找房产中心（目标主体Subject），发布者说等有合适的就通知小明。这样就形成了一个环\n\n发布订阅模式设计\n====\n\n在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。(来自wiki百科)\n\n例：小明去买房（订阅者Subscriber），委托第三方中介去买房（调度中心Event Channel），等待第三方中介回馈消息，过了一会房产中心（发布者Publisher）发布消息给第三方中介，第三方中介发现正好符合小明的要求（key）就去通知小明。\n\n两者区别\n====\n\n<img src=\"https://user-gold-cdn.xitu.io/2017/11/22/15fe1b1f174cd376?imageslim\" />\n\n图片来源: <a href=\"http://developers-club.com/posts/270339/\" >developers-club</a>\n\n>1. 在观察者模式中，观察者是知道主体Subject的，而Subject一直保持对观察者的记录。相反在发布订阅中，两者并不互相了解，只能通过代理进行沟通。\n>2. 观察者模式大多数是同步，如：事件触发，而发布订阅模式大多数是异步，如：消息队列。\n>3. 观察者模式是一种紧耦合状态，而发布订阅模式是一种松耦合的状态。\n>4. 观察者模式是通过主体本身去遍历观察者（维护的是观察者），然后调用订阅者的通知方法去实现。而发布订阅则是通过事件管道去通知（维护的是事件）。\n\nMVVM和MVC的区别\n====\nMVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。\n\n在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。\n\nViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\n\nVue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 \n\n回到Vue\n==== \n\nVue的双向绑定则是利用了观察者模式实现的。\n参考链接：https://segmentfault.com/a/1190000013338801\n\n<pre>\n<code>\nclass Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 为了标明该对象已经被observer过\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n</code>\n</pre>\n\n <pre><code>\n // 拦截数据\n export function defineReactive (\n   obj: Object,\n   key: string,\n   val: any,\n   customSetter?: ?Function,\n   shallow?: boolean\n ) {\n   const dep = new Dep()\n \n   const property = Object.getOwnPropertyDescriptor(obj, key)\n   if (property && property.configurable === false) {\n     return\n   }\n \n   // cater for pre-defined getter/setters\n   const getter = property && property.get\n   const setter = property && property.set\n   if ((!getter || setter) && arguments.length === 2) {\n     val = obj[key]\n   }\n \n   let childOb = !shallow && observe(val)\n   Object.defineProperty(obj, key, {\n     enumerable: true,\n     configurable: true,\n     get: function reactiveGetter () {\n       const value = getter ? getter.call(obj) : val\n       if (Dep.target) {\n         dep.depend()\n         if (childOb) {\n           childOb.dep.depend()\n           if (Array.isArray(value)) {\n             dependArray(value)\n           }\n         }\n       }\n       return value\n     },\n     set: function reactiveSetter (newVal) {\n       const value = getter ? getter.call(obj) : val\n       /* eslint-disable no-self-compare */\n       if (newVal === value || (newVal !== newVal && value !== value)) {\n         return\n       }\n       /* eslint-enable no-self-compare */\n       if (process.env.NODE_ENV !== 'production' && customSetter) {\n         customSetter()\n       }\n       // #7981: for accessor properties without setter\n       if (getter && !setter) return\n       if (setter) {\n         setter.call(obj, newVal)\n       } else {\n         val = newVal\n       }\n       childOb = !shallow && observe(newVal)\n       // 使当前的调度中心通知所有Watcher\n       dep.notify()\n     }\n   })\n }\n </code></pre>\n \n Vue模版渲染\n \n 在执行npm run dev或者npm run build的时候，Vue使用rollup进行编译，入口文件为entry-runtime-with-compiler.js，\n 该文件有以下代码，在runtime的时候执行\n ```vue\n // entry-runtime-with-compiler.js，\n import Vue from './runtime/index'\n ```\n ```vue\n // runtime/index.js\n import Vue from 'core/index'\n ```\n ```vue\n // core/index.js\n // 导入Vue的实例，初始化全局Api\nimport Vue from './instance/index'\nimport { initGlobalAPI } from './global-api/index'\nimport { isServerRendering } from 'core/util/env'\nimport { FunctionalRenderContext } from 'core/vdom/create-functional-component'\ninitGlobalAPI(Vue)\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n})\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n})\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n})\n\nVue.version = '__VERSION__'\n\nexport default Vue\n```\n```vue\n// instance/index.js\n// 做Vue的各种模块混\n// 每当new Vue的时候执行初始化\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n// 初始化混入 *\ninitMixin(Vue)\n\nstateMixin(Vue)\n// 事件混入\neventsMixin(Vue)\n// 生命周期的混入 *\nlifecycleMixin(Vue)\n// render函数混入 *\nrenderMixin(Vue)\n```\n```vue\n// 走进this._init(options)方法\n// 最主要的是\n// 触发Vue原型上的$mount方法，进行compile。compiler/index.js会返回render函数和sataicRenderFns函数。等待renderMixin函数的使用。\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n\n```\n在render.js的renderMixi方法中使用了以下方法\n```vue\n// core/instance/render.js文件中 line:83\n// 这里就是将template进行转换\ntry {\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n  }\n\n// render方法 ，由compiler方法返回，功能是使用with语句的作用是将代码的作用域设置到一个特定的作用域中。之后的msg的都是访问的this中的属性，而this就是\n// vm._renderProxy（vm的一个代理实例），由于Vue自己的proxy方法会将this.data.msg的值的获取改为this.msg，因此msg就变成了\n// options中的data的一个值传入。经过_c (createElement)方法完成template模版的替换。\n(function anonymous(\n) {\nwith(this){return _c('div',{attrs:{\"id\":\"el\"}},[_v(\"\\n  \"+_s(msg)+_s(msg)+\"\\n\")])}\n})\n```\n###梳理下Vue初始化流程：\n>1. 在<font color=pink size=4>new</font>实例Vue的时候，调用<font color=\"pink\" size=\"4\">this._init(options)</font>方法将传入的对象作为$options属性存在Vue实例中。并将各种组件的props，父子组件的inject属性和指令进行合并，开始走created流程。\n>2. 执行了<font color=\"pink\" size=\"4\">initState()</font>方法，对所有数据包括(props和methods)进行拦截，给数据进行observer，并且给被observer过的属性增加ob属性标识，来表示已经被observer。【数据拦截原理见上方观察者模式】\n>> <font color=\"grey\" size=2>补充:由于遍历对象的属性，则每个对象都会有一个Dep，且一个Dep可能会有许多Watcher，因为可能这个属性的值被多处使用，所以当数据改变，则遍历触发自身的所有的Watcher。即dep.notify() => Array.forEach.update</font>\n>3. 之后调用<font color=pink size=4>vm.$mount(el)</font>方法, 进行Vue的mounted。\n>4. 在这之前用一个字段mount存储目标的自定义mounted方法后调用公用的mounted方法，在mounted过程中调用<font color=pink size=4>compilerToFunctions()</font>方法返回一个render函数(一个with关键字函数，切设计虚拟DOM树)，并设置<font color=pink size=4>options.render = render</font>。\n>5. 在公用的mounted方法后有一个<font color=\"pink\" size=\"4\">return mount.call(this, el, hydrating)</font>方法，开始调用自定义的mounted方法。\n>6. 在自定义mounted方法中，调用<font color=\"pink\" size=\"4\">mountComponent()</font>完成观察者模式：实例Watcher类。\n>7. 每个Watcher类在constructor中会调用<font color=\"pink\" size=\"4\">this.value = this.lazy ? undefined : this.get()</font>, 而this.get()方法将自身依赖push给全局的targetStack数组中，并把Dep.target的指向指为当前Watcher。 当要获取属性的值的时候，相应属性自身的get方法之前，将会被之前observer数据拦截，此时Dep.target就存在值，就调用了内部的<font color=\"pink\" size=\"4\">dep.depend()</font>方法实现依赖关系，将当前Watcher放入当前Dep中，等待后期的数据更新。这样就行成了一个依赖环。\n\n最后贴一下官网的生命周期图<a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\">Vue生命周期</a>\n\nVue的详细模板编译原理<a href=\"https://github.com/berwin/Blog/issues/18\">传送门</a>\n\n\n","slug":"publish-subscribe","published":1,"updated":"2018-12-07T00:56:33.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdtwayc0001vewk5ucxf4k3","content":"<p><br></p>\n<h1 id=\"观察者模式设计\"><a href=\"#观察者模式设计\" class=\"headerlink\" title=\"观察者模式设计\"></a>观察者模式设计</h1><p>在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。(来自wiki百科)</p>\n<p>例：小明去买房（观察者Observer），去找房产中心（目标主体Subject），发布者说等有合适的就通知小明。这样就形成了一个环</p>\n<h1 id=\"发布订阅模式设计\"><a href=\"#发布订阅模式设计\" class=\"headerlink\" title=\"发布订阅模式设计\"></a>发布订阅模式设计</h1><p>在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。(来自wiki百科)</p>\n<p>例：小明去买房（订阅者Subscriber），委托第三方中介去买房（调度中心Event Channel），等待第三方中介回馈消息，过了一会房产中心（发布者Publisher）发布消息给第三方中介，第三方中介发现正好符合小明的要求（key）就去通知小明。</p>\n<h1 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h1><p><img src=\"https://user-gold-cdn.xitu.io/2017/11/22/15fe1b1f174cd376?imageslim\"></p>\n<p>图片来源: <a href=\"http://developers-club.com/posts/270339/\" target=\"_blank\" rel=\"noopener\">developers-club</a></p>\n<blockquote>\n<ol>\n<li>在观察者模式中，观察者是知道主体Subject的，而Subject一直保持对观察者的记录。相反在发布订阅中，两者并不互相了解，只能通过代理进行沟通。</li>\n<li>观察者模式大多数是同步，如：事件触发，而发布订阅模式大多数是异步，如：消息队列。</li>\n<li>观察者模式是一种紧耦合状态，而发布订阅模式是一种松耦合的状态。</li>\n<li>观察者模式是通过主体本身去遍历观察者（维护的是观察者），然后调用订阅者的通知方法去实现。而发布订阅则是通过事件管道去通知（维护的是事件）。</li>\n</ol>\n</blockquote>\n<h1 id=\"MVVM和MVC的区别\"><a href=\"#MVVM和MVC的区别\" class=\"headerlink\" title=\"MVVM和MVC的区别\"></a>MVVM和MVC的区别</h1><p>MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>\n<p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>\n<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>\n<p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 </p>\n<h1 id=\"回到Vue\"><a href=\"#回到Vue\" class=\"headerlink\" title=\"回到Vue\"></a>回到Vue</h1><p>Vue的双向绑定则是利用了观察者模式实现的。<br>参考链接：<a href=\"https://segmentfault.com/a/1190000013338801\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000013338801</a></p>\n<pre>\n<code>\nclass Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 为了标明该对象已经被observer过\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n</any></code>\n</pre>\n\n <pre><code>\n // 拦截数据\n export function defineReactive (\n   obj: Object,\n   key: string,\n   val: any,\n   customSetter?: ?Function,\n   shallow?: boolean\n ) {\n   const dep = new Dep()\n\n   const property = Object.getOwnPropertyDescriptor(obj, key)\n   if (property && property.configurable === false) {\n     return\n   }\n\n   // cater for pre-defined getter/setters\n   const getter = property && property.get\n   const setter = property && property.set\n   if ((!getter || setter) && arguments.length === 2) {\n     val = obj[key]\n   }\n\n   let childOb = !shallow && observe(val)\n   Object.defineProperty(obj, key, {\n     enumerable: true,\n     configurable: true,\n     get: function reactiveGetter () {\n       const value = getter ? getter.call(obj) : val\n       if (Dep.target) {\n         dep.depend()\n         if (childOb) {\n           childOb.dep.depend()\n           if (Array.isArray(value)) {\n             dependArray(value)\n           }\n         }\n       }\n       return value\n     },\n     set: function reactiveSetter (newVal) {\n       const value = getter ? getter.call(obj) : val\n       /* eslint-disable no-self-compare */\n       if (newVal === value || (newVal !== newVal && value !== value)) {\n         return\n       }\n       /* eslint-enable no-self-compare */\n       if (process.env.NODE_ENV !== 'production' && customSetter) {\n         customSetter()\n       }\n       // #7981: for accessor properties without setter\n       if (getter && !setter) return\n       if (setter) {\n         setter.call(obj, newVal)\n       } else {\n         val = newVal\n       }\n       childOb = !shallow && observe(newVal)\n       // 使当前的调度中心通知所有Watcher\n       dep.notify()\n     }\n   })\n }\n </code></pre>\n\n<p> Vue模版渲染</p>\n<p> 在执行npm run dev或者npm run build的时候，Vue使用rollup进行编译，入口文件为entry-runtime-with-compiler.js，<br> 该文件有以下代码，在runtime的时候执行<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry-runtime-with-compiler.js，</span><br><span class=\"line\">import Vue from &apos;./runtime/index&apos;</span><br></pre></td></tr></table></figure></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// runtime/index.js</span><br><span class=\"line\">import Vue from &apos;core/index&apos;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // core/index.js</span><br><span class=\"line\"> // 导入Vue的实例，初始化全局Api</span><br><span class=\"line\">import Vue from &apos;./instance/index&apos;</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;</span><br><span class=\"line\">import &#123; isServerRendering &#125; from &apos;core/util/env&apos;</span><br><span class=\"line\">import &#123; FunctionalRenderContext &#125; from &apos;core/vdom/create-functional-component&apos;</span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123;</span><br><span class=\"line\">  get: isServerRendering</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$ssrContext&apos;, &#123;</span><br><span class=\"line\">  get () &#123;</span><br><span class=\"line\">    /* istanbul ignore next */</span><br><span class=\"line\">    return this.$vnode &amp;&amp; this.$vnode.ssrContext</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// expose FunctionalRenderContext for ssr runtime helper installation</span><br><span class=\"line\">Object.defineProperty(Vue, &apos;FunctionalRenderContext&apos;, &#123;</span><br><span class=\"line\">  value: FunctionalRenderContext</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.version = &apos;__VERSION__&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// instance/index.js</span><br><span class=\"line\">// 做Vue的各种模块混</span><br><span class=\"line\">// 每当new Vue的时候执行初始化</span><br><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 初始化混入 *</span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\">// 事件混入</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\">// 生命周期的混入 *</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\">// render函数混入 *</span><br><span class=\"line\">renderMixin(Vue)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 走进this._init(options)方法</span><br><span class=\"line\">// 最主要的是</span><br><span class=\"line\">// 触发Vue原型上的$mount方法，进行compile。compiler/index.js会返回render函数和sataicRenderFns函数。等待renderMixin函数的使用。</span><br><span class=\"line\">    if (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在render.js的renderMixi方法中使用了以下方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// core/instance/render.js文件中 line:83</span><br><span class=\"line\">// 这里就是将template进行转换</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// render方法 ，由compiler方法返回，功能是使用with语句的作用是将代码的作用域设置到一个特定的作用域中。之后的msg的都是访问的this中的属性，而this就是</span><br><span class=\"line\">// vm._renderProxy（vm的一个代理实例），由于Vue自己的proxy方法会将this.data.msg的值的获取改为this.msg，因此msg就变成了</span><br><span class=\"line\">// options中的data的一个值传入。经过_c (createElement)方法完成template模版的替换。</span><br><span class=\"line\">(function anonymous(</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">with(this)&#123;return _c(&apos;div&apos;,&#123;attrs:&#123;&quot;id&quot;:&quot;el&quot;&#125;&#125;,[_v(&quot;\\n  &quot;+_s(msg)+_s(msg)+&quot;\\n&quot;)])&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>###梳理下Vue初始化流程：</p>\n<blockquote>\n<ol>\n<li>在<font color=\"pink\" size=\"4\">new</font>实例Vue的时候，调用<font color=\"pink\" size=\"4\">this._init(options)</font>方法将传入的对象作为$options属性存在Vue实例中。并将各种组件的props，父子组件的inject属性和指令进行合并，开始走created流程。</li>\n<li>执行了<font color=\"pink\" size=\"4\">initState()</font>方法，对所有数据包括(props和methods)进行拦截，给数据进行observer，并且给被observer过的属性增加ob属性标识，来表示已经被observer。【数据拦截原理见上方观察者模式】<blockquote>\n<font color=\"grey\" size=\"2\">补充:由于遍历对象的属性，则每个对象都会有一个Dep，且一个Dep可能会有许多Watcher，因为可能这个属性的值被多处使用，所以当数据改变，则遍历触发自身的所有的Watcher。即dep.notify() =&gt; Array.forEach.update</font></blockquote>\n</li>\n<li>之后调用<font color=\"pink\" size=\"4\">vm.$mount(el)</font>方法, 进行Vue的mounted。</li>\n<li>在这之前用一个字段mount存储目标的自定义mounted方法后调用公用的mounted方法，在mounted过程中调用<font color=\"pink\" size=\"4\">compilerToFunctions()</font>方法返回一个render函数(一个with关键字函数，切设计虚拟DOM树)，并设置<font color=\"pink\" size=\"4\">options.render = render</font>。</li>\n<li>在公用的mounted方法后有一个<font color=\"pink\" size=\"4\">return mount.call(this, el, hydrating)</font>方法，开始调用自定义的mounted方法。</li>\n<li>在自定义mounted方法中，调用<font color=\"pink\" size=\"4\">mountComponent()</font>完成观察者模式：实例Watcher类。</li>\n<li>每个Watcher类在constructor中会调用<font color=\"pink\" size=\"4\">this.value = this.lazy ? undefined : this.get()</font>, 而this.get()方法将自身依赖push给全局的targetStack数组中，并把Dep.target的指向指为当前Watcher。 当要获取属性的值的时候，相应属性自身的get方法之前，将会被之前observer数据拦截，此时Dep.target就存在值，就调用了内部的<font color=\"pink\" size=\"4\">dep.depend()</font>方法实现依赖关系，将当前Watcher放入当前Dep中，等待后期的数据更新。这样就行成了一个依赖环。</li>\n</ol>\n</blockquote>\n<p>最后贴一下官网的生命周期图<a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\" target=\"_blank\" rel=\"noopener\">Vue生命周期</a></p>\n<p>Vue的详细模板编译原理<a href=\"https://github.com/berwin/Blog/issues/18\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><br></p>\n<h1 id=\"观察者模式设计\"><a href=\"#观察者模式设计\" class=\"headerlink\" title=\"观察者模式设计\"></a>观察者模式设计</h1><p>在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。(来自wiki百科)</p>\n<p>例：小明去买房（观察者Observer），去找房产中心（目标主体Subject），发布者说等有合适的就通知小明。这样就形成了一个环</p>\n<h1 id=\"发布订阅模式设计\"><a href=\"#发布订阅模式设计\" class=\"headerlink\" title=\"发布订阅模式设计\"></a>发布订阅模式设计</h1><p>在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。(来自wiki百科)</p>\n<p>例：小明去买房（订阅者Subscriber），委托第三方中介去买房（调度中心Event Channel），等待第三方中介回馈消息，过了一会房产中心（发布者Publisher）发布消息给第三方中介，第三方中介发现正好符合小明的要求（key）就去通知小明。</p>\n<h1 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h1><p><img src=\"https://user-gold-cdn.xitu.io/2017/11/22/15fe1b1f174cd376?imageslim\"></p>\n<p>图片来源: <a href=\"http://developers-club.com/posts/270339/\" target=\"_blank\" rel=\"noopener\">developers-club</a></p>\n<blockquote>\n<ol>\n<li>在观察者模式中，观察者是知道主体Subject的，而Subject一直保持对观察者的记录。相反在发布订阅中，两者并不互相了解，只能通过代理进行沟通。</li>\n<li>观察者模式大多数是同步，如：事件触发，而发布订阅模式大多数是异步，如：消息队列。</li>\n<li>观察者模式是一种紧耦合状态，而发布订阅模式是一种松耦合的状态。</li>\n<li>观察者模式是通过主体本身去遍历观察者（维护的是观察者），然后调用订阅者的通知方法去实现。而发布订阅则是通过事件管道去通知（维护的是事件）。</li>\n</ol>\n</blockquote>\n<h1 id=\"MVVM和MVC的区别\"><a href=\"#MVVM和MVC的区别\" class=\"headerlink\" title=\"MVVM和MVC的区别\"></a>MVVM和MVC的区别</h1><p>MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>\n<p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>\n<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>\n<p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 </p>\n<h1 id=\"回到Vue\"><a href=\"#回到Vue\" class=\"headerlink\" title=\"回到Vue\"></a>回到Vue</h1><p>Vue的双向绑定则是利用了观察者模式实现的。<br>参考链接：<a href=\"https://segmentfault.com/a/1190000013338801\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000013338801</a></p>\n<pre>\n<code>\nclass Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 为了标明该对象已经被observer过\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n</any></code>\n</pre>\n\n <pre><code>\n // 拦截数据\n export function defineReactive (\n   obj: Object,\n   key: string,\n   val: any,\n   customSetter?: ?Function,\n   shallow?: boolean\n ) {\n   const dep = new Dep()\n\n   const property = Object.getOwnPropertyDescriptor(obj, key)\n   if (property && property.configurable === false) {\n     return\n   }\n\n   // cater for pre-defined getter/setters\n   const getter = property && property.get\n   const setter = property && property.set\n   if ((!getter || setter) && arguments.length === 2) {\n     val = obj[key]\n   }\n\n   let childOb = !shallow && observe(val)\n   Object.defineProperty(obj, key, {\n     enumerable: true,\n     configurable: true,\n     get: function reactiveGetter () {\n       const value = getter ? getter.call(obj) : val\n       if (Dep.target) {\n         dep.depend()\n         if (childOb) {\n           childOb.dep.depend()\n           if (Array.isArray(value)) {\n             dependArray(value)\n           }\n         }\n       }\n       return value\n     },\n     set: function reactiveSetter (newVal) {\n       const value = getter ? getter.call(obj) : val\n       /* eslint-disable no-self-compare */\n       if (newVal === value || (newVal !== newVal && value !== value)) {\n         return\n       }\n       /* eslint-enable no-self-compare */\n       if (process.env.NODE_ENV !== 'production' && customSetter) {\n         customSetter()\n       }\n       // #7981: for accessor properties without setter\n       if (getter && !setter) return\n       if (setter) {\n         setter.call(obj, newVal)\n       } else {\n         val = newVal\n       }\n       childOb = !shallow && observe(newVal)\n       // 使当前的调度中心通知所有Watcher\n       dep.notify()\n     }\n   })\n }\n </code></pre>\n\n<p> Vue模版渲染</p>\n<p> 在执行npm run dev或者npm run build的时候，Vue使用rollup进行编译，入口文件为entry-runtime-with-compiler.js，<br> 该文件有以下代码，在runtime的时候执行<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry-runtime-with-compiler.js，</span><br><span class=\"line\">import Vue from &apos;./runtime/index&apos;</span><br></pre></td></tr></table></figure></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// runtime/index.js</span><br><span class=\"line\">import Vue from &apos;core/index&apos;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // core/index.js</span><br><span class=\"line\"> // 导入Vue的实例，初始化全局Api</span><br><span class=\"line\">import Vue from &apos;./instance/index&apos;</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;</span><br><span class=\"line\">import &#123; isServerRendering &#125; from &apos;core/util/env&apos;</span><br><span class=\"line\">import &#123; FunctionalRenderContext &#125; from &apos;core/vdom/create-functional-component&apos;</span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123;</span><br><span class=\"line\">  get: isServerRendering</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$ssrContext&apos;, &#123;</span><br><span class=\"line\">  get () &#123;</span><br><span class=\"line\">    /* istanbul ignore next */</span><br><span class=\"line\">    return this.$vnode &amp;&amp; this.$vnode.ssrContext</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// expose FunctionalRenderContext for ssr runtime helper installation</span><br><span class=\"line\">Object.defineProperty(Vue, &apos;FunctionalRenderContext&apos;, &#123;</span><br><span class=\"line\">  value: FunctionalRenderContext</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.version = &apos;__VERSION__&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// instance/index.js</span><br><span class=\"line\">// 做Vue的各种模块混</span><br><span class=\"line\">// 每当new Vue的时候执行初始化</span><br><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 初始化混入 *</span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\">// 事件混入</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\">// 生命周期的混入 *</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\">// render函数混入 *</span><br><span class=\"line\">renderMixin(Vue)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 走进this._init(options)方法</span><br><span class=\"line\">// 最主要的是</span><br><span class=\"line\">// 触发Vue原型上的$mount方法，进行compile。compiler/index.js会返回render函数和sataicRenderFns函数。等待renderMixin函数的使用。</span><br><span class=\"line\">    if (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在render.js的renderMixi方法中使用了以下方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// core/instance/render.js文件中 line:83</span><br><span class=\"line\">// 这里就是将template进行转换</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// render方法 ，由compiler方法返回，功能是使用with语句的作用是将代码的作用域设置到一个特定的作用域中。之后的msg的都是访问的this中的属性，而this就是</span><br><span class=\"line\">// vm._renderProxy（vm的一个代理实例），由于Vue自己的proxy方法会将this.data.msg的值的获取改为this.msg，因此msg就变成了</span><br><span class=\"line\">// options中的data的一个值传入。经过_c (createElement)方法完成template模版的替换。</span><br><span class=\"line\">(function anonymous(</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">with(this)&#123;return _c(&apos;div&apos;,&#123;attrs:&#123;&quot;id&quot;:&quot;el&quot;&#125;&#125;,[_v(&quot;\\n  &quot;+_s(msg)+_s(msg)+&quot;\\n&quot;)])&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>###梳理下Vue初始化流程：</p>\n<blockquote>\n<ol>\n<li>在<font color=\"pink\" size=\"4\">new</font>实例Vue的时候，调用<font color=\"pink\" size=\"4\">this._init(options)</font>方法将传入的对象作为$options属性存在Vue实例中。并将各种组件的props，父子组件的inject属性和指令进行合并，开始走created流程。</li>\n<li>执行了<font color=\"pink\" size=\"4\">initState()</font>方法，对所有数据包括(props和methods)进行拦截，给数据进行observer，并且给被observer过的属性增加ob属性标识，来表示已经被observer。【数据拦截原理见上方观察者模式】<blockquote>\n<font color=\"grey\" size=\"2\">补充:由于遍历对象的属性，则每个对象都会有一个Dep，且一个Dep可能会有许多Watcher，因为可能这个属性的值被多处使用，所以当数据改变，则遍历触发自身的所有的Watcher。即dep.notify() =&gt; Array.forEach.update</font></blockquote>\n</li>\n<li>之后调用<font color=\"pink\" size=\"4\">vm.$mount(el)</font>方法, 进行Vue的mounted。</li>\n<li>在这之前用一个字段mount存储目标的自定义mounted方法后调用公用的mounted方法，在mounted过程中调用<font color=\"pink\" size=\"4\">compilerToFunctions()</font>方法返回一个render函数(一个with关键字函数，切设计虚拟DOM树)，并设置<font color=\"pink\" size=\"4\">options.render = render</font>。</li>\n<li>在公用的mounted方法后有一个<font color=\"pink\" size=\"4\">return mount.call(this, el, hydrating)</font>方法，开始调用自定义的mounted方法。</li>\n<li>在自定义mounted方法中，调用<font color=\"pink\" size=\"4\">mountComponent()</font>完成观察者模式：实例Watcher类。</li>\n<li>每个Watcher类在constructor中会调用<font color=\"pink\" size=\"4\">this.value = this.lazy ? undefined : this.get()</font>, 而this.get()方法将自身依赖push给全局的targetStack数组中，并把Dep.target的指向指为当前Watcher。 当要获取属性的值的时候，相应属性自身的get方法之前，将会被之前observer数据拦截，此时Dep.target就存在值，就调用了内部的<font color=\"pink\" size=\"4\">dep.depend()</font>方法实现依赖关系，将当前Watcher放入当前Dep中，等待后期的数据更新。这样就行成了一个依赖环。</li>\n</ol>\n</blockquote>\n<p>最后贴一下官网的生命周期图<a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\" target=\"_blank\" rel=\"noopener\">Vue生命周期</a></p>\n<p>Vue的详细模板编译原理<a href=\"https://github.com/berwin/Blog/issues/18\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}